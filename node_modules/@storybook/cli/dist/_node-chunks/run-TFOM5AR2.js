import CJS_COMPAT_NODE_URL_zv09hezec4 from 'node:url';
import CJS_COMPAT_NODE_PATH_zv09hezec4 from 'node:path';
import CJS_COMPAT_NODE_MODULE_zv09hezec4 from "node:module";

var __filename = CJS_COMPAT_NODE_URL_zv09hezec4.fileURLToPath(import.meta.url);
var __dirname = CJS_COMPAT_NODE_PATH_zv09hezec4.dirname(__filename);
var require = CJS_COMPAT_NODE_MODULE_zv09hezec4.createRequire(import.meta.url);

// ------------------------------------------------------------
// end of CJS compatibility banner, injected by Storybook's esbuild configuration
// ------------------------------------------------------------
import {
  bannerComment,
  containsDirnameUsage,
  containsESMUsage,
  containsFilenameUsage,
  containsRequireUsage,
  findFilesUp,
  getFrameworkPackageName,
  getProjects,
  getStorybookData,
  hasRequireBanner,
  processAutoblockerResults,
  require_picocolors,
  shortenPath,
  updateMainConfig,
  upgradeStorybookDependencies
} from "./chunk-UGMDECHZ.js";
import {
  slash
} from "./chunk-F745V6PN.js";
import {
  require_semver
} from "./chunk-XFVW7Z75.js";
import {
  __commonJS,
  __name,
  __require,
  __toESM
} from "./chunk-OQELV2SQ.js";

// ../../node_modules/envinfo/dist/envinfo.js
var require_envinfo = __commonJS({
  "../../node_modules/envinfo/dist/envinfo.js"(exports, module) {
    (() => {
      var e = { 2980: (e2, t11, r2) => {
        "use strict";
        r2(7360), r2(5888), r2(8412), r2(3852), r2(5584);
        var n = r2(9892), o = r2(5008), i = r2(5088), s = r2(224);
        function a(e3, t12) {
          (t12 = t12 || {}).clipboard && console.log("\n*** Clipboard option removed - use clipboardy or clipboard-cli directly ***\n");
          var r3 = Object.keys(e3).length > 0 ? e3 : i.defaults, s2 = Object.entries(r3).reduce(function(e4, r4) {
            var o2 = r4[0], i2 = r4[1], s3 = n[`get${o2}`];
            return s3 ? (i2 && e4.push(s3(i2, t12)), e4) : e4 = e4.concat((i2 || []).map(function(e5) {
              var t13 = n[`get${e5.replace(/\s/g, "")}Info`];
              return t13 ? t13() : Promise.resolve(["Unknown"]);
            }));
          }, []);
          return Promise.all(s2).then(function(e4) {
            var r4 = e4.reduce(function(e5, t13) {
              return t13 && t13[0] && Object.assign(e5, { [t13[0]]: t13 }), e5;
            }, {});
            return function(e5, t13) {
              var r5 = t13.json ? o.json : t13.markdown ? o.markdown : o.yaml;
              if (t13.console) {
                var n2 = false;
                process.stdout.isTTY && (n2 = true), console.log(r5(e5, Object.assign({}, t13, { console: n2 })));
              }
              return r5(e5, Object.assign({}, t13, { console: false }));
            }(Object.entries(i.defaults).reduce(function(e5, t13) {
              var n2 = t13[0], o2 = t13[1];
              return r4[n2] ? Object.assign(e5, { [n2]: r4[n2][1] }) : Object.assign(e5, { [n2]: (o2 || []).reduce(function(e6, t14) {
                return r4[t14] ? (r4[t14].shift(), 1 === r4[t14].length ? Object.assign(e6, { [t14]: r4[t14][0] }) : Object.assign(e6, { [t14]: { version: r4[t14][0], path: r4[t14][1] } })) : e6;
              }, {}) });
            }, {}), t12);
          });
        }
        __name(a, "a");
        e2.exports = { cli: /* @__PURE__ */ __name(function(e3) {
          if (e3.all) return a(Object.assign({}, i.defaults, { npmPackages: true, npmGlobalPackages: true }), e3);
          if (e3.raw) return a(JSON.parse(e3.raw), e3);
          if (e3.helper) {
            var t12 = n[`get${e3.helper}`] || n[`get${e3.helper}Info`] || n[e3.helper];
            return t12 ? t12().then(console.log) : console.error("Not Found");
          }
          var r3 = /* @__PURE__ */ __name(function(e4, t13) {
            return e4.toLowerCase().includes(t13.toLowerCase());
          }, "r"), o2 = Object.keys(e3).filter(function(e4) {
            return Object.keys(i.defaults).some(function(t13) {
              return r3(t13, e4);
            });
          }), c = Object.entries(i.defaults).reduce(function(t13, n2) {
            return o2.some(function(e4) {
              return r3(e4, n2[0]);
            }) ? Object.assign(t13, { [n2[0]]: n2[1] || e3[n2[0]] }) : t13;
          }, {});
          return e3.preset ? i[e3.preset] ? a(Object.assign({}, s.omit(i[e3.preset], ["options"]), c), Object.assign({}, i[e3.preset].options, s.pick(e3, ["duplicates", "fullTree", "json", "markdown", "console"]))) : console.error(`
No "${e3.preset}" preset found.`) : a(c, e3);
        }, "cli"), helpers: n, main: a, run: /* @__PURE__ */ __name(function(e3, t12) {
          return "string" == typeof e3.preset ? a(i[e3.preset], t12) : a(e3, t12);
        }, "run") };
      }, 5008: (e2, t11, r2) => {
        "use strict";
        r2(223), r2(3852), r2(4880), r2(3708), r2(5584), r2(5308);
        var n = r2(6232), o = r2(224);
        function i(e3, t12) {
          return o.log("trace", "clean", e3), Object.keys(e3).reduce(function(r3, n2) {
            return !t12.showNotFound && "Not Found" === e3[n2] || "N/A" === e3[n2] || void 0 === e3[n2] || 0 === Object.keys(e3[n2]).length ? r3 : o.isObject(e3[n2]) ? Object.values(e3[n2]).every(function(e4) {
              return "N/A" === e4 || !t12.showNotFound && "Not Found" === e4;
            }) ? r3 : Object.assign(r3, { [n2]: i(e3[n2], t12) }) : Object.assign(r3, { [n2]: e3[n2] });
          }, {});
        }
        __name(i, "i");
        function s(e3, t12) {
          o.log("trace", "formatHeaders"), t12 || (t12 = { type: "underline" });
          var r3 = { underline: ["\x1B[4m", "\x1B[0m"] };
          return e3.slice().split("\n").map(function(e4) {
            if (":" === e4.slice("-1")) {
              var n2 = e4.match(/^[\s]*/g)[0];
              return `${n2}${r3[t12.type][0]}${e4.slice(n2.length)}${r3[t12.type][1]}`;
            }
            return e4;
          }).join("\n");
        }
        __name(s, "s");
        function a(e3) {
          return o.log("trace", "formatPackages"), e3.npmPackages ? Object.assign(e3, { npmPackages: Object.entries(e3.npmPackages || {}).reduce(function(e4, t12) {
            var r3 = t12[0], n2 = t12[1];
            if ("Not Found" === n2) return Object.assign(e4, { [r3]: n2 });
            var o2 = n2.wanted ? `${n2.wanted} =>` : "", i2 = Array.isArray(n2.installed) ? n2.installed.join(", ") : n2.installed, s2 = n2.duplicates ? `(${n2.duplicates.join(", ")})` : "";
            return Object.assign(e4, { [r3]: `${o2} ${i2} ${s2}` });
          }, {}) }) : e3;
        }
        __name(a, "a");
        function c(e3, t12, r3) {
          return r3 || (r3 = { emptyMessage: "None" }), Array.isArray(t12) && (t12 = t12.length > 0 ? t12.join(", ") : r3.emptyMessage), { [e3]: t12 };
        }
        __name(c, "c");
        function u(e3, t12) {
          return Object.entries(e3).reduce(function(e4, r3) {
            var n2 = r3[0], i2 = r3[1];
            return o.isObject(i2) ? Object.assign(e4, { [n2]: u(i2, t12) }) : Object.assign(e4, t12(n2, i2));
          }, {});
        }
        __name(u, "u");
        function l(e3) {
          return o.log("trace", "serializeArrays"), u(e3, c);
        }
        __name(l, "l");
        function f(e3) {
          return o.log("trace", "serializeVersionsAndPaths"), Object.entries(e3).reduce(function(e4, t12) {
            return Object.assign(e4, { [t12[0]]: Object.entries(t12[1]).reduce(function(e5, t13) {
              var r3 = t13[0], n2 = t13[1];
              return n2.version ? Object.assign(e5, { [r3]: [n2.version, n2.path].filter(Boolean).join(" - ") }) : Object.assign(e5, { [r3]: [n2][0] });
            }, {}) }, {});
          }, {});
        }
        __name(f, "f");
        function p(e3) {
          return n(e3, { indent: "  ", prefix: "\n", postfix: "\n" });
        }
        __name(p, "p");
        function h(e3) {
          return e3.slice().split("\n").map(function(e4) {
            if ("" !== e4) {
              var t12 = ":" === e4.slice("-1"), r3 = e4.search(/\S|$/);
              return t12 ? `${"#".repeat(r3 / 2 + 1)} ` + e4.slice(r3) : " - " + e4.slice(r3);
            }
            return "";
          }).join("\n");
        }
        __name(h, "h");
        function d(e3, t12) {
          return t12 || (t12 = { indent: "  " }), JSON.stringify(e3, null, t12.indent);
        }
        __name(d, "d");
        e2.exports = { json: /* @__PURE__ */ __name(function(e3, t12) {
          return o.log("trace", "formatToJson"), t12 || (t12 = {}), e3 = o.pipe([function() {
            return i(e3, t12);
          }, t12.title ? function(e4) {
            return { [t12.title]: e4 };
          } : o.noop, d])(e3), e3 = t12.console ? `
${e3}
` : e3;
        }, "json"), markdown: /* @__PURE__ */ __name(function(e3, t12) {
          return o.log("trace", "formatToMarkdown"), o.pipe([function() {
            return i(e3, t12);
          }, a, l, f, p, h, t12.title ? function(e4) {
            return `
# ${t12.title}${e4}`;
          } : o.noop])(e3, t12);
        }, "markdown"), yaml: /* @__PURE__ */ __name(function(e3, t12) {
          return o.log("trace", "formatToYaml", t12), o.pipe([function() {
            return i(e3, t12);
          }, a, l, f, t12.title ? function(e4) {
            return { [t12.title]: e4 };
          } : o.noop, p, t12.console ? s : o.noop])(e3, t12);
        }, "yaml") };
      }, 6732: (e2, t11, r2) => {
        "use strict";
        r2(5888);
        var n = r2(224);
        e2.exports = { getNodeInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getNodeInfo"), Promise.all([n.isWindows ? n.run("node -v").then(n.findVersion) : n.which("node").then(function(e3) {
            return e3 ? n.run(e3 + " -v") : Promise.resolve("");
          }).then(n.findVersion), n.which("node").then(n.condensePath)]).then(function(e3) {
            return n.determineFound("Node", e3[0], e3[1]);
          });
        }, "getNodeInfo"), getnpmInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getnpmInfo"), Promise.all([n.run("npm -v"), n.which("npm").then(n.condensePath)]).then(function(e3) {
            return n.determineFound("npm", e3[0], e3[1]);
          });
        }, "getnpmInfo"), getWatchmanInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getWatchmanInfo"), Promise.all([n.which("watchman").then(function(e3) {
            return e3 ? n.run(e3 + " -v") : void 0;
          }), n.which("watchman")]).then(function(e3) {
            return n.determineFound("Watchman", e3[0], e3[1]);
          });
        }, "getWatchmanInfo"), getYarnInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getYarnInfo"), Promise.all([n.run("yarn -v"), n.which("yarn").then(n.condensePath)]).then(function(e3) {
            return n.determineFound("Yarn", e3[0], e3[1]);
          });
        }, "getYarnInfo"), getpnpmInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getpnpmInfo"), Promise.all([n.run("pnpm -v"), n.which("pnpm").then(n.condensePath)]).then(function(e3) {
            return n.determineFound("pnpm", e3[0], e3[1]);
          });
        }, "getpnpmInfo"), getbunInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getbunInfo"), Promise.all([n.run("bun -v"), n.which("bun").then(n.condensePath)]).then(function(e3) {
            return n.determineFound("bun", e3[0], e3[1]);
          });
        }, "getbunInfo") };
      }, 2524: (e2, t11, r2) => {
        "use strict";
        r2(3708), r2(5888), r2(8412);
        var n = r2(2058), o = r2(8558), i = r2(224), s = r2(7072);
        function a(e3, t12) {
          var r3;
          return (i.isLinux ? i.run("firefox --version").then(function(e4) {
            return e4.replace(/^.* ([^ ]*)/g, "$1");
          }) : i.isMacOS && "string" == typeof e3 && e3 ? i.getDarwinApplicationVersion(e3) : i.isWindows && "string" == typeof t12 && t12 ? i.windowsExeExists(t12).then(function(e4) {
            return r3 = e4, e4 ? i.run(`powershell ". '${e4}' -v | Write-Output"`).then(function(e5) {
              return i.findVersion(e5);
            }) : i.NA;
          }) : Promise.resolve(i.NA)).then(function(e4) {
            return i.determineFound("Firefox", e4, r3 || i.NA);
          });
        }
        __name(a, "a");
        e2.exports = { getBraveBrowserInfo: /* @__PURE__ */ __name(function() {
          return i.log("trace", "getBraveBrowser"), (i.isLinux ? i.run("brave --version || brave-browser --version").then(function(e3) {
            return e3.replace(/^.* ([^ ]*)/g, "$1");
          }) : i.isMacOS ? i.getDarwinApplicationVersion(i.browserBundleIdentifiers["Brave Browser"]).then(i.findVersion) : Promise.resolve("N/A")).then(function(e3) {
            return i.determineFound("Brave Browser", e3, "N/A");
          });
        }, "getBraveBrowserInfo"), getChromeInfo: /* @__PURE__ */ __name(function() {
          var e3;
          if (i.log("trace", "getChromeInfo"), i.isLinux) e3 = i.run("google-chrome --version").then(function(e4) {
            return e4.replace(" dev", "").replace(/^.* ([^ ]*)/g, "$1");
          });
          else if (i.isMacOS) e3 = i.getDarwinApplicationVersion(i.browserBundleIdentifiers.Chrome).then(i.findVersion);
          else if (i.isWindows) {
            var t12;
            try {
              t12 = i.findVersion(n.readdirSync(s.join(process.env["ProgramFiles(x86)"], "Google/Chrome/Application")).join("\n"));
            } catch (e4) {
              t12 = i.NotFound;
            }
            e3 = Promise.resolve(t12);
          } else e3 = Promise.resolve("N/A");
          return e3.then(function(e4) {
            return i.determineFound("Chrome", e4, "N/A");
          });
        }, "getChromeInfo"), getChromeCanaryInfo: /* @__PURE__ */ __name(function() {
          return i.log("trace", "getChromeCanaryInfo"), i.getDarwinApplicationVersion(i.browserBundleIdentifiers["Chrome Canary"]).then(function(e3) {
            return i.determineFound("Chrome Canary", e3, "N/A");
          });
        }, "getChromeCanaryInfo"), getChromiumInfo: /* @__PURE__ */ __name(function() {
          return i.log("trace", "getChromiumInfo"), (i.isLinux ? i.run("chromium --version").then(i.findVersion) : Promise.resolve("N/A")).then(function(e3) {
            return i.determineFound("Chromium", e3, "N/A");
          });
        }, "getChromiumInfo"), getEdgeInfo: /* @__PURE__ */ __name(function() {
          var e3;
          if (i.log("trace", "getEdgeInfo"), i.isWindows && "10" === o.release().split(".")[0]) {
            var t12 = { Spartan: "Microsoft.MicrosoftEdge", Chromium: "Microsoft.MicrosoftEdge.Stable", ChromiumDev: "Microsoft.MicrosoftEdge.Dev" };
            e3 = Promise.all(Object.keys(t12).map(function(e4) {
              return function(e5, t13) {
                return i.run(`powershell get-appxpackage ${e5}`).then(function(e6) {
                  if ("" !== i.findVersion(e6)) return `${t13} (${i.findVersion(e6)})`;
                });
              }(t12[e4], e4);
            }).filter(function(e4) {
              return void 0 !== e4;
            }));
          } else {
            if (!i.isMacOS) return Promise.resolve("N/A");
            e3 = i.getDarwinApplicationVersion(i.browserBundleIdentifiers["Microsoft Edge"]);
          }
          return e3.then(function(e4) {
            return i.determineFound("Edge", Array.isArray(e4) ? e4.filter(function(e5) {
              return void 0 !== e5;
            }) : e4, i.NA);
          });
        }, "getEdgeInfo"), getFirefoxInfo: /* @__PURE__ */ __name(function() {
          i.log("trace", "getFirefoxInfo"), a(i.browserBundleIdentifiers.Firefox, "Mozilla Firefox/firefox.exe");
        }, "getFirefoxInfo"), getFirefoxDeveloperEditionInfo: /* @__PURE__ */ __name(function() {
          i.log("trace", "getFirefoxDeveloperEditionInfo"), a(i.browserBundleIdentifiers["Firefox Developer Edition"], "Firefox Developer Edition/firefox.exe");
        }, "getFirefoxDeveloperEditionInfo"), getFirefoxNightlyInfo: /* @__PURE__ */ __name(function() {
          return i.log("trace", "getFirefoxNightlyInfo"), (i.isLinux ? i.run("firefox-trunk --version").then(function(e3) {
            return e3.replace(/^.* ([^ ]*)/g, "$1");
          }) : i.isMacOS ? i.getDarwinApplicationVersion(i.browserBundleIdentifiers["Firefox Nightly"]) : Promise.resolve("N/A")).then(function(e3) {
            return i.determineFound("Firefox Nightly", e3, "N/A");
          });
        }, "getFirefoxNightlyInfo"), getInternetExplorerInfo: /* @__PURE__ */ __name(function() {
          var e3;
          if (i.log("trace", "getInternetExplorerInfo"), i.isWindows) {
            var t12 = [process.env.SYSTEMDRIVE || "C:", "Program Files", "Internet Explorer", "iexplore.exe"].join("\\\\");
            e3 = i.run(`wmic datafile where "name='${t12}'" get Version`).then(i.findVersion);
          } else e3 = Promise.resolve("N/A");
          return e3.then(function(e4) {
            return i.determineFound("Internet Explorer", e4, "N/A");
          });
        }, "getInternetExplorerInfo"), getSafariTechnologyPreviewInfo: /* @__PURE__ */ __name(function() {
          return i.log("trace", "getSafariTechnologyPreviewInfo"), i.getDarwinApplicationVersion(i.browserBundleIdentifiers["Safari Technology Preview"]).then(function(e3) {
            return i.determineFound("Safari Technology Preview", e3, "N/A");
          });
        }, "getSafariTechnologyPreviewInfo"), getSafariInfo: /* @__PURE__ */ __name(function() {
          return i.log("trace", "getSafariInfo"), i.getDarwinApplicationVersion(i.browserBundleIdentifiers.Safari).then(function(e3) {
            return i.determineFound("Safari", e3, "N/A");
          });
        }, "getSafariInfo") };
      }, 6620: (e2, t11, r2) => {
        "use strict";
        r2(7360), r2(5888);
        var n = r2(224);
        e2.exports = { getMongoDBInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getMongoDBInfo"), Promise.all([n.run("mongo --version").then(n.findVersion), n.which("mongo")]).then(function(e3) {
            return n.determineFound("MongoDB", e3[0], e3[1]);
          });
        }, "getMongoDBInfo"), getMySQLInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getMySQLInfo"), Promise.all([n.run("mysql --version").then(function(e3) {
            return `${n.findVersion(e3, null, 1)}${e3.includes("MariaDB") ? " (MariaDB)" : ""}`;
          }), n.which("mysql")]).then(function(e3) {
            return n.determineFound("MySQL", e3[0], e3[1]);
          });
        }, "getMySQLInfo"), getPostgreSQLInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getPostgreSQLInfo"), Promise.all([n.run("postgres --version").then(n.findVersion), n.which("postgres")]).then(function(e3) {
            return n.determineFound("PostgreSQL", e3[0], e3[1]);
          });
        }, "getPostgreSQLInfo"), getSQLiteInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getSQLiteInfo"), Promise.all([n.run("sqlite3 --version").then(n.findVersion), n.which("sqlite3")]).then(function(e3) {
            return n.determineFound("SQLite", e3[0], e3[1]);
          });
        }, "getSQLiteInfo") };
      }, 3224: (e2, t11, r2) => {
        "use strict";
        r2(3708), r2(8412), r2(5888);
        var n = r2(7072), o = r2(224);
        e2.exports = { getAndroidStudioInfo: /* @__PURE__ */ __name(function() {
          var e3 = Promise.resolve("N/A");
          if (o.isMacOS) {
            var t12 = [n.join("/", "Applications", "Android Studio.app", "Contents", "Info.plist"), n.join(process.env.HOME, "Applications", "Android Studio.app", "Contents", "Info.plist"), n.join("/", "Applications", "JetBrains Toolbox", "Android Studio.app", "Contents", "Info.plist"), n.join(process.env.HOME, "Applications", "JetBrains Toolbox", "Android Studio.app", "Contents", "Info.plist")];
            e3 = Promise.all(t12.map(function(e4) {
              return o.fileExists(e4).then(function(t13) {
                if (!t13) return null;
                var r3 = o.generatePlistBuddyCommand(e4.replace(/ /g, "\\ "), ["CFBundleShortVersionString", "CFBundleVersion"]);
                return o.run(r3).then(function(e5) {
                  return e5.split("\n").join(" ");
                });
              });
            })).then(function(e4) {
              return e4.find(function(e5) {
                return null !== e5;
              }) || o.NotFound;
            });
          } else o.isLinux ? e3 = Promise.all([o.run('cat /opt/android-studio/bin/studio.sh | grep "$Home/.AndroidStudio" | head -1').then(o.findVersion), o.run("cat /opt/android-studio/build.txt")]).then(function(e4) {
            return `${e4[0]} ${e4[1]}`.trim() || o.NotFound;
          }) : o.isWindows && (e3 = Promise.all([o.run('wmic datafile where name="C:\\\\Program Files\\\\Android\\\\Android Studio\\\\bin\\\\studio.exe" get Version').then(function(e4) {
            return e4.replace(/(\r\n|\n|\r)/gm, "");
          }), o.run('type "C:\\\\Program Files\\\\Android\\\\Android Studio\\\\build.txt"').then(function(e4) {
            return e4.replace(/(\r\n|\n|\r)/gm, "");
          })]).then(function(e4) {
            return `${e4[0]} ${e4[1]}`.trim() || o.NotFound;
          }));
          return e3.then(function(e4) {
            return o.determineFound("Android Studio", e4);
          });
        }, "getAndroidStudioInfo"), getAtomInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getAtomInfo"), Promise.all([o.getDarwinApplicationVersion(o.ideBundleIdentifiers.Atom), "N/A"]).then(function(e3) {
            return o.determineFound("Atom", e3[0], e3[1]);
          });
        }, "getAtomInfo"), getEmacsInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getEmacsInfo"), o.isMacOS || o.isLinux ? Promise.all([o.run("emacs --version").then(o.findVersion), o.run("which emacs")]).then(function(e3) {
            return o.determineFound("Emacs", e3[0], e3[1]);
          }) : Promise.resolve(["Emacs", "N/A"]);
        }, "getEmacsInfo"), getIntelliJInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getIntelliJInfo"), o.getDarwinApplicationVersion(o.ideBundleIdentifiers.IntelliJ).then(function(e3) {
            return o.determineFound("IntelliJ", e3);
          });
        }, "getIntelliJInfo"), getNanoInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getNanoInfo"), o.isLinux ? Promise.all([o.run("nano --version").then(o.findVersion), o.run("which nano")]).then(function(e3) {
            return o.determineFound("Nano", e3[0], e3[1]);
          }) : Promise.resolve(["Nano", "N/A"]);
        }, "getNanoInfo"), getNvimInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getNvimInfo"), o.isMacOS || o.isLinux ? Promise.all([o.run("nvim --version").then(o.findVersion), o.run("which nvim")]).then(function(e3) {
            return o.determineFound("Nvim", e3[0], e3[1]);
          }) : Promise.resolve(["Vim", "N/A"]);
        }, "getNvimInfo"), getPhpStormInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getPhpStormInfo"), o.getDarwinApplicationVersion(o.ideBundleIdentifiers.PhpStorm).then(function(e3) {
            return o.determineFound("PhpStorm", e3);
          });
        }, "getPhpStormInfo"), getSublimeTextInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getSublimeTextInfo"), Promise.all([o.run("subl --version").then(function(e3) {
            return o.findVersion(e3, /\d+/);
          }), o.which("subl")]).then(function(e3) {
            return "" === e3[0] && o.isMacOS ? (o.log("trace", "getSublimeTextInfo using plist"), Promise.all([o.getDarwinApplicationVersion(o.ideBundleIdentifiers["Sublime Text"]), "N/A"])) : e3;
          }).then(function(e3) {
            return o.determineFound("Sublime Text", e3[0], e3[1]);
          });
        }, "getSublimeTextInfo"), getVimInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getVimInfo"), o.isMacOS || o.isLinux ? Promise.all([o.run("vim --version").then(o.findVersion), o.run("which vim")]).then(function(e3) {
            return o.determineFound("Vim", e3[0], e3[1]);
          }) : Promise.resolve(["Vim", "N/A"]);
        }, "getVimInfo"), getVSCodeInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getVSCodeInfo"), Promise.all([o.run("code --version").then(o.findVersion), o.which("code")]).then(function(e3) {
            return o.determineFound("VSCode", e3[0], e3[1]);
          });
        }, "getVSCodeInfo"), getVisualStudioInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getVisualStudioInfo"), o.isWindows ? o.run(`"${process.env["ProgramFiles(x86)"]}/Microsoft Visual Studio/Installer/vswhere.exe" -format json -prerelease`).then(function(e3) {
            var t12 = JSON.parse(e3).map(function(e4) {
              return { Version: e4.installationVersion, DisplayName: e4.displayName };
            });
            return o.determineFound("Visual Studio", t12.map(function(e4) {
              return `${e4.Version} (${e4.DisplayName})`;
            }));
          }).catch(function() {
            return Promise.resolve(["Visual Studio", o.NotFound]);
          }) : Promise.resolve(["Visual Studio", o.NA]);
        }, "getVisualStudioInfo"), getWebStormInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getWebStormInfo"), o.getDarwinApplicationVersion(o.ideBundleIdentifiers.WebStorm).then(function(e3) {
            return o.determineFound("WebStorm", e3);
          });
        }, "getWebStormInfo"), getXcodeInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getXcodeInfo"), o.isMacOS ? Promise.all([o.which("xcodebuild").then(function(e3) {
            return o.run(e3 + " -version");
          }).then(function(e3) {
            return `${o.findVersion(e3)}/${e3.split("Build version ")[1]}`;
          }), o.which("xcodebuild")]).then(function(e3) {
            return o.determineFound("Xcode", e3[0], e3[1]);
          }) : Promise.resolve(["Xcode", "N/A"]);
        }, "getXcodeInfo") };
      }, 9892: (e2, t11, r2) => {
        "use strict";
        function n(e3, t12, r3) {
          return t12 in e3 ? Object.defineProperty(e3, t12, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t12] = r3, e3;
        }
        __name(n, "n");
        r2(5584);
        var o = r2(6304), i = r2(224), s = r2(6732), a = r2(2524), c = r2(6620), u = r2(3224), l = r2(6436), f = r2(760), p = r2(2060), h = r2(7508), d = r2(9284), m = r2(8144), g = r2(5882), v = r2(9676);
        e2.exports = Object.assign({}, i, o, function(e3) {
          for (var t12 = 1; t12 < arguments.length; t12++) {
            var r3 = null != arguments[t12] ? arguments[t12] : {}, o2 = Object.keys(r3);
            "function" == typeof Object.getOwnPropertySymbols && (o2 = o2.concat(Object.getOwnPropertySymbols(r3).filter(function(e4) {
              return Object.getOwnPropertyDescriptor(r3, e4).enumerable;
            }))), o2.forEach(function(t13) {
              n(e3, t13, r3[t13]);
            });
          }
          return e3;
        }({}, s, a, c, u, l, f, p, h, d, m, g, v));
      }, 6436: (e2, t11, r2) => {
        "use strict";
        r2(5888);
        var n = r2(224);
        e2.exports = { getBashInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getBashInfo"), Promise.all([n.run("bash --version").then(n.findVersion), n.which("bash")]).then(function(e3) {
            return n.determineFound("Bash", e3[0], e3[1]);
          });
        }, "getBashInfo"), getElixirInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getElixirInfo"), Promise.all([n.run("elixir --version").then(function(e3) {
            return n.findVersion(e3, /[Elixir]+\s([\d+.[\d+|.]+)/, 1);
          }), n.which("elixir")]).then(function(e3) {
            return Promise.resolve(n.determineFound("Elixir", e3[0], e3[1]));
          });
        }, "getElixirInfo"), getErlangInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getErlangInfo"), Promise.all([n.run(`erl -eval "{ok, Version} = file:read_file(filename:join([code:root_dir(), 'releases', erlang:system_info(otp_release), 'OTP_VERSION'])), io:fwrite(Version), halt()." -noshell`).then(n.findVersion), n.which("erl")]).then(function(e3) {
            return Promise.resolve(n.determineFound("Erlang", e3[0], e3[1]));
          });
        }, "getErlangInfo"), getGoInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getGoInfo"), Promise.all([n.run("go version").then(n.findVersion), n.which("go")]).then(function(e3) {
            return n.determineFound("Go", e3[0], e3[1]);
          });
        }, "getGoInfo"), getJavaInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getJavaInfo"), Promise.all([n.run("javac -version", { unify: true }).then(function(e3) {
            return n.findVersion(e3, /\d+\.[\w+|.|_|-]+/);
          }), n.run("which javac")]).then(function(e3) {
            return n.determineFound("Java", e3[0], e3[1]);
          });
        }, "getJavaInfo"), getPerlInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getPerlInfo"), Promise.all([n.run("perl -v").then(n.findVersion), n.which("perl")]).then(function(e3) {
            return n.determineFound("Perl", e3[0], e3[1]);
          });
        }, "getPerlInfo"), getPHPInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getPHPInfo"), Promise.all([n.run("php -v").then(n.findVersion), n.which("php")]).then(function(e3) {
            return n.determineFound("PHP", e3[0], e3[1]);
          });
        }, "getPHPInfo"), getProtocInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getProtocInfo"), Promise.all([n.run("protoc --version").then(n.findVersion), n.run("which protoc")]).then(function(e3) {
            return n.determineFound("Protoc", e3[0], e3[1]);
          });
        }, "getProtocInfo"), getPythonInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getPythonInfo"), Promise.all([n.run("python -V 2>&1").then(n.findVersion), n.run("which python")]).then(function(e3) {
            return n.determineFound("Python", e3[0], e3[1]);
          });
        }, "getPythonInfo"), getPython3Info: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getPython3Info"), Promise.all([n.run("python3 -V 2>&1").then(n.findVersion), n.run("which python3")]).then(function(e3) {
            return n.determineFound("Python3", e3[0], e3[1]);
          });
        }, "getPython3Info"), getRInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getRInfo"), Promise.all([n.run("R --version", { unify: true }).then(n.findVersion), n.which("R")]).then(function(e3) {
            return n.determineFound("R", e3[0], e3[1]);
          });
        }, "getRInfo"), getRubyInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getRubyInfo"), Promise.all([n.run("ruby -v").then(n.findVersion), n.which("ruby")]).then(function(e3) {
            return n.determineFound("Ruby", e3[0], e3[1]);
          });
        }, "getRubyInfo"), getRustInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getRustInfo"), Promise.all([n.run("rustc --version").then(n.findVersion), n.run("which rustc")]).then(function(e3) {
            return n.determineFound("Rust", e3[0], e3[1]);
          });
        }, "getRustInfo"), getScalaInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getScalaInfo"), n.isMacOS || n.isLinux ? Promise.all([n.run("scalac -version").then(n.findVersion), n.run("which scalac")]).then(function(e3) {
            return n.determineFound("Scala", e3[0], e3[1]);
          }) : Promise.resolve(["Scala", "N/A"]);
        }, "getScalaInfo") };
      }, 760: (e2, t11, r2) => {
        "use strict";
        r2(5888);
        var n = r2(224);
        e2.exports = { getAptInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getAptInfo"), n.isLinux ? Promise.all([n.run("apt --version").then(n.findVersion), n.which("apt")]).then(function(e3) {
            return n.determineFound("Apt", e3[0], e3[1]);
          }) : Promise.all(["Apt", "N/A"]);
        }, "getAptInfo"), getCargoInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getCargoInfo"), Promise.all([n.run("cargo --version").then(n.findVersion), n.which("cargo").then(n.condensePath)]).then(function(e3) {
            return n.determineFound("Cargo", e3[0], e3[1]);
          });
        }, "getCargoInfo"), getCocoaPodsInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getCocoaPodsInfo"), n.isMacOS ? Promise.all([n.run("pod --version").then(n.findVersion), n.which("pod")]).then(function(e3) {
            return n.determineFound("CocoaPods", e3[0], e3[1]);
          }) : Promise.all(["CocoaPods", "N/A"]);
        }, "getCocoaPodsInfo"), getComposerInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getComposerInfo"), Promise.all([n.run("composer --version").then(n.findVersion), n.which("composer").then(n.condensePath)]).then(function(e3) {
            return n.determineFound("Composer", e3[0], e3[1]);
          });
        }, "getComposerInfo"), getGradleInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getGradleInfo"), Promise.all([n.run("gradle --version").then(n.findVersion), n.which("gradle").then(n.condensePath)]).then(function(e3) {
            return n.determineFound("Gradle", e3[0], e3[1]);
          });
        }, "getGradleInfo"), getHomebrewInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getHomebrewInfo"), n.isMacOS || n.isLinux ? Promise.all([n.run("brew --version").then(n.findVersion), n.which("brew")]).then(function(e3) {
            return n.determineFound("Homebrew", e3[0], e3[1]);
          }) : Promise.all(["Homebrew", "N/A"]);
        }, "getHomebrewInfo"), getMavenInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getMavenInfo"), Promise.all([n.run("mvn --version").then(n.findVersion), n.which("mvn").then(n.condensePath)]).then(function(e3) {
            return n.determineFound("Maven", e3[0], e3[1]);
          });
        }, "getMavenInfo"), getpip2Info: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getpip2Info"), Promise.all([n.run("pip2 --version").then(n.findVersion), n.which("pip2").then(n.condensePath)]).then(function(e3) {
            return n.determineFound("pip2", e3[0], e3[1]);
          });
        }, "getpip2Info"), getpip3Info: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getpip3Info"), Promise.all([n.run("pip3 --version").then(n.findVersion), n.which("pip3").then(n.condensePath)]).then(function(e3) {
            return n.determineFound("pip3", e3[0], e3[1]);
          });
        }, "getpip3Info"), getRubyGemsInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getRubyGemsInfo"), Promise.all([n.run("gem --version").then(n.findVersion), n.which("gem")]).then(function(e3) {
            return n.determineFound("RubyGems", e3[0], e3[1]);
          });
        }, "getRubyGemsInfo"), getYumInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getYumInfo"), n.isLinux ? Promise.all([n.run("yum --version").then(n.findVersion), n.which("yum")]).then(function(e3) {
            return n.determineFound("Yum", e3[0], e3[1]);
          }) : Promise.all(["Yum", "N/A"]);
        }, "getYumInfo") };
      }, 2060: (e2, t11, r2) => {
        "use strict";
        r2(5888);
        var n = r2(224), o = r2(7072);
        e2.exports = { getYarnWorkspacesInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getYarnWorkspacesInfo"), Promise.all([n.run("yarn -v"), n.getPackageJsonByPath("package.json").then(function(e3) {
            return e3 && "workspaces" in e3;
          })]).then(function(e3) {
            var t12 = "Yarn Workspaces";
            return e3[0] && e3[1] ? Promise.resolve([t12, e3[0]]) : Promise.resolve([t12, "Not Found"]);
          });
        }, "getYarnWorkspacesInfo"), getLernaInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getLernaInfo"), Promise.all([n.getPackageJsonByName("lerna").then(function(e3) {
            return e3 && e3.version;
          }), n.fileExists(o.join(process.cwd(), "lerna.json"))]).then(function(e3) {
            var t12 = "Lerna";
            return e3[0] && e3[1] ? Promise.resolve([t12, e3[0]]) : Promise.resolve([t12, "Not Found"]);
          });
        }, "getLernaInfo") };
      }, 7508: (e2, t11, r2) => {
        "use strict";
        r2(4880), r2(5888), r2(3708);
        var n = r2(2058), o = r2(7072), i = r2(224);
        e2.exports = { getAndroidSDKInfo: /* @__PURE__ */ __name(function() {
          return i.run("sdkmanager --list").then(function(e3) {
            return !e3 && process.env.ANDROID_HOME ? i.run(`${process.env.ANDROID_HOME}/tools/bin/sdkmanager --list`) : e3;
          }).then(function(e3) {
            return !e3 && process.env.ANDROID_HOME ? i.run(`${process.env.ANDROID_HOME}/cmdline-tools/latest/bin/sdkmanager --list`) : e3;
          }).then(function(e3) {
            return !e3 && i.isMacOS ? i.run("~/Library/Android/sdk/tools/bin/sdkmanager --list") : e3;
          }).then(function(e3) {
            var t12 = i.parseSDKManagerOutput(e3), r3 = /* @__PURE__ */ __name(function(e4) {
              var t13, r4 = o.join(e4, "source.properties");
              try {
                t13 = n.readFileSync(r4, "utf8");
              } catch (e5) {
                if ("ENOENT" === e5.code) return;
                throw e5;
              }
              for (var i2 = t13.split("\n"), s2 = 0; s2 < i2.length; s2 += 1) {
                var a = i2[s2].split("=");
                if (2 === a.length && "Pkg.Revision" === a[0].trim()) return a[1].trim();
              }
            }, "r"), s = process.env.ANDROID_NDK ? r3(process.env.ANDROID_NDK) : process.env.ANDROID_NDK_HOME ? r3(process.env.ANDROID_NDK_HOME) : process.env.ANDROID_HOME ? r3(o.join(process.env.ANDROID_HOME, "ndk-bundle")) : void 0;
            return t12.buildTools.length || t12.apiLevels.length || t12.systemImages.length || s ? Promise.resolve(["Android SDK", { "API Levels": t12.apiLevels || i.NotFound, "Build Tools": t12.buildTools || i.NotFound, "System Images": t12.systemImages || i.NotFound, "Android NDK": s || i.NotFound }]) : Promise.resolve(["Android SDK", i.NotFound]);
          });
        }, "getAndroidSDKInfo"), getiOSSDKInfo: /* @__PURE__ */ __name(function() {
          return i.isMacOS ? i.run("xcodebuild -showsdks").then(function(e3) {
            return e3.match(/[\w]+\s[\d|.]+/g);
          }).then(i.uniq).then(function(e3) {
            return e3.length ? ["iOS SDK", { Platforms: e3 }] : ["iOS SDK", i.NotFound];
          }) : Promise.resolve(["iOS SDK", "N/A"]);
        }, "getiOSSDKInfo"), getWindowsSDKInfo: /* @__PURE__ */ __name(function() {
          if (i.log("trace", "getWindowsSDKInfo"), i.isWindows) {
            var e3 = i.NotFound;
            return i.run("reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModelUnlock").then(function(t12) {
              e3 = t12.split(/[\r\n]/g).slice(1).filter(function(e4) {
                return "" !== e4;
              }).reduce(function(e4, t13) {
                var r4 = t13.match(/[^\s]+/g);
                return "0x0" !== r4[2] && "0x1" !== r4[2] || (r4[2] = "0x1" === r4[2] ? "Enabled" : "Disabled"), e4[r4[0]] = r4[2], e4;
              }, {}), 0 === Object.keys(e3).length && (e3 = i.NotFound);
              try {
                var r3 = n.readdirSync(`${process.env["ProgramFiles(x86)"]}/Windows Kits/10/Platforms/UAP`);
                e3.Versions = r3;
              } catch (e4) {
              }
              return Promise.resolve(["Windows SDK", e3]);
            });
          }
          return Promise.resolve(["Windows SDK", i.NA]);
        }, "getWindowsSDKInfo") };
      }, 9284: (e2, t11, r2) => {
        "use strict";
        r2(5888);
        var n = r2(224);
        e2.exports = { getApacheInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getApacheInfo"), n.isMacOS || n.isLinux ? Promise.all([n.run("apachectl -v").then(n.findVersion), n.run("which apachectl")]).then(function(e3) {
            return n.determineFound("Apache", e3[0], e3[1]);
          }) : Promise.resolve(["Apache", "N/A"]);
        }, "getApacheInfo"), getNginxInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getNginxInfo"), n.isMacOS || n.isLinux ? Promise.all([n.run("nginx -v 2>&1").then(n.findVersion), n.run("which nginx")]).then(function(e3) {
            return n.determineFound("Nginx", e3[0], e3[1]);
          }) : Promise.resolve(["Nginx", "N/A"]);
        }, "getNginxInfo") };
      }, 8144: (e2, t11, r2) => {
        "use strict";
        r2(3708), r2(4880), r2(5888);
        var n = r2(2288), o = r2(224), i = r2(8558);
        e2.exports = { getContainerInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getContainerInfo"), o.isLinux ? Promise.all([o.fileExists("/.dockerenv"), o.readFile("/proc/self/cgroup")]).then(function(e3) {
            return o.log("trace", "getContainerInfoThen", e3), Promise.resolve(["Container", e3[0] || e3[1] ? "Yes" : "N/A"]);
          }).catch(function(e3) {
            return o.log("trace", "getContainerInfoCatch", e3);
          }) : Promise.resolve(["Container", "N/A"]);
        }, "getContainerInfo"), getCPUInfo: /* @__PURE__ */ __name(function() {
          var e3;
          o.log("trace", "getCPUInfo");
          try {
            var t12 = i.cpus();
            e3 = "(" + t12.length + ") " + i.arch() + " " + t12[0].model;
          } catch (t13) {
            e3 = "Unknown";
          }
          return Promise.all(["CPU", e3]);
        }, "getCPUInfo"), getMemoryInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getMemoryInfo"), Promise.all(["Memory", `${o.toReadableBytes(i.freemem())} / ${o.toReadableBytes(i.totalmem())}`]);
        }, "getMemoryInfo"), getOSInfo: /* @__PURE__ */ __name(function() {
          var e3, t12;
          if (o.log("trace", "getOSInfo"), o.isMacOS) e3 = o.run("sw_vers -productVersion ");
          else if (o.isLinux) e3 = o.run("cat /etc/os-release").then(function(e4) {
            var t13 = (e4 || "").match(/NAME="(.+)"/) || "", r4 = (e4 || "").match(/VERSION="(.+)"/) || ["", ""], n2 = null !== r4 ? r4[1] : "";
            return `${t13[1]} ${n2}`.trim() || "";
          });
          else if (o.isWindows) {
            e3 = Promise.resolve(i.release());
            var r3 = i.release().split(".");
            "10" === r3[0] && "0" === r3[1] && r3[2] >= 22e3 && (t12 = "Windows 11");
          } else e3 = Promise.resolve();
          return e3.then(function(e4) {
            return t12 = t12 || n(i.platform(), i.release()), e4 && (t12 += ` ${e4}`), ["OS", t12];
          });
        }, "getOSInfo"), getShellInfo: /* @__PURE__ */ __name(function() {
          if (o.log("trace", "getShellInfo", process.env), o.isMacOS || o.isLinux) {
            var e3 = process.env.SHELL || o.runSync("getent passwd $LOGNAME | cut -d: -f7 | head -1"), t12 = `${e3} --version 2>&1`;
            return e3.match("/bin/ash") && (t12 = `${e3} --help 2>&1`), Promise.all([o.run(t12).then(o.findVersion), o.which(e3)]).then(function(e4) {
              return o.determineFound("Shell", e4[0] || "Unknown", e4[1]);
            });
          }
          return Promise.resolve(["Shell", "N/A"]);
        }, "getShellInfo"), getGLibcInfo: /* @__PURE__ */ __name(function() {
          return o.log("trace", "getGLibc"), o.isLinux ? Promise.all([o.run("ldd --version").then(o.findVersion)]).then(function(e3) {
            return o.determineFound("GLibc", e3[0] || "Unknown");
          }) : Promise.resolve(["GLibc", "N/A"]);
        }, "getGLibcInfo") };
      }, 5882: (e2, t11, r2) => {
        "use strict";
        r2(5888);
        var n = r2(224);
        e2.exports = { getBazelInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getBazelInfo"), Promise.all([n.run("bazel --version").then(n.findVersion), n.run("which bazel")]).then(function(e3) {
            return n.determineFound("Bazel", e3[0], e3[1]);
          });
        }, "getBazelInfo"), getCMakeInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getCMakeInfo"), Promise.all([n.run("cmake --version").then(n.findVersion), n.run("which cmake")]).then(function(e3) {
            return n.determineFound("CMake", e3[0], e3[1]);
          });
        }, "getCMakeInfo"), getGCCInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getGCCInfo"), n.isMacOS || n.isLinux ? Promise.all([n.run("gcc -v 2>&1").then(n.findVersion), n.run("which gcc")]).then(function(e3) {
            return n.determineFound("GCC", e3[0], e3[1]);
          }) : Promise.resolve(["GCC", "N/A"]);
        }, "getGCCInfo"), getClangInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getClangInfo"), Promise.all([n.run("clang --version").then(n.findVersion), n.which("clang")]).then(function(e3) {
            return n.determineFound("Clang", e3[0], e3[1]);
          });
        }, "getClangInfo"), getGitInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getGitInfo"), Promise.all([n.run("git --version").then(n.findVersion), n.run("which git")]).then(function(e3) {
            return n.determineFound("Git", e3[0], e3[1]);
          });
        }, "getGitInfo"), getMakeInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getMakeInfo"), n.isMacOS || n.isLinux ? Promise.all([n.run("make --version").then(n.findVersion), n.run("which make")]).then(function(e3) {
            return n.determineFound("Make", e3[0], e3[1]);
          }) : Promise.resolve(["Make", "N/A"]);
        }, "getMakeInfo"), getNinjaInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getNinjaInfo"), Promise.all([n.run("ninja --version").then(n.findVersion), n.run("which ninja")]).then(function(e3) {
            return n.determineFound("Ninja", e3[0], e3[1]);
          });
        }, "getNinjaInfo"), getMercurialInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getMercurialInfo"), n.isMacOS || n.isLinux ? Promise.all([n.run("hg --version").then(n.findVersion), n.run("which hg")]).then(function(e3) {
            return n.determineFound("Mercurial", e3[0], e3[1]);
          }) : Promise.resolve(["Mercurial", "N/A"]);
        }, "getMercurialInfo"), getSubversionInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getSubversionInfo"), n.isMacOS || n.isLinux ? Promise.all([n.run("svn --version").then(n.findVersion), n.run("which svn")]).then(function(e3) {
            return n.determineFound("Subversion", e3[0], e3[1]);
          }) : Promise.resolve(["Subversion", "N/A"]);
        }, "getSubversionInfo"), getFFmpegInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getFFmpegInfo"), Promise.all([n.run("ffmpeg -version").then(n.findVersion), n.which("ffmpeg")]).then(function(e3) {
            return n.determineFound("FFmpeg", e3[0], e3[1]);
          });
        }, "getFFmpegInfo"), getCurlInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getCurlInfo"), Promise.all([n.run("curl --version").then(n.findVersion), n.which("curl")]).then(function(e3) {
            return n.determineFound("Curl", e3[0], e3[1]);
          });
        }, "getCurlInfo"), getOpenSSLInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getOpenSSLInfo"), Promise.all([n.run("openssl version").then(n.findVersion), n.which("openssl")]).then(function(e3) {
            return n.determineFound("OpenSSL", e3[0], e3[1]);
          });
        }, "getOpenSSLInfo") };
      }, 9676: (e2, t11, r2) => {
        "use strict";
        r2(5888);
        var n = r2(224);
        e2.exports = { getDockerInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getDockerInfo"), Promise.all([n.run("docker --version").then(n.findVersion), n.which("docker")]).then(function(e3) {
            return n.determineFound("Docker", e3[0], e3[1]);
          });
        }, "getDockerInfo"), getDockerComposeInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getDockerComposeInfo"), Promise.all([n.run("docker-compose --version").then(n.findVersion), n.which("docker-compose")]).then(function(e3) {
            return n.determineFound("Docker Compose", e3[0], e3[1]);
          });
        }, "getDockerComposeInfo"), getParallelsInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getParallelsInfo"), Promise.all([n.run("prlctl --version").then(n.findVersion), n.which("prlctl")]).then(function(e3) {
            return n.determineFound("Parallels", e3[0], e3[1]);
          });
        }, "getParallelsInfo"), getPodmanInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getPodmanInfo"), Promise.all([n.run("podman --version").then(n.findVersion), n.which("podman")]).then(function(e3) {
            return n.determineFound("Podman", e3[0], e3[1]);
          });
        }, "getPodmanInfo"), getVirtualBoxInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getVirtualBoxInfo"), Promise.all([n.run("vboxmanage --version").then(n.findVersion), n.which("vboxmanage")]).then(function(e3) {
            return n.determineFound("VirtualBox", e3[0], e3[1]);
          });
        }, "getVirtualBoxInfo"), getVMwareFusionInfo: /* @__PURE__ */ __name(function() {
          return n.log("trace", "getVMwareFusionInfo"), n.getDarwinApplicationVersion("com.vmware.fusion").then(function(e3) {
            return n.determineFound("VMWare Fusion", e3, "N/A");
          });
        }, "getVMwareFusionInfo") };
      }, 6032: (e2) => {
        "use strict";
        e2.exports = { androidSystemImages: /system-images;([\S \t]+)/g, androidAPILevels: /platforms;android-(\d+)[\S\s]/g, androidBuildTools: /build-tools;([\d|.]+)[\S\s]/g };
      }, 6304: (e2, t11, r2) => {
        "use strict";
        r2(4880), r2(5584), r2(5888), r2(7360), r2(3708);
        var n = r2(808), o = r2(7072), i = r2(224), s = /* @__PURE__ */ __name(function(e3) {
          var t12 = e3.split("node_modules" + o.sep), r3 = t12[t12.length - 1];
          return "@" === r3.charAt(0) ? [r3.split(o.sep)[0], r3.split(o.sep)[1]].join("/") : r3.split(o.sep)[0];
        }, "s");
        e2.exports = { getnpmPackages: /* @__PURE__ */ __name(function(e3, t12) {
          i.log("trace", "getnpmPackages"), t12 || (t12 = {});
          var r3 = null, n2 = null;
          return "string" == typeof e3 && (e3.includes("*") || e3.includes("?") || e3.includes("+") || e3.includes("!") ? r3 = e3 : e3 = e3.split(",")), Promise.all(["npmPackages", i.getPackageJsonByPath("package.json").then(function(e4) {
            return Object.assign({}, (e4 || {}).devDependencies || {}, (e4 || {}).dependencies || {});
          }).then(function(e4) {
            return n2 = e4, t12.fullTree || t12.duplicates || r3 ? i.getAllPackageJsonPaths(r3) : Promise.resolve(Object.keys(e4 || []).map(function(e5) {
              return o.join("node_modules", e5, "package.json");
            }));
          }).then(function(o2) {
            return !r3 && "boolean" != typeof e3 || t12.fullTree ? Array.isArray(e3) ? Promise.resolve((o2 || []).filter(function(t13) {
              return e3.includes(s(t13));
            })) : Promise.resolve(o2) : Promise.resolve((o2 || []).filter(function(e4) {
              return Object.keys(n2 || []).includes(s(e4));
            }));
          }).then(function(e4) {
            return Promise.all([e4, Promise.all(e4.map(function(e5) {
              return i.getPackageJsonByPath(e5);
            }))]);
          }).then(function(e4) {
            var r4 = e4[0], o2 = e4[1].reduce(function(e5, n3, o3) {
              return n3 && n3.name ? (e5[n3.name] || (e5[n3.name] = {}), t12.duplicates && (e5[n3.name].duplicates = i.uniq((e5[n3.name].duplicates || []).concat(n3.version))), 1 === (r4[o3].match(/node_modules/g) || []).length && (e5[n3.name].installed = n3.version), e5) : e5;
            }, {});
            return Object.keys(o2).forEach(function(e5) {
              o2[e5].duplicates && o2[e5].installed && (o2[e5].duplicates = o2[e5].duplicates.filter(function(t13) {
                return t13 !== o2[e5].installed;
              })), n2[e5] && (o2[e5].wanted = n2[e5]);
            }), o2;
          }).then(function(r4) {
            return t12.showNotFound && Array.isArray(e3) && e3.forEach(function(e4) {
              r4[e4] || (r4[e4] = "Not Found");
            }), r4;
          }).then(function(e4) {
            return i.sortObject(e4);
          })]);
        }, "getnpmPackages"), getnpmGlobalPackages: /* @__PURE__ */ __name(function(e3, t12) {
          i.log("trace", "getnpmGlobalPackages", e3);
          var r3 = null;
          return "string" == typeof e3 ? e3.includes("*") || e3.includes("?") || e3.includes("+") || e3.includes("!") ? r3 = e3 : e3 = e3.split(",") : Array.isArray(e3) || (e3 = true), Promise.all(["npmGlobalPackages", i.run("npm get prefix --global").then(function(e4) {
            return new Promise(function(t13, s2) {
              return n(o.join(e4, i.isWindows ? "" : "lib", "node_modules", r3 || "{*,@*/*}", "package.json"), function(e5, r4) {
                e5 || t13(r4), s2(e5);
              });
            });
          }).then(function(t13) {
            return Promise.all(t13.filter(function(t14) {
              return "boolean" == typeof e3 || null !== r3 || e3.includes(s(t14));
            }).map(function(e4) {
              return i.getPackageJsonByFullPath(e4);
            }));
          }).then(function(e4) {
            return e4.reduce(function(e5, t13) {
              return t13 ? Object.assign(e5, { [t13.name]: t13.version }) : e5;
            }, {});
          }).then(function(r4) {
            return t12.showNotFound && Array.isArray(e3) && e3.forEach(function(e4) {
              r4[e4] || (r4[e4] = "Not Found");
            }), r4;
          })]);
        }, "getnpmGlobalPackages") };
      }, 5088: (e2) => {
        "use strict";
        e2.exports = { defaults: { System: ["OS", "CPU", "Memory", "Container", "Shell"], Binaries: ["Node", "Yarn", "npm", "pnpm", "bun", "Watchman"], Managers: ["Apt", "Cargo", "CocoaPods", "Composer", "Gradle", "Homebrew", "Maven", "pip2", "pip3", "RubyGems", "Yum"], Utilities: ["Bazel", "CMake", "Make", "GCC", "Git", "Clang", "Ninja", "Mercurial", "Subversion", "FFmpeg", "Curl", "OpenSSL"], Servers: ["Apache", "Nginx"], Virtualization: ["Docker", "Docker Compose", "Parallels", "VirtualBox", "VMware Fusion"], SDKs: ["iOS SDK", "Android SDK", "Windows SDK"], IDEs: ["Android Studio", "Atom", "Emacs", "IntelliJ", "NVim", "Nano", "PhpStorm", "Sublime Text", "VSCode", "Visual Studio", "Vim", "WebStorm", "Xcode"], Languages: ["Bash", "Go", "Elixir", "Erlang", "Java", "Perl", "PHP", "Protoc", "Python", "Python3", "R", "Ruby", "Rust", "Scala"], Databases: ["MongoDB", "MySQL", "PostgreSQL", "SQLite"], Browsers: ["Brave Browser", "Chrome", "Chrome Canary", "Chromium", "Edge", "Firefox", "Firefox Developer Edition", "Firefox Nightly", "Internet Explorer", "Safari", "Safari Technology Preview"], Monorepos: ["Yarn Workspaces", "Lerna"], npmPackages: null, npmGlobalPackages: null }, cssnano: { System: ["OS", "CPU"], Binaries: ["Node", "Yarn", "npm", "pnpm", "bun"], npmPackages: ["cssnano", "postcss"], options: { duplicates: true } }, jest: { System: ["OS", "CPU"], Binaries: ["Node", "Yarn", "npm", "pnpm", "bun"], npmPackages: ["jest"] }, "react-native": { System: ["OS", "CPU"], Binaries: ["Node", "Yarn", "npm", "pnpm", "bun", "Watchman"], SDKs: ["iOS SDK", "Android SDK", "Windows SDK"], IDEs: ["Android Studio", "Xcode", "Visual Studio"], npmPackages: ["react", "react-native"], npmGlobalPackages: ["react-native-cli"] }, nyc: { System: ["OS", "CPU", "Memory"], Binaries: ["Node", "Yarn", "npm", "pnpm", "bun"], npmPackages: "/**/{*babel*,@babel/*/,*istanbul*,nyc,source-map-support,typescript,ts-node}" }, webpack: { System: ["OS", "CPU"], Binaries: ["Node", "Yarn", "npm", "pnpm", "bun"], npmPackages: "*webpack*", npmGlobalPackages: ["webpack", "webpack-cli"] }, "styled-components": { System: ["OS", "CPU"], Binaries: ["Node", "Yarn", "npm", "pnpm", "bun"], Browsers: ["Chrome", "Firefox", "Safari"], npmPackages: "*styled-components*" }, "create-react-app": { System: ["OS", "CPU"], Binaries: ["Node", "npm", "Yarn", "pnpm", "bun"], Browsers: ["Chrome", "Edge", "Internet Explorer", "Firefox", "Safari"], npmPackages: ["react", "react-dom", "react-scripts"], npmGlobalPackages: ["create-react-app"], options: { duplicates: true, showNotFound: true } }, apollo: { System: ["OS"], Binaries: ["Node", "npm", "Yarn", "pnpm", "bun"], Browsers: ["Chrome", "Edge", "Firefox", "Safari"], npmPackages: "{*apollo*,@apollo/*}", npmGlobalPackages: "{*apollo*,@apollo/*}" }, "react-native-web": { System: ["OS", "CPU"], Binaries: ["Node", "npm", "Yarn", "pnpm", "bun"], Browsers: ["Chrome", "Edge", "Internet Explorer", "Firefox", "Safari"], npmPackages: ["react", "react-native-web"], options: { showNotFound: true } }, babel: { System: ["OS"], Binaries: ["Node", "npm", "Yarn", "pnpm", "bun"], Monorepos: ["Yarn Workspaces", "Lerna"], npmPackages: "{*babel*,@babel/*,eslint,webpack,create-react-app,react-native,lerna,jest,next,rollup}" }, playwright: { System: ["OS", "CPU", "Memory", "Container"], Binaries: ["Node", "Yarn", "npm", "pnpm", "bun"], Languages: ["Bash"], IDEs: ["VSCode"], npmPackages: "{playwright*,@playwright/*}" } };
      }, 224: (e2, t11, r2) => {
        "use strict";
        r2(4880), r2(4260), r2(5584), r2(7276), r2(4228), r2(3708), r2(8412), r2(5308), r2(6568), r2(5888);
        var n = r2(7072), o = r2(2058), i = r2(8558), s = r2(4368), a = r2(8460), c = r2(808), u = r2(6032), l = /* @__PURE__ */ __name(function(e3) {
          var t12 = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).unify, r3 = void 0 !== t12 && t12;
          return new Promise(function(t13) {
            s.exec(e3, { stdio: [0, "pipe", "ignore"] }, function(e4, n2, o2) {
              var i2;
              i2 = r3 ? n2.toString() + o2.toString() : n2.toString(), t13((e4 ? "" : i2).trim());
            });
          });
        }, "l"), f = /* @__PURE__ */ __name(function(e3) {
          var t12 = Object.values(Array.prototype.slice.call(arguments).slice(1));
          (process.env.ENVINFO_DEBUG || "").toLowerCase() === e3 && console.log(e3, JSON.stringify(t12));
        }, "f"), p = /* @__PURE__ */ __name(function(e3) {
          return new Promise(function(t12) {
            o.readFile(e3, "utf8", function(e4, r3) {
              return t12(r3 || null);
            });
          });
        }, "p"), h = /* @__PURE__ */ __name(function(e3) {
          return p(e3).then(function(e4) {
            return e4 ? JSON.parse(e4) : null;
          });
        }, "h"), d = /\d+\.[\d+|.]+/g, m = /* @__PURE__ */ __name(function(e3) {
          f("trace", "findDarwinApplication", e3);
          var t12 = `mdfind "kMDItemCFBundleIdentifier=='${e3}'"`;
          return f("trace", t12), l(t12).then(function(e4) {
            return e4.replace(/(\s)/g, "\\ ");
          });
        }, "m"), g = /* @__PURE__ */ __name(function(e3, t12) {
          var r3 = (t12 || ["CFBundleShortVersionString"]).map(function(e4) {
            return "-c Print:" + e4;
          });
          return ["/usr/libexec/PlistBuddy"].concat(r3).concat([e3]).join(" ");
        }, "g"), v = /* @__PURE__ */ __name(function(e3, t12) {
          for (var r3 = [], n2 = null; null !== (n2 = e3.exec(t12)); ) r3.push(n2);
          return r3;
        }, "v");
        e2.exports = { run: l, log: f, fileExists: /* @__PURE__ */ __name(function(e3) {
          return new Promise(function(t12) {
            o.stat(e3, function(r3) {
              return t12(r3 ? null : e3);
            });
          });
        }, "fileExists"), windowsExeExists: /* @__PURE__ */ __name(function(e3) {
          return new Promise(function(t12) {
            var r3;
            o.access(r3 = n.join(process.env.ProgramFiles, `${e3}`), o.constants.R_OK, function(i2) {
              i2 ? o.access(r3 = n.join(process.env["ProgramFiles(x86)"], `${e3}`), o.constants.X_OK, function(e4) {
                t12(e4 ? null : r3);
              }) : t12(r3);
            });
          });
        }, "windowsExeExists"), readFile: p, requireJson: h, versionRegex: d, findDarwinApplication: m, generatePlistBuddyCommand: g, matchAll: v, parseSDKManagerOutput: /* @__PURE__ */ __name(function(e3) {
          var t12 = e3.split("Available")[0];
          return { apiLevels: v(u.androidAPILevels, t12).map(function(e4) {
            return e4[1];
          }), buildTools: v(u.androidBuildTools, t12).map(function(e4) {
            return e4[1];
          }), systemImages: v(u.androidSystemImages, t12).map(function(e4) {
            return e4[1].split("|").map(function(e5) {
              return e5.trim();
            });
          }).map(function(e4) {
            return e4[0].split(";")[0] + " | " + e4[2].split(" System Image")[0];
          }) };
        }, "parseSDKManagerOutput"), isLinux: "linux" === process.platform, isMacOS: "darwin" === process.platform, NA: "N/A", NotFound: "Not Found", isWindows: process.platform.startsWith("win"), isObject: /* @__PURE__ */ __name(function(e3) {
          return "object" == typeof e3 && !Array.isArray(e3);
        }, "isObject"), noop: /* @__PURE__ */ __name(function(e3) {
          return e3;
        }, "noop"), pipe: /* @__PURE__ */ __name(function(e3) {
          return function(t12) {
            return e3.reduce(function(e4, t13) {
              return t13(e4);
            }, t12);
          };
        }, "pipe"), browserBundleIdentifiers: { "Brave Browser": "com.brave.Browser", Chrome: "com.google.Chrome", "Chrome Canary": "com.google.Chrome.canary", Firefox: "org.mozilla.firefox", "Firefox Developer Edition": "org.mozilla.firefoxdeveloperedition", "Firefox Nightly": "org.mozilla.nightly", "Microsoft Edge": "com.microsoft.edgemac", Safari: "com.apple.Safari", "Safari Technology Preview": "com.apple.SafariTechnologyPreview" }, ideBundleIdentifiers: { Atom: "com.github.atom", IntelliJ: "com.jetbrains.intellij", PhpStorm: "com.jetbrains.PhpStorm", "Sublime Text": "com.sublimetext.3", WebStorm: "com.jetbrains.WebStorm" }, runSync: /* @__PURE__ */ __name(function(e3) {
          return (s.execSync(e3, { stdio: [0, "pipe", "ignore"] }).toString() || "").trim();
        }, "runSync"), which: /* @__PURE__ */ __name(function(e3) {
          return new Promise(function(t12) {
            return a(e3, function(e4, r3) {
              return t12(r3);
            });
          });
        }, "which"), getDarwinApplicationVersion: /* @__PURE__ */ __name(function(e3) {
          var t12;
          return f("trace", "getDarwinApplicationVersion", e3), t12 = "darwin" !== process.platform ? "N/A" : m(e3).then(function(e4) {
            return l(g(n.join(e4, "Contents", "Info.plist"), ["CFBundleShortVersionString"]));
          }), Promise.resolve(t12);
        }, "getDarwinApplicationVersion"), uniq: /* @__PURE__ */ __name(function(e3) {
          return Array.from(new Set(e3));
        }, "uniq"), toReadableBytes: /* @__PURE__ */ __name(function(e3) {
          var t12 = Math.floor(Math.log(e3) / Math.log(1024));
          return e3 ? (e3 / Math.pow(1024, t12)).toFixed(2) + " " + ["B", "KB", "MB", "GB", "TB", "PB"][t12] : "0 Bytes";
        }, "toReadableBytes"), omit: /* @__PURE__ */ __name(function(e3, t12) {
          return Object.keys(e3).filter(function(e4) {
            return t12.indexOf(e4) < 0;
          }).reduce(function(t13, r3) {
            return Object.assign(t13, { [r3]: e3[r3] });
          }, {});
        }, "omit"), pick: /* @__PURE__ */ __name(function(e3, t12) {
          return Object.keys(e3).filter(function(e4) {
            return t12.indexOf(e4) >= 0;
          }).reduce(function(t13, r3) {
            return Object.assign(t13, { [r3]: e3[r3] });
          }, {});
        }, "pick"), getPackageJsonByName: /* @__PURE__ */ __name(function(e3) {
          return h(n.join(process.cwd(), "node_modules", e3, "package.json"));
        }, "getPackageJsonByName"), getPackageJsonByPath: /* @__PURE__ */ __name(function(e3) {
          return h(n.join(process.cwd(), e3));
        }, "getPackageJsonByPath"), getPackageJsonByFullPath: /* @__PURE__ */ __name(function(e3) {
          return f("trace", "getPackageJsonByFullPath", e3), h(e3);
        }, "getPackageJsonByFullPath"), getAllPackageJsonPaths: /* @__PURE__ */ __name(function(e3) {
          return f("trace", "getAllPackageJsonPaths", e3), new Promise(function(t12) {
            return c(e3 ? n.join("node_modules", e3, "package.json") : n.join("node_modules", "**", "package.json"), function(e4, r3) {
              return t12(r3.map(n.normalize) || []);
            });
          });
        }, "getAllPackageJsonPaths"), sortObject: /* @__PURE__ */ __name(function(e3) {
          return Object.keys(e3).sort().reduce(function(t12, r3) {
            return t12[r3] = e3[r3], t12;
          }, {});
        }, "sortObject"), findVersion: /* @__PURE__ */ __name(function(e3, t12, r3) {
          f("trace", "findVersion", e3, t12, r3);
          var n2 = r3 || 0, o2 = t12 || d, i2 = e3.match(o2);
          return i2 ? i2[n2] : e3;
        }, "findVersion"), condensePath: /* @__PURE__ */ __name(function(e3) {
          return (e3 || "").replace(i.homedir(), "~");
        }, "condensePath"), determineFound: /* @__PURE__ */ __name(function(e3, t12, r3) {
          return f("trace", "determineFound", e3, t12, r3), "N/A" === t12 ? Promise.resolve([e3, "N/A"]) : t12 && 0 !== Object.keys(t12).length ? r3 ? Promise.resolve([e3, t12, r3]) : Promise.resolve([e3, t12]) : Promise.resolve([e3, "Not Found"]);
        }, "determineFound") };
      }, 9016: (e2) => {
        "use strict";
        function t11(e3, t12, o) {
          e3 instanceof RegExp && (e3 = r2(e3, o)), t12 instanceof RegExp && (t12 = r2(t12, o));
          var i = n(e3, t12, o);
          return i && { start: i[0], end: i[1], pre: o.slice(0, i[0]), body: o.slice(i[0] + e3.length, i[1]), post: o.slice(i[1] + t12.length) };
        }
        __name(t11, "t");
        function r2(e3, t12) {
          var r3 = t12.match(e3);
          return r3 ? r3[0] : null;
        }
        __name(r2, "r");
        function n(e3, t12, r3) {
          var n2, o, i, s, a, c = r3.indexOf(e3), u = r3.indexOf(t12, c + 1), l = c;
          if (c >= 0 && u > 0) {
            for (n2 = [], i = r3.length; l >= 0 && !a; ) l == c ? (n2.push(l), c = r3.indexOf(e3, l + 1)) : 1 == n2.length ? a = [n2.pop(), u] : ((o = n2.pop()) < i && (i = o, s = u), u = r3.indexOf(t12, l + 1)), l = c < u && c >= 0 ? c : u;
            n2.length && (a = [i, s]);
          }
          return a;
        }
        __name(n, "n");
        e2.exports = t11, t11.range = n;
      }, 1620: (e2, t11, r2) => {
        var n = r2(6596), o = r2(9016);
        e2.exports = function(e3) {
          return e3 ? ("{}" === e3.substr(0, 2) && (e3 = "\\{\\}" + e3.substr(2)), v(function(e4) {
            return e4.split("\\\\").join(i).split("\\{").join(s).split("\\}").join(a).split("\\,").join(c).split("\\.").join(u);
          }(e3), true).map(f)) : [];
        };
        var i = "\0SLASH" + Math.random() + "\0", s = "\0OPEN" + Math.random() + "\0", a = "\0CLOSE" + Math.random() + "\0", c = "\0COMMA" + Math.random() + "\0", u = "\0PERIOD" + Math.random() + "\0";
        function l(e3) {
          return parseInt(e3, 10) == e3 ? parseInt(e3, 10) : e3.charCodeAt(0);
        }
        __name(l, "l");
        function f(e3) {
          return e3.split(i).join("\\").split(s).join("{").split(a).join("}").split(c).join(",").split(u).join(".");
        }
        __name(f, "f");
        function p(e3) {
          if (!e3) return [""];
          var t12 = [], r3 = o("{", "}", e3);
          if (!r3) return e3.split(",");
          var n2 = r3.pre, i2 = r3.body, s2 = r3.post, a2 = n2.split(",");
          a2[a2.length - 1] += "{" + i2 + "}";
          var c2 = p(s2);
          return s2.length && (a2[a2.length - 1] += c2.shift(), a2.push.apply(a2, c2)), t12.push.apply(t12, a2), t12;
        }
        __name(p, "p");
        function h(e3) {
          return "{" + e3 + "}";
        }
        __name(h, "h");
        function d(e3) {
          return /^-?0\d/.test(e3);
        }
        __name(d, "d");
        function m(e3, t12) {
          return e3 <= t12;
        }
        __name(m, "m");
        function g(e3, t12) {
          return e3 >= t12;
        }
        __name(g, "g");
        function v(e3, t12) {
          var r3 = [], i2 = o("{", "}", e3);
          if (!i2 || /\$$/.test(i2.pre)) return [e3];
          var s2, c2 = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(i2.body), u2 = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(i2.body), f2 = c2 || u2, y = i2.body.indexOf(",") >= 0;
          if (!f2 && !y) return i2.post.match(/,.*\}/) ? v(e3 = i2.pre + "{" + i2.body + a + i2.post) : [e3];
          if (f2) s2 = i2.body.split(/\.\./);
          else if (1 === (s2 = p(i2.body)).length && 1 === (s2 = v(s2[0], false).map(h)).length) return (x = i2.post.length ? v(i2.post, false) : [""]).map(function(e4) {
            return i2.pre + s2[0] + e4;
          });
          var b, w = i2.pre, x = i2.post.length ? v(i2.post, false) : [""];
          if (f2) {
            var S = l(s2[0]), P = l(s2[1]), O = Math.max(s2[0].length, s2[1].length), I = 3 == s2.length ? Math.abs(l(s2[2])) : 1, E = m;
            P < S && (I *= -1, E = g);
            var j = s2.some(d);
            b = [];
            for (var _ = S; E(_, P); _ += I) {
              var A;
              if (u2) "\\" === (A = String.fromCharCode(_)) && (A = "");
              else if (A = String(_), j) {
                var k = O - A.length;
                if (k > 0) {
                  var N = new Array(k + 1).join("0");
                  A = _ < 0 ? "-" + N + A.slice(1) : N + A;
                }
              }
              b.push(A);
            }
          } else b = n(s2, function(e4) {
            return v(e4, false);
          });
          for (var F = 0; F < b.length; F++) for (var C = 0; C < x.length; C++) {
            var M = w + b[F] + x[C];
            (!t12 || f2 || M) && r3.push(M);
          }
          return r3;
        }
        __name(v, "v");
      }, 6596: (e2) => {
        e2.exports = function(e3, r2) {
          for (var n = [], o = 0; o < e3.length; o++) {
            var i = r2(e3[o], o);
            t11(i) ? n.push.apply(n, i) : n.push(i);
          }
          return n;
        };
        var t11 = Array.isArray || function(e3) {
          return "[object Array]" === Object.prototype.toString.call(e3);
        };
      }, 2016: (e2) => {
        e2.exports = function(e3) {
          if ("function" != typeof e3) throw TypeError(e3 + " is not a function!");
          return e3;
        };
      }, 7384: (e2, t11, r2) => {
        var n = r2(7096)("unscopables"), o = Array.prototype;
        null == o[n] && r2(2336)(o, n, {}), e2.exports = function(e3) {
          o[n][e3] = true;
        };
      }, 2388: (e2) => {
        e2.exports = function(e3, t11, r2, n) {
          if (!(e3 instanceof t11) || void 0 !== n && n in e3) throw TypeError(r2 + ": incorrect invocation!");
          return e3;
        };
      }, 3504: (e2, t11, r2) => {
        var n = r2(3888);
        e2.exports = function(e3) {
          if (!n(e3)) throw TypeError(e3 + " is not an object!");
          return e3;
        };
      }, 7504: (e2, t11, r2) => {
        var n = r2(2780), o = r2(3528), i = r2(8508);
        e2.exports = function(e3) {
          return function(t12, r3, s) {
            var a, c = n(t12), u = o(c.length), l = i(s, u);
            if (e3 && r3 != r3) {
              for (; u > l; ) if ((a = c[l++]) != a) return true;
            } else for (; u > l; l++) if ((e3 || l in c) && c[l] === r3) return e3 || l || 0;
            return !e3 && -1;
          };
        };
      }, 5848: (e2, t11, r2) => {
        var n = r2(6924), o = r2(7096)("toStringTag"), i = "Arguments" == n(/* @__PURE__ */ function() {
          return arguments;
        }());
        e2.exports = function(e3) {
          var t12, r3, s;
          return void 0 === e3 ? "Undefined" : null === e3 ? "Null" : "string" == typeof (r3 = function(e4, t13) {
            try {
              return e4[t13];
            } catch (e5) {
            }
          }(t12 = Object(e3), o)) ? r3 : i ? n(t12) : "Object" == (s = n(t12)) && "function" == typeof t12.callee ? "Arguments" : s;
        };
      }, 6924: (e2) => {
        var t11 = {}.toString;
        e2.exports = function(e3) {
          return t11.call(e3).slice(8, -1);
        };
      }, 148: (e2, t11, r2) => {
        "use strict";
        var n = r2(8520).f, o = r2(3472), i = r2(7704), s = r2(800), a = r2(2388), c = r2(7228), u = r2(6952), l = r2(172), f = r2(3384), p = r2(1668), h = r2(2020).fastKey, d = r2(2772), m = p ? "_s" : "size", g = /* @__PURE__ */ __name(function(e3, t12) {
          var r3, n2 = h(t12);
          if ("F" !== n2) return e3._i[n2];
          for (r3 = e3._f; r3; r3 = r3.n) if (r3.k == t12) return r3;
        }, "g");
        e2.exports = { getConstructor: /* @__PURE__ */ __name(function(e3, t12, r3, u2) {
          var l2 = e3(function(e4, n2) {
            a(e4, l2, t12, "_i"), e4._t = t12, e4._i = o(null), e4._f = void 0, e4._l = void 0, e4[m] = 0, null != n2 && c(n2, r3, e4[u2], e4);
          });
          return i(l2.prototype, { clear: /* @__PURE__ */ __name(function() {
            for (var e4 = d(this, t12), r4 = e4._i, n2 = e4._f; n2; n2 = n2.n) n2.r = true, n2.p && (n2.p = n2.p.n = void 0), delete r4[n2.i];
            e4._f = e4._l = void 0, e4[m] = 0;
          }, "clear"), delete: /* @__PURE__ */ __name(function(e4) {
            var r4 = d(this, t12), n2 = g(r4, e4);
            if (n2) {
              var o2 = n2.n, i2 = n2.p;
              delete r4._i[n2.i], n2.r = true, i2 && (i2.n = o2), o2 && (o2.p = i2), r4._f == n2 && (r4._f = o2), r4._l == n2 && (r4._l = i2), r4[m]--;
            }
            return !!n2;
          }, "delete"), forEach: /* @__PURE__ */ __name(function(e4) {
            d(this, t12);
            for (var r4, n2 = s(e4, arguments.length > 1 ? arguments[1] : void 0, 3); r4 = r4 ? r4.n : this._f; ) for (n2(r4.v, r4.k, this); r4 && r4.r; ) r4 = r4.p;
          }, "forEach"), has: /* @__PURE__ */ __name(function(e4) {
            return !!g(d(this, t12), e4);
          }, "has") }), p && n(l2.prototype, "size", { get: /* @__PURE__ */ __name(function() {
            return d(this, t12)[m];
          }, "get") }), l2;
        }, "getConstructor"), def: /* @__PURE__ */ __name(function(e3, t12, r3) {
          var n2, o2, i2 = g(e3, t12);
          return i2 ? i2.v = r3 : (e3._l = i2 = { i: o2 = h(t12, true), k: t12, v: r3, p: n2 = e3._l, n: void 0, r: false }, e3._f || (e3._f = i2), n2 && (n2.n = i2), e3[m]++, "F" !== o2 && (e3._i[o2] = i2)), e3;
        }, "def"), getEntry: g, setStrong: /* @__PURE__ */ __name(function(e3, t12, r3) {
          u(e3, t12, function(e4, r4) {
            this._t = d(e4, t12), this._k = r4, this._l = void 0;
          }, function() {
            for (var e4 = this, t13 = e4._k, r4 = e4._l; r4 && r4.r; ) r4 = r4.p;
            return e4._t && (e4._l = r4 = r4 ? r4.n : e4._t._f) ? l(0, "keys" == t13 ? r4.k : "values" == t13 ? r4.v : [r4.k, r4.v]) : (e4._t = void 0, l(1));
          }, r3 ? "entries" : "values", !r3, true), f(t12);
        }, "setStrong") };
      }, 9412: (e2, t11, r2) => {
        "use strict";
        var n = r2(2804), o = r2(7076), i = r2(8868), s = r2(7704), a = r2(2020), c = r2(7228), u = r2(2388), l = r2(3888), f = r2(9316), p = r2(8380), h = r2(6256), d = r2(2672);
        e2.exports = function(e3, t12, r3, m, g, v) {
          var y = n[e3], b = y, w = g ? "set" : "add", x = b && b.prototype, S = {}, P = /* @__PURE__ */ __name(function(e4) {
            var t13 = x[e4];
            i(x, e4, "delete" == e4 || "has" == e4 ? function(e5) {
              return !(v && !l(e5)) && t13.call(this, 0 === e5 ? 0 : e5);
            } : "get" == e4 ? function(e5) {
              return v && !l(e5) ? void 0 : t13.call(this, 0 === e5 ? 0 : e5);
            } : "add" == e4 ? function(e5) {
              return t13.call(this, 0 === e5 ? 0 : e5), this;
            } : function(e5, r4) {
              return t13.call(this, 0 === e5 ? 0 : e5, r4), this;
            });
          }, "P");
          if ("function" == typeof b && (v || x.forEach && !f(function() {
            new b().entries().next();
          }))) {
            var O = new b(), I = O[w](v ? {} : -0, 1) != O, E = f(function() {
              O.has(1);
            }), j = p(function(e4) {
              new b(e4);
            }), _ = !v && f(function() {
              for (var e4 = new b(), t13 = 5; t13--; ) e4[w](t13, t13);
              return !e4.has(-0);
            });
            j || ((b = t12(function(t13, r4) {
              u(t13, b, e3);
              var n2 = d(new y(), t13, b);
              return null != r4 && c(r4, g, n2[w], n2), n2;
            })).prototype = x, x.constructor = b), (E || _) && (P("delete"), P("has"), g && P("get")), (_ || I) && P(w), v && x.clear && delete x.clear;
          } else b = m.getConstructor(t12, e3, g, w), s(b.prototype, r3), a.NEED = true;
          return h(b, e3), S[e3] = b, o(o.G + o.W + o.F * (b != y), S), v || m.setStrong(b, e3, g), b;
        };
      }, 8432: (e2) => {
        var t11 = e2.exports = { version: "2.5.7" };
        "number" == typeof __e && (__e = t11);
      }, 2340: (e2, t11, r2) => {
        "use strict";
        var n = r2(8520), o = r2(8164);
        e2.exports = function(e3, t12, r3) {
          t12 in e3 ? n.f(e3, t12, o(0, r3)) : e3[t12] = r3;
        };
      }, 800: (e2, t11, r2) => {
        var n = r2(2016);
        e2.exports = function(e3, t12, r3) {
          if (n(e3), void 0 === t12) return e3;
          switch (r3) {
            case 1:
              return function(r4) {
                return e3.call(t12, r4);
              };
            case 2:
              return function(r4, n2) {
                return e3.call(t12, r4, n2);
              };
            case 3:
              return function(r4, n2, o) {
                return e3.call(t12, r4, n2, o);
              };
          }
          return function() {
            return e3.apply(t12, arguments);
          };
        };
      }, 24: (e2) => {
        e2.exports = function(e3) {
          if (null == e3) throw TypeError("Can't call method on  " + e3);
          return e3;
        };
      }, 1668: (e2, t11, r2) => {
        e2.exports = !r2(9316)(function() {
          return 7 != Object.defineProperty({}, "a", { get: /* @__PURE__ */ __name(function() {
            return 7;
          }, "get") }).a;
        });
      }, 1300: (e2, t11, r2) => {
        var n = r2(3888), o = r2(2804).document, i = n(o) && n(o.createElement);
        e2.exports = function(e3) {
          return i ? o.createElement(e3) : {};
        };
      }, 444: (e2) => {
        e2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
      }, 7076: (e2, t11, r2) => {
        var n = r2(2804), o = r2(8432), i = r2(2336), s = r2(8868), a = r2(800), c = "prototype", u = /* @__PURE__ */ __name(function(e3, t12, r3) {
          var l, f, p, h, d = e3 & u.F, m = e3 & u.G, g = e3 & u.S, v = e3 & u.P, y = e3 & u.B, b = m ? n : g ? n[t12] || (n[t12] = {}) : (n[t12] || {})[c], w = m ? o : o[t12] || (o[t12] = {}), x = w[c] || (w[c] = {});
          for (l in m && (r3 = t12), r3) p = ((f = !d && b && void 0 !== b[l]) ? b : r3)[l], h = y && f ? a(p, n) : v && "function" == typeof p ? a(Function.call, p) : p, b && s(b, l, p, e3 & u.U), w[l] != p && i(w, l, h), v && x[l] != p && (x[l] = p);
        }, "u");
        n.core = o, u.F = 1, u.G = 2, u.S = 4, u.P = 8, u.B = 16, u.W = 32, u.U = 64, u.R = 128, e2.exports = u;
      }, 9316: (e2) => {
        e2.exports = function(e3) {
          try {
            return !!e3();
          } catch (e4) {
            return true;
          }
        };
      }, 4448: (e2, t11, r2) => {
        "use strict";
        var n = r2(2336), o = r2(8868), i = r2(9316), s = r2(24), a = r2(7096);
        e2.exports = function(e3, t12, r3) {
          var c = a(e3), u = r3(s, c, ""[e3]), l = u[0], f = u[1];
          i(function() {
            var t13 = {};
            return t13[c] = function() {
              return 7;
            }, 7 != ""[e3](t13);
          }) && (o(String.prototype, e3, l), n(RegExp.prototype, c, 2 == t12 ? function(e4, t13) {
            return f.call(e4, this, t13);
          } : function(e4) {
            return f.call(e4, this);
          }));
        };
      }, 8068: (e2, t11, r2) => {
        "use strict";
        var n = r2(3504);
        e2.exports = function() {
          var e3 = n(this), t12 = "";
          return e3.global && (t12 += "g"), e3.ignoreCase && (t12 += "i"), e3.multiline && (t12 += "m"), e3.unicode && (t12 += "u"), e3.sticky && (t12 += "y"), t12;
        };
      }, 7228: (e2, t11, r2) => {
        var n = r2(800), o = r2(2372), i = r2(3164), s = r2(3504), a = r2(3528), c = r2(2800), u = {}, l = {}, f = e2.exports = function(e3, t12, r3, f2, p) {
          var h, d, m, g, v = p ? function() {
            return e3;
          } : c(e3), y = n(r3, f2, t12 ? 2 : 1), b = 0;
          if ("function" != typeof v) throw TypeError(e3 + " is not iterable!");
          if (i(v)) {
            for (h = a(e3.length); h > b; b++) if ((g = t12 ? y(s(d = e3[b])[0], d[1]) : y(e3[b])) === u || g === l) return g;
          } else for (m = v.call(e3); !(d = m.next()).done; ) if ((g = o(m, y, d.value, t12)) === u || g === l) return g;
        };
        f.BREAK = u, f.RETURN = l;
      }, 2804: (e2) => {
        var t11 = e2.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = t11);
      }, 9080: (e2) => {
        var t11 = {}.hasOwnProperty;
        e2.exports = function(e3, r2) {
          return t11.call(e3, r2);
        };
      }, 2336: (e2, t11, r2) => {
        var n = r2(8520), o = r2(8164);
        e2.exports = r2(1668) ? function(e3, t12, r3) {
          return n.f(e3, t12, o(1, r3));
        } : function(e3, t12, r3) {
          return e3[t12] = r3, e3;
        };
      }, 4016: (e2, t11, r2) => {
        var n = r2(2804).document;
        e2.exports = n && n.documentElement;
      }, 5516: (e2, t11, r2) => {
        e2.exports = !r2(1668) && !r2(9316)(function() {
          return 7 != Object.defineProperty(r2(1300)("div"), "a", { get: /* @__PURE__ */ __name(function() {
            return 7;
          }, "get") }).a;
        });
      }, 2672: (e2, t11, r2) => {
        var n = r2(3888), o = r2(5076).set;
        e2.exports = function(e3, t12, r3) {
          var i, s = t12.constructor;
          return s !== r3 && "function" == typeof s && (i = s.prototype) !== r3.prototype && n(i) && o && o(e3, i), e3;
        };
      }, 5628: (e2) => {
        e2.exports = function(e3, t11, r2) {
          var n = void 0 === r2;
          switch (t11.length) {
            case 0:
              return n ? e3() : e3.call(r2);
            case 1:
              return n ? e3(t11[0]) : e3.call(r2, t11[0]);
            case 2:
              return n ? e3(t11[0], t11[1]) : e3.call(r2, t11[0], t11[1]);
            case 3:
              return n ? e3(t11[0], t11[1], t11[2]) : e3.call(r2, t11[0], t11[1], t11[2]);
            case 4:
              return n ? e3(t11[0], t11[1], t11[2], t11[3]) : e3.call(r2, t11[0], t11[1], t11[2], t11[3]);
          }
          return e3.apply(r2, t11);
        };
      }, 2936: (e2, t11, r2) => {
        var n = r2(6924);
        e2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(e3) {
          return "String" == n(e3) ? e3.split("") : Object(e3);
        };
      }, 3164: (e2, t11, r2) => {
        var n = r2(2488), o = r2(7096)("iterator"), i = Array.prototype;
        e2.exports = function(e3) {
          return void 0 !== e3 && (n.Array === e3 || i[o] === e3);
        };
      }, 3888: (e2) => {
        e2.exports = function(e3) {
          return "object" == typeof e3 ? null !== e3 : "function" == typeof e3;
        };
      }, 7760: (e2, t11, r2) => {
        var n = r2(3888), o = r2(6924), i = r2(7096)("match");
        e2.exports = function(e3) {
          var t12;
          return n(e3) && (void 0 !== (t12 = e3[i]) ? !!t12 : "RegExp" == o(e3));
        };
      }, 2372: (e2, t11, r2) => {
        var n = r2(3504);
        e2.exports = function(e3, t12, r3, o) {
          try {
            return o ? t12(n(r3)[0], r3[1]) : t12(r3);
          } catch (t13) {
            var i = e3.return;
            throw void 0 !== i && n(i.call(e3)), t13;
          }
        };
      }, 128: (e2, t11, r2) => {
        "use strict";
        var n = r2(3472), o = r2(8164), i = r2(6256), s = {};
        r2(2336)(s, r2(7096)("iterator"), function() {
          return this;
        }), e2.exports = function(e3, t12, r3) {
          e3.prototype = n(s, { next: o(1, r3) }), i(e3, t12 + " Iterator");
        };
      }, 6952: (e2, t11, r2) => {
        "use strict";
        var n = r2(4440), o = r2(7076), i = r2(8868), s = r2(2336), a = r2(2488), c = r2(128), u = r2(6256), l = r2(9556), f = r2(7096)("iterator"), p = !([].keys && "next" in [].keys()), h = "keys", d = "values", m = /* @__PURE__ */ __name(function() {
          return this;
        }, "m");
        e2.exports = function(e3, t12, r3, g, v, y, b) {
          c(r3, t12, g);
          var w, x, S, P = /* @__PURE__ */ __name(function(e4) {
            if (!p && e4 in j) return j[e4];
            switch (e4) {
              case h:
              case d:
                return function() {
                  return new r3(this, e4);
                };
            }
            return function() {
              return new r3(this, e4);
            };
          }, "P"), O = t12 + " Iterator", I = v == d, E = false, j = e3.prototype, _ = j[f] || j["@@iterator"] || v && j[v], A = _ || P(v), k = v ? I ? P("entries") : A : void 0, N = "Array" == t12 && j.entries || _;
          if (N && (S = l(N.call(new e3()))) !== Object.prototype && S.next && (u(S, O, true), n || "function" == typeof S[f] || s(S, f, m)), I && _ && _.name !== d && (E = true, A = /* @__PURE__ */ __name(function() {
            return _.call(this);
          }, "A")), n && !b || !p && !E && j[f] || s(j, f, A), a[t12] = A, a[O] = m, v) if (w = { values: I ? A : P(d), keys: y ? A : P(h), entries: k }, b) for (x in w) x in j || i(j, x, w[x]);
          else o(o.P + o.F * (p || E), t12, w);
          return w;
        };
      }, 8380: (e2, t11, r2) => {
        var n = r2(7096)("iterator"), o = false;
        try {
          var i = [7][n]();
          i.return = function() {
            o = true;
          }, Array.from(i, function() {
            throw 2;
          });
        } catch (e3) {
        }
        e2.exports = function(e3, t12) {
          if (!t12 && !o) return false;
          var r3 = false;
          try {
            var i2 = [7], s = i2[n]();
            s.next = function() {
              return { done: r3 = true };
            }, i2[n] = function() {
              return s;
            }, e3(i2);
          } catch (e4) {
          }
          return r3;
        };
      }, 172: (e2) => {
        e2.exports = function(e3, t11) {
          return { value: t11, done: !!e3 };
        };
      }, 2488: (e2) => {
        e2.exports = {};
      }, 4440: (e2) => {
        e2.exports = false;
      }, 2020: (e2, t11, r2) => {
        var n = r2(9664)("meta"), o = r2(3888), i = r2(9080), s = r2(8520).f, a = 0, c = Object.isExtensible || function() {
          return true;
        }, u = !r2(9316)(function() {
          return c(Object.preventExtensions({}));
        }), l = /* @__PURE__ */ __name(function(e3) {
          s(e3, n, { value: { i: "O" + ++a, w: {} } });
        }, "l"), f = e2.exports = { KEY: n, NEED: false, fastKey: /* @__PURE__ */ __name(function(e3, t12) {
          if (!o(e3)) return "symbol" == typeof e3 ? e3 : ("string" == typeof e3 ? "S" : "P") + e3;
          if (!i(e3, n)) {
            if (!c(e3)) return "F";
            if (!t12) return "E";
            l(e3);
          }
          return e3[n].i;
        }, "fastKey"), getWeak: /* @__PURE__ */ __name(function(e3, t12) {
          if (!i(e3, n)) {
            if (!c(e3)) return true;
            if (!t12) return false;
            l(e3);
          }
          return e3[n].w;
        }, "getWeak"), onFreeze: /* @__PURE__ */ __name(function(e3) {
          return u && f.NEED && c(e3) && !i(e3, n) && l(e3), e3;
        }, "onFreeze") };
      }, 448: (e2, t11, r2) => {
        var n = r2(2804), o = r2(2280).set, i = n.MutationObserver || n.WebKitMutationObserver, s = n.process, a = n.Promise, c = "process" == r2(6924)(s);
        e2.exports = function() {
          var e3, t12, r3, u = /* @__PURE__ */ __name(function() {
            var n2, o2;
            for (c && (n2 = s.domain) && n2.exit(); e3; ) {
              o2 = e3.fn, e3 = e3.next;
              try {
                o2();
              } catch (n3) {
                throw e3 ? r3() : t12 = void 0, n3;
              }
            }
            t12 = void 0, n2 && n2.enter();
          }, "u");
          if (c) r3 = /* @__PURE__ */ __name(function() {
            s.nextTick(u);
          }, "r");
          else if (!i || n.navigator && n.navigator.standalone) if (a && a.resolve) {
            var l = a.resolve(void 0);
            r3 = /* @__PURE__ */ __name(function() {
              l.then(u);
            }, "r");
          } else r3 = /* @__PURE__ */ __name(function() {
            o.call(n, u);
          }, "r");
          else {
            var f = true, p = document.createTextNode("");
            new i(u).observe(p, { characterData: true }), r3 = /* @__PURE__ */ __name(function() {
              p.data = f = !f;
            }, "r");
          }
          return function(n2) {
            var o2 = { fn: n2, next: void 0 };
            t12 && (t12.next = o2), e3 || (e3 = o2, r3()), t12 = o2;
          };
        };
      }, 8024: (e2, t11, r2) => {
        "use strict";
        var n = r2(2016);
        function o(e3) {
          var t12, r3;
          this.promise = new e3(function(e4, n2) {
            if (void 0 !== t12 || void 0 !== r3) throw TypeError("Bad Promise constructor");
            t12 = e4, r3 = n2;
          }), this.resolve = n(t12), this.reject = n(r3);
        }
        __name(o, "o");
        e2.exports.f = function(e3) {
          return new o(e3);
        };
      }, 6472: (e2, t11, r2) => {
        "use strict";
        var n = r2(5444), o = r2(5364), i = r2(3875), s = r2(1164), a = r2(2936), c = Object.assign;
        e2.exports = !c || r2(9316)(function() {
          var e3 = {}, t12 = {}, r3 = Symbol(), n2 = "abcdefghijklmnopqrst";
          return e3[r3] = 7, n2.split("").forEach(function(e4) {
            t12[e4] = e4;
          }), 7 != c({}, e3)[r3] || Object.keys(c({}, t12)).join("") != n2;
        }) ? function(e3, t12) {
          for (var r3 = s(e3), c2 = arguments.length, u = 1, l = o.f, f = i.f; c2 > u; ) for (var p, h = a(arguments[u++]), d = l ? n(h).concat(l(h)) : n(h), m = d.length, g = 0; m > g; ) f.call(h, p = d[g++]) && (r3[p] = h[p]);
          return r3;
        } : c;
      }, 3472: (e2, t11, r2) => {
        var n = r2(3504), o = r2(1176), i = r2(444), s = r2(4588)("IE_PROTO"), a = /* @__PURE__ */ __name(function() {
        }, "a"), c = "prototype", u = /* @__PURE__ */ __name(function() {
          var e3, t12 = r2(1300)("iframe"), n2 = i.length;
          for (t12.style.display = "none", r2(4016).appendChild(t12), t12.src = "javascript:", (e3 = t12.contentWindow.document).open(), e3.write("<script>document.F=Object</script>"), e3.close(), u = e3.F; n2--; ) delete u[c][i[n2]];
          return u();
        }, "u");
        e2.exports = Object.create || function(e3, t12) {
          var r3;
          return null !== e3 ? (a[c] = n(e3), r3 = new a(), a[c] = null, r3[s] = e3) : r3 = u(), void 0 === t12 ? r3 : o(r3, t12);
        };
      }, 8520: (e2, t11, r2) => {
        var n = r2(3504), o = r2(5516), i = r2(1896), s = Object.defineProperty;
        t11.f = r2(1668) ? Object.defineProperty : function(e3, t12, r3) {
          if (n(e3), t12 = i(t12, true), n(r3), o) try {
            return s(e3, t12, r3);
          } catch (e4) {
          }
          if ("get" in r3 || "set" in r3) throw TypeError("Accessors not supported!");
          return "value" in r3 && (e3[t12] = r3.value), e3;
        };
      }, 1176: (e2, t11, r2) => {
        var n = r2(8520), o = r2(3504), i = r2(5444);
        e2.exports = r2(1668) ? Object.defineProperties : function(e3, t12) {
          o(e3);
          for (var r3, s = i(t12), a = s.length, c = 0; a > c; ) n.f(e3, r3 = s[c++], t12[r3]);
          return e3;
        };
      }, 6524: (e2, t11, r2) => {
        var n = r2(3875), o = r2(8164), i = r2(2780), s = r2(1896), a = r2(9080), c = r2(5516), u = Object.getOwnPropertyDescriptor;
        t11.f = r2(1668) ? u : function(e3, t12) {
          if (e3 = i(e3), t12 = s(t12, true), c) try {
            return u(e3, t12);
          } catch (e4) {
          }
          if (a(e3, t12)) return o(!n.f.call(e3, t12), e3[t12]);
        };
      }, 5364: (e2, t11) => {
        t11.f = Object.getOwnPropertySymbols;
      }, 9556: (e2, t11, r2) => {
        var n = r2(9080), o = r2(1164), i = r2(4588)("IE_PROTO"), s = Object.prototype;
        e2.exports = Object.getPrototypeOf || function(e3) {
          return e3 = o(e3), n(e3, i) ? e3[i] : "function" == typeof e3.constructor && e3 instanceof e3.constructor ? e3.constructor.prototype : e3 instanceof Object ? s : null;
        };
      }, 3816: (e2, t11, r2) => {
        var n = r2(9080), o = r2(2780), i = r2(7504)(false), s = r2(4588)("IE_PROTO");
        e2.exports = function(e3, t12) {
          var r3, a = o(e3), c = 0, u = [];
          for (r3 in a) r3 != s && n(a, r3) && u.push(r3);
          for (; t12.length > c; ) n(a, r3 = t12[c++]) && (~i(u, r3) || u.push(r3));
          return u;
        };
      }, 5444: (e2, t11, r2) => {
        var n = r2(3816), o = r2(444);
        e2.exports = Object.keys || function(e3) {
          return n(e3, o);
        };
      }, 3875: (e2, t11) => {
        t11.f = {}.propertyIsEnumerable;
      }, 2504: (e2, t11, r2) => {
        var n = r2(5444), o = r2(2780), i = r2(3875).f;
        e2.exports = function(e3) {
          return function(t12) {
            for (var r3, s = o(t12), a = n(s), c = a.length, u = 0, l = []; c > u; ) i.call(s, r3 = a[u++]) && l.push(e3 ? [r3, s[r3]] : s[r3]);
            return l;
          };
        };
      }, 7904: (e2) => {
        e2.exports = function(e3) {
          try {
            return { e: false, v: e3() };
          } catch (e4) {
            return { e: true, v: e4 };
          }
        };
      }, 0: (e2, t11, r2) => {
        var n = r2(3504), o = r2(3888), i = r2(8024);
        e2.exports = function(e3, t12) {
          if (n(e3), o(t12) && t12.constructor === e3) return t12;
          var r3 = i.f(e3);
          return (0, r3.resolve)(t12), r3.promise;
        };
      }, 8164: (e2) => {
        e2.exports = function(e3, t11) {
          return { enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t11 };
        };
      }, 7704: (e2, t11, r2) => {
        var n = r2(8868);
        e2.exports = function(e3, t12, r3) {
          for (var o in t12) n(e3, o, t12[o], r3);
          return e3;
        };
      }, 8868: (e2, t11, r2) => {
        var n = r2(2804), o = r2(2336), i = r2(9080), s = r2(9664)("src"), a = "toString", c = Function[a], u = ("" + c).split(a);
        r2(8432).inspectSource = function(e3) {
          return c.call(e3);
        }, (e2.exports = function(e3, t12, r3, a2) {
          var c2 = "function" == typeof r3;
          c2 && (i(r3, "name") || o(r3, "name", t12)), e3[t12] !== r3 && (c2 && (i(r3, s) || o(r3, s, e3[t12] ? "" + e3[t12] : u.join(String(t12)))), e3 === n ? e3[t12] = r3 : a2 ? e3[t12] ? e3[t12] = r3 : o(e3, t12, r3) : (delete e3[t12], o(e3, t12, r3)));
        })(Function.prototype, a, function() {
          return "function" == typeof this && this[s] || c.call(this);
        });
      }, 5076: (e2, t11, r2) => {
        var n = r2(3888), o = r2(3504), i = /* @__PURE__ */ __name(function(e3, t12) {
          if (o(e3), !n(t12) && null !== t12) throw TypeError(t12 + ": can't set as prototype!");
        }, "i");
        e2.exports = { set: Object.setPrototypeOf || ("__proto__" in {} ? function(e3, t12, n2) {
          try {
            (n2 = r2(800)(Function.call, r2(6524).f(Object.prototype, "__proto__").set, 2))(e3, []), t12 = !(e3 instanceof Array);
          } catch (e4) {
            t12 = true;
          }
          return function(e4, r3) {
            return i(e4, r3), t12 ? e4.__proto__ = r3 : n2(e4, r3), e4;
          };
        }({}, false) : void 0), check: i };
      }, 3384: (e2, t11, r2) => {
        "use strict";
        var n = r2(2804), o = r2(8520), i = r2(1668), s = r2(7096)("species");
        e2.exports = function(e3) {
          var t12 = n[e3];
          i && t12 && !t12[s] && o.f(t12, s, { configurable: true, get: /* @__PURE__ */ __name(function() {
            return this;
          }, "get") });
        };
      }, 6256: (e2, t11, r2) => {
        var n = r2(8520).f, o = r2(9080), i = r2(7096)("toStringTag");
        e2.exports = function(e3, t12, r3) {
          e3 && !o(e3 = r3 ? e3 : e3.prototype, i) && n(e3, i, { configurable: true, value: t12 });
        };
      }, 4588: (e2, t11, r2) => {
        var n = r2(5432)("keys"), o = r2(9664);
        e2.exports = function(e3) {
          return n[e3] || (n[e3] = o(e3));
        };
      }, 5432: (e2, t11, r2) => {
        var n = r2(8432), o = r2(2804), i = "__core-js_shared__", s = o[i] || (o[i] = {});
        (e2.exports = function(e3, t12) {
          return s[e3] || (s[e3] = void 0 !== t12 ? t12 : {});
        })("versions", []).push({ version: n.version, mode: r2(4440) ? "pure" : "global", copyright: "\xA9 2018 Denis Pushkarev (zloirock.ru)" });
      }, 6776: (e2, t11, r2) => {
        var n = r2(3504), o = r2(2016), i = r2(7096)("species");
        e2.exports = function(e3, t12) {
          var r3, s = n(e3).constructor;
          return void 0 === s || null == (r3 = n(s)[i]) ? t12 : o(r3);
        };
      }, 6712: (e2, t11, r2) => {
        "use strict";
        var n = r2(9316);
        e2.exports = function(e3, t12) {
          return !!e3 && n(function() {
            t12 ? e3.call(null, function() {
            }, 1) : e3.call(null);
          });
        };
      }, 2280: (e2, t11, r2) => {
        var n, o, i, s = r2(800), a = r2(5628), c = r2(4016), u = r2(1300), l = r2(2804), f = l.process, p = l.setImmediate, h = l.clearImmediate, d = l.MessageChannel, m = l.Dispatch, g = 0, v = {}, y = "onreadystatechange", b = /* @__PURE__ */ __name(function() {
          var e3 = +this;
          if (v.hasOwnProperty(e3)) {
            var t12 = v[e3];
            delete v[e3], t12();
          }
        }, "b"), w = /* @__PURE__ */ __name(function(e3) {
          b.call(e3.data);
        }, "w");
        p && h || (p = /* @__PURE__ */ __name(function(e3) {
          for (var t12 = [], r3 = 1; arguments.length > r3; ) t12.push(arguments[r3++]);
          return v[++g] = function() {
            a("function" == typeof e3 ? e3 : Function(e3), t12);
          }, n(g), g;
        }, "p"), h = /* @__PURE__ */ __name(function(e3) {
          delete v[e3];
        }, "h"), "process" == r2(6924)(f) ? n = /* @__PURE__ */ __name(function(e3) {
          f.nextTick(s(b, e3, 1));
        }, "n") : m && m.now ? n = /* @__PURE__ */ __name(function(e3) {
          m.now(s(b, e3, 1));
        }, "n") : d ? (i = (o = new d()).port2, o.port1.onmessage = w, n = s(i.postMessage, i, 1)) : l.addEventListener && "function" == typeof postMessage && !l.importScripts ? (n = /* @__PURE__ */ __name(function(e3) {
          l.postMessage(e3 + "", "*");
        }, "n"), l.addEventListener("message", w, false)) : n = y in u("script") ? function(e3) {
          c.appendChild(u("script"))[y] = function() {
            c.removeChild(this), b.call(e3);
          };
        } : function(e3) {
          setTimeout(s(b, e3, 1), 0);
        }), e2.exports = { set: p, clear: h };
      }, 8508: (e2, t11, r2) => {
        var n = r2(8236), o = Math.max, i = Math.min;
        e2.exports = function(e3, t12) {
          return (e3 = n(e3)) < 0 ? o(e3 + t12, 0) : i(e3, t12);
        };
      }, 8236: (e2) => {
        var t11 = Math.ceil, r2 = Math.floor;
        e2.exports = function(e3) {
          return isNaN(e3 = +e3) ? 0 : (e3 > 0 ? r2 : t11)(e3);
        };
      }, 2780: (e2, t11, r2) => {
        var n = r2(2936), o = r2(24);
        e2.exports = function(e3) {
          return n(o(e3));
        };
      }, 3528: (e2, t11, r2) => {
        var n = r2(8236), o = Math.min;
        e2.exports = function(e3) {
          return e3 > 0 ? o(n(e3), 9007199254740991) : 0;
        };
      }, 1164: (e2, t11, r2) => {
        var n = r2(24);
        e2.exports = function(e3) {
          return Object(n(e3));
        };
      }, 1896: (e2, t11, r2) => {
        var n = r2(3888);
        e2.exports = function(e3, t12) {
          if (!n(e3)) return e3;
          var r3, o;
          if (t12 && "function" == typeof (r3 = e3.toString) && !n(o = r3.call(e3))) return o;
          if ("function" == typeof (r3 = e3.valueOf) && !n(o = r3.call(e3))) return o;
          if (!t12 && "function" == typeof (r3 = e3.toString) && !n(o = r3.call(e3))) return o;
          throw TypeError("Can't convert object to primitive value");
        };
      }, 9664: (e2) => {
        var t11 = 0, r2 = Math.random();
        e2.exports = function(e3) {
          return "Symbol(".concat(void 0 === e3 ? "" : e3, ")_", (++t11 + r2).toString(36));
        };
      }, 1168: (e2, t11, r2) => {
        var n = r2(2804).navigator;
        e2.exports = n && n.userAgent || "";
      }, 2772: (e2, t11, r2) => {
        var n = r2(3888);
        e2.exports = function(e3, t12) {
          if (!n(e3) || e3._t !== t12) throw TypeError("Incompatible receiver, " + t12 + " required!");
          return e3;
        };
      }, 7096: (e2, t11, r2) => {
        var n = r2(5432)("wks"), o = r2(9664), i = r2(2804).Symbol, s = "function" == typeof i;
        (e2.exports = function(e3) {
          return n[e3] || (n[e3] = s && i[e3] || (s ? i : o)("Symbol." + e3));
        }).store = n;
      }, 2800: (e2, t11, r2) => {
        var n = r2(5848), o = r2(7096)("iterator"), i = r2(2488);
        e2.exports = r2(8432).getIteratorMethod = function(e3) {
          if (null != e3) return e3[o] || e3["@@iterator"] || i[n(e3)];
        };
      }, 4228: (e2, t11, r2) => {
        "use strict";
        var n = r2(800), o = r2(7076), i = r2(1164), s = r2(2372), a = r2(3164), c = r2(3528), u = r2(2340), l = r2(2800);
        o(o.S + o.F * !r2(8380)(function(e3) {
          Array.from(e3);
        }), "Array", { from: /* @__PURE__ */ __name(function(e3) {
          var t12, r3, o2, f, p = i(e3), h = "function" == typeof this ? this : Array, d = arguments.length, m = d > 1 ? arguments[1] : void 0, g = void 0 !== m, v = 0, y = l(p);
          if (g && (m = n(m, d > 2 ? arguments[2] : void 0, 2)), null == y || h == Array && a(y)) for (r3 = new h(t12 = c(p.length)); t12 > v; v++) u(r3, v, g ? m(p[v], v) : p[v]);
          else for (f = y.call(p), r3 = new h(); !(o2 = f.next()).done; v++) u(r3, v, g ? s(f, m, [o2.value, v], true) : o2.value);
          return r3.length = v, r3;
        }, "from") });
      }, 4260: (e2, t11, r2) => {
        "use strict";
        var n = r2(7076), o = r2(2016), i = r2(1164), s = r2(9316), a = [].sort, c = [1, 2, 3];
        n(n.P + n.F * (s(function() {
          c.sort(void 0);
        }) || !s(function() {
          c.sort(null);
        }) || !r2(6712)(a)), "Array", { sort: /* @__PURE__ */ __name(function(e3) {
          return void 0 === e3 ? a.call(i(this)) : a.call(i(this), o(e3));
        }, "sort") });
      }, 5584: (e2, t11, r2) => {
        var n = r2(7076);
        n(n.S + n.F, "Object", { assign: r2(6472) });
      }, 5888: (e2, t11, r2) => {
        "use strict";
        var n, o, i, s, a = r2(4440), c = r2(2804), u = r2(800), l = r2(5848), f = r2(7076), p = r2(3888), h = r2(2016), d = r2(2388), m = r2(7228), g = r2(6776), v = r2(2280).set, y = r2(448)(), b = r2(8024), w = r2(7904), x = r2(1168), S = r2(0), P = "Promise", O = c.TypeError, I = c.process, E = I && I.versions, j = E && E.v8 || "", _ = c[P], A = "process" == l(I), k = /* @__PURE__ */ __name(function() {
        }, "k"), N = o = b.f, F = !!function() {
          try {
            var e3 = _.resolve(1), t12 = (e3.constructor = {})[r2(7096)("species")] = function(e4) {
              e4(k, k);
            };
            return (A || "function" == typeof PromiseRejectionEvent) && e3.then(k) instanceof t12 && 0 !== j.indexOf("6.6") && -1 === x.indexOf("Chrome/66");
          } catch (e4) {
          }
        }(), C = /* @__PURE__ */ __name(function(e3) {
          var t12;
          return !(!p(e3) || "function" != typeof (t12 = e3.then)) && t12;
        }, "C"), M = /* @__PURE__ */ __name(function(e3, t12) {
          if (!e3._n) {
            e3._n = true;
            var r3 = e3._c;
            y(function() {
              for (var n2 = e3._v, o2 = 1 == e3._s, i2 = 0, s2 = function(t13) {
                var r4, i3, s3, a2 = o2 ? t13.ok : t13.fail, c2 = t13.resolve, u2 = t13.reject, l2 = t13.domain;
                try {
                  a2 ? (o2 || (2 == e3._h && D(e3), e3._h = 1), true === a2 ? r4 = n2 : (l2 && l2.enter(), r4 = a2(n2), l2 && (l2.exit(), s3 = true)), r4 === t13.promise ? u2(O("Promise-chain cycle")) : (i3 = C(r4)) ? i3.call(r4, c2, u2) : c2(r4)) : u2(n2);
                } catch (e4) {
                  l2 && !s3 && l2.exit(), u2(e4);
                }
              }; r3.length > i2; ) s2(r3[i2++]);
              e3._c = [], e3._n = false, t12 && !e3._h && V(e3);
            });
          }
        }, "M"), V = /* @__PURE__ */ __name(function(e3) {
          v.call(c, function() {
            var t12, r3, n2, o2 = e3._v, i2 = T(e3);
            if (i2 && (t12 = w(function() {
              A ? I.emit("unhandledRejection", o2, e3) : (r3 = c.onunhandledrejection) ? r3({ promise: e3, reason: o2 }) : (n2 = c.console) && n2.error && n2.error("Unhandled promise rejection", o2);
            }), e3._h = A || T(e3) ? 2 : 1), e3._a = void 0, i2 && t12.e) throw t12.v;
          });
        }, "V"), T = /* @__PURE__ */ __name(function(e3) {
          return 1 !== e3._h && 0 === (e3._a || e3._c).length;
        }, "T"), D = /* @__PURE__ */ __name(function(e3) {
          v.call(c, function() {
            var t12;
            A ? I.emit("rejectionHandled", e3) : (t12 = c.onrejectionhandled) && t12({ promise: e3, reason: e3._v });
          });
        }, "D"), L = /* @__PURE__ */ __name(function(e3) {
          var t12 = this;
          t12._d || (t12._d = true, (t12 = t12._w || t12)._v = e3, t12._s = 2, t12._a || (t12._a = t12._c.slice()), M(t12, true));
        }, "L"), $ = /* @__PURE__ */ __name(function(e3) {
          var t12, r3 = this;
          if (!r3._d) {
            r3._d = true, r3 = r3._w || r3;
            try {
              if (r3 === e3) throw O("Promise can't be resolved itself");
              (t12 = C(e3)) ? y(function() {
                var n2 = { _w: r3, _d: false };
                try {
                  t12.call(e3, u($, n2, 1), u(L, n2, 1));
                } catch (e4) {
                  L.call(n2, e4);
                }
              }) : (r3._v = e3, r3._s = 1, M(r3, false));
            } catch (e4) {
              L.call({ _w: r3, _d: false }, e4);
            }
          }
        }, "$");
        F || (_ = /* @__PURE__ */ __name(function(e3) {
          d(this, _, P, "_h"), h(e3), n.call(this);
          try {
            e3(u($, this, 1), u(L, this, 1));
          } catch (e4) {
            L.call(this, e4);
          }
        }, "_"), (n = /* @__PURE__ */ __name(function(e3) {
          this._c = [], this._a = void 0, this._s = 0, this._d = false, this._v = void 0, this._h = 0, this._n = false;
        }, "n")).prototype = r2(7704)(_.prototype, { then: /* @__PURE__ */ __name(function(e3, t12) {
          var r3 = N(g(this, _));
          return r3.ok = "function" != typeof e3 || e3, r3.fail = "function" == typeof t12 && t12, r3.domain = A ? I.domain : void 0, this._c.push(r3), this._a && this._a.push(r3), this._s && M(this, false), r3.promise;
        }, "then"), catch: /* @__PURE__ */ __name(function(e3) {
          return this.then(void 0, e3);
        }, "catch") }), i = /* @__PURE__ */ __name(function() {
          var e3 = new n();
          this.promise = e3, this.resolve = u($, e3, 1), this.reject = u(L, e3, 1);
        }, "i"), b.f = N = /* @__PURE__ */ __name(function(e3) {
          return e3 === _ || e3 === s ? new i(e3) : o(e3);
        }, "N")), f(f.G + f.W + f.F * !F, { Promise: _ }), r2(6256)(_, P), r2(3384)(P), s = r2(8432)[P], f(f.S + f.F * !F, P, { reject: /* @__PURE__ */ __name(function(e3) {
          var t12 = N(this);
          return (0, t12.reject)(e3), t12.promise;
        }, "reject") }), f(f.S + f.F * (a || !F), P, { resolve: /* @__PURE__ */ __name(function(e3) {
          return S(a && this === s ? _ : this, e3);
        }, "resolve") }), f(f.S + f.F * !(F && r2(8380)(function(e3) {
          _.all(e3).catch(k);
        })), P, { all: /* @__PURE__ */ __name(function(e3) {
          var t12 = this, r3 = N(t12), n2 = r3.resolve, o2 = r3.reject, i2 = w(function() {
            var r4 = [], i3 = 0, s2 = 1;
            m(e3, false, function(e4) {
              var a2 = i3++, c2 = false;
              r4.push(void 0), s2++, t12.resolve(e4).then(function(e5) {
                c2 || (c2 = true, r4[a2] = e5, --s2 || n2(r4));
              }, o2);
            }), --s2 || n2(r4);
          });
          return i2.e && o2(i2.v), r3.promise;
        }, "all"), race: /* @__PURE__ */ __name(function(e3) {
          var t12 = this, r3 = N(t12), n2 = r3.reject, o2 = w(function() {
            m(e3, false, function(e4) {
              t12.resolve(e4).then(r3.resolve, n2);
            });
          });
          return o2.e && n2(o2.v), r3.promise;
        }, "race") });
      }, 7320: (e2, t11, r2) => {
        r2(1668) && "g" != /./g.flags && r2(8520).f(RegExp.prototype, "flags", { configurable: true, get: r2(8068) });
      }, 4880: (e2, t11, r2) => {
        r2(4448)("match", 1, function(e3, t12, r3) {
          return [function(r4) {
            "use strict";
            var n = e3(this), o = null == r4 ? void 0 : r4[t12];
            return void 0 !== o ? o.call(r4, n) : new RegExp(r4)[t12](String(n));
          }, r3];
        });
      }, 8412: (e2, t11, r2) => {
        r2(4448)("replace", 2, function(e3, t12, r3) {
          return [function(n, o) {
            "use strict";
            var i = e3(this), s = null == n ? void 0 : n[t12];
            return void 0 !== s ? s.call(n, i, o) : r3.call(String(i), n, o);
          }, r3];
        });
      }, 223: (e2, t11, r2) => {
        r2(4448)("search", 1, function(e3, t12, r3) {
          return [function(r4) {
            "use strict";
            var n = e3(this), o = null == r4 ? void 0 : r4[t12];
            return void 0 !== o ? o.call(r4, n) : new RegExp(r4)[t12](String(n));
          }, r3];
        });
      }, 3708: (e2, t11, r2) => {
        r2(4448)("split", 2, function(e3, t12, n) {
          "use strict";
          var o = r2(7760), i = n, s = [].push, a = "split", c = "length", u = "lastIndex";
          if ("c" == "abbc"[a](/(b)*/)[1] || 4 != "test"[a](/(?:)/, -1)[c] || 2 != "ab"[a](/(?:ab)*/)[c] || 4 != "."[a](/(.?)(.?)/)[c] || "."[a](/()()/)[c] > 1 || ""[a](/.?/)[c]) {
            var l = void 0 === /()??/.exec("")[1];
            n = /* @__PURE__ */ __name(function(e4, t13) {
              var r3 = String(this);
              if (void 0 === e4 && 0 === t13) return [];
              if (!o(e4)) return i.call(r3, e4, t13);
              var n2, a2, f, p, h, d = [], m = (e4.ignoreCase ? "i" : "") + (e4.multiline ? "m" : "") + (e4.unicode ? "u" : "") + (e4.sticky ? "y" : ""), g = 0, v = void 0 === t13 ? 4294967295 : t13 >>> 0, y = new RegExp(e4.source, m + "g");
              for (l || (n2 = new RegExp("^" + y.source + "$(?!\\s)", m)); (a2 = y.exec(r3)) && !((f = a2.index + a2[0][c]) > g && (d.push(r3.slice(g, a2.index)), !l && a2[c] > 1 && a2[0].replace(n2, function() {
                for (h = 1; h < arguments[c] - 2; h++) void 0 === arguments[h] && (a2[h] = void 0);
              }), a2[c] > 1 && a2.index < r3[c] && s.apply(d, a2.slice(1)), p = a2[0][c], g = f, d[c] >= v)); ) y[u] === a2.index && y[u]++;
              return g === r3[c] ? !p && y.test("") || d.push("") : d.push(r3.slice(g)), d[c] > v ? d.slice(0, v) : d;
            }, "n");
          } else "0"[a](void 0, 0)[c] && (n = /* @__PURE__ */ __name(function(e4, t13) {
            return void 0 === e4 && 0 === t13 ? [] : i.call(this, e4, t13);
          }, "n"));
          return [function(r3, o2) {
            var i2 = e3(this), s2 = null == r3 ? void 0 : r3[t12];
            return void 0 !== s2 ? s2.call(r3, i2, o2) : n.call(String(i2), r3, o2);
          }, n];
        });
      }, 6568: (e2, t11, r2) => {
        "use strict";
        r2(7320);
        var n = r2(3504), o = r2(8068), i = r2(1668), s = "toString", a = /./[s], c = /* @__PURE__ */ __name(function(e3) {
          r2(8868)(RegExp.prototype, s, e3, true);
        }, "c");
        r2(9316)(function() {
          return "/a/b" != a.call({ source: "a", flags: "b" });
        }) ? c(function() {
          var e3 = n(this);
          return "/".concat(e3.source, "/", "flags" in e3 ? e3.flags : !i && e3 instanceof RegExp ? o.call(e3) : void 0);
        }) : a.name != s && c(function() {
          return a.call(this);
        });
      }, 7276: (e2, t11, r2) => {
        "use strict";
        var n = r2(148), o = r2(2772);
        e2.exports = r2(9412)("Set", function(e3) {
          return function() {
            return e3(this, arguments.length > 0 ? arguments[0] : void 0);
          };
        }, { add: /* @__PURE__ */ __name(function(e3) {
          return n.def(o(this, "Set"), e3 = 0 === e3 ? 0 : e3, e3);
        }, "add") }, n);
      }, 7360: (e2, t11, r2) => {
        "use strict";
        var n = r2(7076), o = r2(7504)(true);
        n(n.P, "Array", { includes: /* @__PURE__ */ __name(function(e3) {
          return o(this, e3, arguments.length > 1 ? arguments[1] : void 0);
        }, "includes") }), r2(7384)("includes");
      }, 3852: (e2, t11, r2) => {
        var n = r2(7076), o = r2(2504)(true);
        n(n.S, "Object", { entries: /* @__PURE__ */ __name(function(e3) {
          return o(e3);
        }, "entries") });
      }, 5308: (e2, t11, r2) => {
        var n = r2(7076), o = r2(2504)(false);
        n(n.S, "Object", { values: /* @__PURE__ */ __name(function(e3) {
          return o(e3);
        }, "values") });
      }, 7468: (e2, t11, r2) => {
        "use strict";
        const n = r2(4368), o = r2(9624), i = r2(1846);
        function s(e3, t12, r3) {
          const s2 = o(e3, t12, r3), a = n.spawn(s2.command, s2.args, s2.options);
          return i.hookChildProcess(a, s2), a;
        }
        __name(s, "s");
        e2.exports = s, e2.exports.spawn = s, e2.exports.sync = function(e3, t12, r3) {
          const s2 = o(e3, t12, r3), a = n.spawnSync(s2.command, s2.args, s2.options);
          return a.error = a.error || i.verifyENOENTSync(a.status, s2), a;
        }, e2.exports._parse = o, e2.exports._enoent = i;
      }, 1846: (e2) => {
        "use strict";
        const t11 = "win32" === process.platform;
        function r2(e3, t12) {
          return Object.assign(new Error(`${t12} ${e3.command} ENOENT`), { code: "ENOENT", errno: "ENOENT", syscall: `${t12} ${e3.command}`, path: e3.command, spawnargs: e3.args });
        }
        __name(r2, "r");
        function n(e3, n2) {
          return t11 && 1 === e3 && !n2.file ? r2(n2.original, "spawn") : null;
        }
        __name(n, "n");
        e2.exports = { hookChildProcess: /* @__PURE__ */ __name(function(e3, r3) {
          if (!t11) return;
          const o = e3.emit;
          e3.emit = function(t12, i) {
            if ("exit" === t12) {
              const t13 = n(i, r3);
              if (t13) return o.call(e3, "error", t13);
            }
            return o.apply(e3, arguments);
          };
        }, "hookChildProcess"), verifyENOENT: n, verifyENOENTSync: /* @__PURE__ */ __name(function(e3, n2) {
          return t11 && 1 === e3 && !n2.file ? r2(n2.original, "spawnSync") : null;
        }, "verifyENOENTSync"), notFoundError: r2 };
      }, 9624: (e2, t11, r2) => {
        "use strict";
        const n = r2(7072), o = r2(9480), i = r2(8372), s = r2(824), a = r2(7780), c = r2(1716), u = "win32" === process.platform, l = /\.(?:com|exe)$/i, f = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i, p = o(() => c.satisfies(process.version, "^4.8.0 || ^5.7.0 || >= 6.0.0", true)) || false;
        e2.exports = function(e3, t12, r3) {
          t12 && !Array.isArray(t12) && (r3 = t12, t12 = null);
          const o2 = { command: e3, args: t12 = t12 ? t12.slice(0) : [], options: r3 = Object.assign({}, r3), file: void 0, original: { command: e3, args: t12 } };
          return r3.shell ? function(e4) {
            if (p) return e4;
            const t13 = [e4.command].concat(e4.args).join(" ");
            return u ? (e4.command = "string" == typeof e4.options.shell ? e4.options.shell : process.env.comspec || "cmd.exe", e4.args = ["/d", "/s", "/c", `"${t13}"`], e4.options.windowsVerbatimArguments = true) : ("string" == typeof e4.options.shell ? e4.command = e4.options.shell : "android" === process.platform ? e4.command = "/system/bin/sh" : e4.command = "/bin/sh", e4.args = ["-c", t13]), e4;
          }(o2) : function(e4) {
            if (!u) return e4;
            const t13 = function(e5) {
              e5.file = i(e5);
              const t14 = e5.file && a(e5.file);
              return t14 ? (e5.args.unshift(e5.file), e5.command = t14, i(e5)) : e5.file;
            }(e4), r4 = !l.test(t13);
            if (e4.options.forceShell || r4) {
              const r5 = f.test(t13);
              e4.command = n.normalize(e4.command), e4.command = s.command(e4.command), e4.args = e4.args.map((e5) => s.argument(e5, r5));
              const o3 = [e4.command].concat(e4.args).join(" ");
              e4.args = ["/d", "/s", "/c", `"${o3}"`], e4.command = process.env.comspec || "cmd.exe", e4.options.windowsVerbatimArguments = true;
            }
            return e4;
          }(o2);
        };
      }, 824: (e2) => {
        "use strict";
        const t11 = /([()\][%!^"`<>&|;, *?])/g;
        e2.exports.command = function(e3) {
          return e3.replace(t11, "^$1");
        }, e2.exports.argument = function(e3, r2) {
          return e3 = (e3 = `"${e3 = (e3 = (e3 = `${e3}`).replace(/(\\*)"/g, '$1$1\\"')).replace(/(\\*)$/, "$1$1")}"`).replace(t11, "^$1"), r2 && (e3 = e3.replace(t11, "^$1")), e3;
        };
      }, 7780: (e2, t11, r2) => {
        "use strict";
        const n = r2(2058), o = r2(6176);
        e2.exports = function(e3) {
          let t12, r3;
          Buffer.alloc ? t12 = Buffer.alloc(150) : (t12 = new Buffer(150), t12.fill(0));
          try {
            r3 = n.openSync(e3, "r"), n.readSync(r3, t12, 0, 150, 0), n.closeSync(r3);
          } catch (e4) {
          }
          return o(t12.toString());
        };
      }, 8372: (e2, t11, r2) => {
        "use strict";
        const n = r2(7072), o = r2(8460), i = r2(3032)();
        function s(e3, t12) {
          const r3 = process.cwd(), s2 = null != e3.options.cwd;
          if (s2) try {
            process.chdir(e3.options.cwd);
          } catch (e4) {
          }
          let a;
          try {
            a = o.sync(e3.command, { path: (e3.options.env || process.env)[i], pathExt: t12 ? n.delimiter : void 0 });
          } catch (e4) {
          } finally {
            process.chdir(r3);
          }
          return a && (a = n.resolve(s2 ? e3.options.cwd : "", a)), a;
        }
        __name(s, "s");
        e2.exports = function(e3) {
          return s(e3) || s(e3, true);
        };
      }, 9988: (e2, t11, r2) => {
        var n = r2(4640), o = /* @__PURE__ */ __name(function() {
        }, "o"), i = /* @__PURE__ */ __name(function(e3, t12, r3) {
          if ("function" == typeof t12) return i(e3, null, t12);
          t12 || (t12 = {}), r3 = n(r3 || o);
          var s = e3._writableState, a = e3._readableState, c = t12.readable || false !== t12.readable && e3.readable, u = t12.writable || false !== t12.writable && e3.writable, l = /* @__PURE__ */ __name(function() {
            e3.writable || f();
          }, "l"), f = /* @__PURE__ */ __name(function() {
            u = false, c || r3.call(e3);
          }, "f"), p = /* @__PURE__ */ __name(function() {
            c = false, u || r3.call(e3);
          }, "p"), h = /* @__PURE__ */ __name(function(t13) {
            r3.call(e3, t13 ? new Error("exited with error code: " + t13) : null);
          }, "h"), d = /* @__PURE__ */ __name(function(t13) {
            r3.call(e3, t13);
          }, "d"), m = /* @__PURE__ */ __name(function() {
            return (!c || a && a.ended) && (!u || s && s.ended) ? void 0 : r3.call(e3, new Error("premature close"));
          }, "m"), g = /* @__PURE__ */ __name(function() {
            e3.req.on("finish", f);
          }, "g");
          return function(e4) {
            return e4.setHeader && "function" == typeof e4.abort;
          }(e3) ? (e3.on("complete", f), e3.on("abort", m), e3.req ? g() : e3.on("request", g)) : u && !s && (e3.on("end", l), e3.on("close", l)), function(e4) {
            return e4.stdio && Array.isArray(e4.stdio) && 3 === e4.stdio.length;
          }(e3) && e3.on("exit", h), e3.on("end", p), e3.on("finish", f), false !== t12.error && e3.on("error", d), e3.on("close", m), function() {
            e3.removeListener("complete", f), e3.removeListener("abort", m), e3.removeListener("request", g), e3.req && e3.req.removeListener("finish", f), e3.removeListener("end", l), e3.removeListener("close", l), e3.removeListener("finish", f), e3.removeListener("exit", h), e3.removeListener("end", p), e3.removeListener("error", d), e3.removeListener("close", m);
          };
        }, "i");
        e2.exports = i;
      }, 84: (e2, t11, r2) => {
        e2.exports = l, l.realpath = l, l.sync = f, l.realpathSync = f, l.monkeypatch = function() {
          n.realpath = l, n.realpathSync = f;
        }, l.unmonkeypatch = function() {
          n.realpath = o, n.realpathSync = i;
        };
        var n = r2(2058), o = n.realpath, i = n.realpathSync, s = process.version, a = /^v[0-5]\./.test(s), c = r2(7192);
        function u(e3) {
          return e3 && "realpath" === e3.syscall && ("ELOOP" === e3.code || "ENOMEM" === e3.code || "ENAMETOOLONG" === e3.code);
        }
        __name(u, "u");
        function l(e3, t12, r3) {
          if (a) return o(e3, t12, r3);
          "function" == typeof t12 && (r3 = t12, t12 = null), o(e3, t12, function(n2, o2) {
            u(n2) ? c.realpath(e3, t12, r3) : r3(n2, o2);
          });
        }
        __name(l, "l");
        function f(e3, t12) {
          if (a) return i(e3, t12);
          try {
            return i(e3, t12);
          } catch (r3) {
            if (u(r3)) return c.realpathSync(e3, t12);
            throw r3;
          }
        }
        __name(f, "f");
      }, 7192: (e2, t11, r2) => {
        var n = r2(7072), o = "win32" === process.platform, i = r2(2058), s = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
        if (n.normalize, o) var a = /(.*?)(?:[\/\\]+|$)/g;
        else a = /(.*?)(?:[\/]+|$)/g;
        if (o) var c = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
        else c = /^[\/]*/;
        t11.realpathSync = function(e3, t12) {
          if (e3 = n.resolve(e3), t12 && Object.prototype.hasOwnProperty.call(t12, e3)) return t12[e3];
          var r3, s2, u, l, f = e3, p = {}, h = {};
          function d() {
            var t13 = c.exec(e3);
            r3 = t13[0].length, s2 = t13[0], u = t13[0], l = "", o && !h[u] && (i.lstatSync(u), h[u] = true);
          }
          __name(d, "d");
          for (d(); r3 < e3.length; ) {
            a.lastIndex = r3;
            var m = a.exec(e3);
            if (l = s2, s2 += m[0], u = l + m[1], r3 = a.lastIndex, !(h[u] || t12 && t12[u] === u)) {
              var g;
              if (t12 && Object.prototype.hasOwnProperty.call(t12, u)) g = t12[u];
              else {
                var v = i.lstatSync(u);
                if (!v.isSymbolicLink()) {
                  h[u] = true, t12 && (t12[u] = u);
                  continue;
                }
                var y = null;
                if (!o) {
                  var b = v.dev.toString(32) + ":" + v.ino.toString(32);
                  p.hasOwnProperty(b) && (y = p[b]);
                }
                null === y && (i.statSync(u), y = i.readlinkSync(u)), g = n.resolve(l, y), t12 && (t12[u] = g), o || (p[b] = y);
              }
              e3 = n.resolve(g, e3.slice(r3)), d();
            }
          }
          return t12 && (t12[f] = e3), e3;
        }, t11.realpath = function(e3, t12, r3) {
          if ("function" != typeof r3 && (r3 = function(e4) {
            return "function" == typeof e4 ? e4 : function() {
              var e5;
              if (s) {
                var t13 = new Error();
                e5 = /* @__PURE__ */ __name(function(e6) {
                  e6 && (t13.message = e6.message, r4(e6 = t13));
                }, "e");
              } else e5 = r4;
              return e5;
              function r4(e6) {
                if (e6) {
                  if (process.throwDeprecation) throw e6;
                  if (!process.noDeprecation) {
                    var t14 = "fs: missing callback " + (e6.stack || e6.message);
                    process.traceDeprecation ? console.trace(t14) : console.error(t14);
                  }
                }
              }
              __name(r4, "r");
            }();
          }(t12), t12 = null), e3 = n.resolve(e3), t12 && Object.prototype.hasOwnProperty.call(t12, e3)) return process.nextTick(r3.bind(null, null, t12[e3]));
          var u, l, f, p, h = e3, d = {}, m = {};
          function g() {
            var t13 = c.exec(e3);
            u = t13[0].length, l = t13[0], f = t13[0], p = "", o && !m[f] ? i.lstat(f, function(e4) {
              if (e4) return r3(e4);
              m[f] = true, v();
            }) : process.nextTick(v);
          }
          __name(g, "g");
          function v() {
            if (u >= e3.length) return t12 && (t12[h] = e3), r3(null, e3);
            a.lastIndex = u;
            var n2 = a.exec(e3);
            return p = l, l += n2[0], f = p + n2[1], u = a.lastIndex, m[f] || t12 && t12[f] === f ? process.nextTick(v) : t12 && Object.prototype.hasOwnProperty.call(t12, f) ? w(t12[f]) : i.lstat(f, y);
          }
          __name(v, "v");
          function y(e4, n2) {
            if (e4) return r3(e4);
            if (!n2.isSymbolicLink()) return m[f] = true, t12 && (t12[f] = f), process.nextTick(v);
            if (!o) {
              var s2 = n2.dev.toString(32) + ":" + n2.ino.toString(32);
              if (d.hasOwnProperty(s2)) return b(null, d[s2], f);
            }
            i.stat(f, function(e5) {
              if (e5) return r3(e5);
              i.readlink(f, function(e6, t13) {
                o || (d[s2] = t13), b(e6, t13);
              });
            });
          }
          __name(y, "y");
          function b(e4, o2, i2) {
            if (e4) return r3(e4);
            var s2 = n.resolve(p, o2);
            t12 && (t12[i2] = s2), w(s2);
          }
          __name(b, "b");
          function w(t13) {
            e3 = n.resolve(t13, e3.slice(u)), g();
          }
          __name(w, "w");
          g();
        };
      }, 9712: (e2, t11, r2) => {
        function n(e3, t12) {
          return Object.prototype.hasOwnProperty.call(e3, t12);
        }
        __name(n, "n");
        t11.alphasort = u, t11.alphasorti = c, t11.setopts = function(e3, t12, r3) {
          if (r3 || (r3 = {}), r3.matchBase && -1 === t12.indexOf("/")) {
            if (r3.noglobstar) throw new Error("base matching requires globstar");
            t12 = "**/" + t12;
          }
          e3.silent = !!r3.silent, e3.pattern = t12, e3.strict = false !== r3.strict, e3.realpath = !!r3.realpath, e3.realpathCache = r3.realpathCache || /* @__PURE__ */ Object.create(null), e3.follow = !!r3.follow, e3.dot = !!r3.dot, e3.mark = !!r3.mark, e3.nodir = !!r3.nodir, e3.nodir && (e3.mark = true), e3.sync = !!r3.sync, e3.nounique = !!r3.nounique, e3.nonull = !!r3.nonull, e3.nosort = !!r3.nosort, e3.nocase = !!r3.nocase, e3.stat = !!r3.stat, e3.noprocess = !!r3.noprocess, e3.absolute = !!r3.absolute, e3.maxLength = r3.maxLength || 1 / 0, e3.cache = r3.cache || /* @__PURE__ */ Object.create(null), e3.statCache = r3.statCache || /* @__PURE__ */ Object.create(null), e3.symlinks = r3.symlinks || /* @__PURE__ */ Object.create(null), function(e4, t13) {
            e4.ignore = t13.ignore || [], Array.isArray(e4.ignore) || (e4.ignore = [e4.ignore]), e4.ignore.length && (e4.ignore = e4.ignore.map(l));
          }(e3, r3), e3.changedCwd = false;
          var i2 = process.cwd();
          n(r3, "cwd") ? (e3.cwd = o.resolve(r3.cwd), e3.changedCwd = e3.cwd !== i2) : e3.cwd = i2, e3.root = r3.root || o.resolve(e3.cwd, "/"), e3.root = o.resolve(e3.root), "win32" === process.platform && (e3.root = e3.root.replace(/\\/g, "/")), e3.cwdAbs = s(e3.cwd) ? e3.cwd : f(e3, e3.cwd), "win32" === process.platform && (e3.cwdAbs = e3.cwdAbs.replace(/\\/g, "/")), e3.nomount = !!r3.nomount, r3.nonegate = true, r3.nocomment = true, e3.minimatch = new a(t12, r3), e3.options = e3.minimatch.options;
        }, t11.ownProp = n, t11.makeAbs = f, t11.finish = function(e3) {
          for (var t12 = e3.nounique, r3 = t12 ? [] : /* @__PURE__ */ Object.create(null), n2 = 0, o2 = e3.matches.length; n2 < o2; n2++) {
            var i2 = e3.matches[n2];
            if (i2 && 0 !== Object.keys(i2).length) {
              var s2 = Object.keys(i2);
              t12 ? r3.push.apply(r3, s2) : s2.forEach(function(e4) {
                r3[e4] = true;
              });
            } else if (e3.nonull) {
              var a2 = e3.minimatch.globSet[n2];
              t12 ? r3.push(a2) : r3[a2] = true;
            }
          }
          if (t12 || (r3 = Object.keys(r3)), e3.nosort || (r3 = r3.sort(e3.nocase ? c : u)), e3.mark) {
            for (n2 = 0; n2 < r3.length; n2++) r3[n2] = e3._mark(r3[n2]);
            e3.nodir && (r3 = r3.filter(function(t13) {
              var r4 = !/\/$/.test(t13), n3 = e3.cache[t13] || e3.cache[f(e3, t13)];
              return r4 && n3 && (r4 = "DIR" !== n3 && !Array.isArray(n3)), r4;
            }));
          }
          e3.ignore.length && (r3 = r3.filter(function(t13) {
            return !p(e3, t13);
          })), e3.found = r3;
        }, t11.mark = function(e3, t12) {
          var r3 = f(e3, t12), n2 = e3.cache[r3], o2 = t12;
          if (n2) {
            var i2 = "DIR" === n2 || Array.isArray(n2), s2 = "/" === t12.slice(-1);
            if (i2 && !s2 ? o2 += "/" : !i2 && s2 && (o2 = o2.slice(0, -1)), o2 !== t12) {
              var a2 = f(e3, o2);
              e3.statCache[a2] = e3.statCache[r3], e3.cache[a2] = e3.cache[r3];
            }
          }
          return o2;
        }, t11.isIgnored = p, t11.childrenIgnored = function(e3, t12) {
          return !!e3.ignore.length && e3.ignore.some(function(e4) {
            return !(!e4.gmatcher || !e4.gmatcher.match(t12));
          });
        };
        var o = r2(7072), i = r2(836), s = r2(4832), a = i.Minimatch;
        function c(e3, t12) {
          return e3.toLowerCase().localeCompare(t12.toLowerCase());
        }
        __name(c, "c");
        function u(e3, t12) {
          return e3.localeCompare(t12);
        }
        __name(u, "u");
        function l(e3) {
          var t12 = null;
          if ("/**" === e3.slice(-3)) {
            var r3 = e3.replace(/(\/\*\*)+$/, "");
            t12 = new a(r3, { dot: true });
          }
          return { matcher: new a(e3, { dot: true }), gmatcher: t12 };
        }
        __name(l, "l");
        function f(e3, t12) {
          var r3 = t12;
          return r3 = "/" === t12.charAt(0) ? o.join(e3.root, t12) : s(t12) || "" === t12 ? t12 : e3.changedCwd ? o.resolve(e3.cwd, t12) : o.resolve(t12), "win32" === process.platform && (r3 = r3.replace(/\\/g, "/")), r3;
        }
        __name(f, "f");
        function p(e3, t12) {
          return !!e3.ignore.length && e3.ignore.some(function(e4) {
            return e4.matcher.match(t12) || !(!e4.gmatcher || !e4.gmatcher.match(t12));
          });
        }
        __name(p, "p");
      }, 808: (e2, t11, r2) => {
        e2.exports = b;
        var n = r2(2058), o = r2(84), i = r2(836), s = (i.Minimatch, r2(3352)), a = r2(467).EventEmitter, c = r2(7072), u = r2(6608), l = r2(4832), f = r2(4548), p = r2(9712), h = (p.alphasort, p.alphasorti, p.setopts), d = p.ownProp, m = r2(363), g = (r2(970), p.childrenIgnored), v = p.isIgnored, y = r2(4640);
        function b(e3, t12, r3) {
          if ("function" == typeof t12 && (r3 = t12, t12 = {}), t12 || (t12 = {}), t12.sync) {
            if (r3) throw new TypeError("callback provided to sync glob");
            return f(e3, t12);
          }
          return new x(e3, t12, r3);
        }
        __name(b, "b");
        b.sync = f;
        var w = b.GlobSync = f.GlobSync;
        function x(e3, t12, r3) {
          if ("function" == typeof t12 && (r3 = t12, t12 = null), t12 && t12.sync) {
            if (r3) throw new TypeError("callback provided to sync glob");
            return new w(e3, t12);
          }
          if (!(this instanceof x)) return new x(e3, t12, r3);
          h(this, e3, t12), this._didRealPath = false;
          var n2 = this.minimatch.set.length;
          this.matches = new Array(n2), "function" == typeof r3 && (r3 = y(r3), this.on("error", r3), this.on("end", function(e4) {
            r3(null, e4);
          }));
          var o2 = this;
          if (this._processing = 0, this._emitQueue = [], this._processQueue = [], this.paused = false, this.noprocess) return this;
          if (0 === n2) return a2();
          for (var i2 = true, s2 = 0; s2 < n2; s2++) this._process(this.minimatch.set[s2], s2, false, a2);
          function a2() {
            --o2._processing, o2._processing <= 0 && (i2 ? process.nextTick(function() {
              o2._finish();
            }) : o2._finish());
          }
          __name(a2, "a");
          i2 = false;
        }
        __name(x, "x");
        b.glob = b, b.hasMagic = function(e3, t12) {
          var r3 = function(e4, t13) {
            if (null === t13 || "object" != typeof t13) return e4;
            for (var r4 = Object.keys(t13), n3 = r4.length; n3--; ) e4[r4[n3]] = t13[r4[n3]];
            return e4;
          }({}, t12);
          r3.noprocess = true;
          var n2 = new x(e3, r3).minimatch.set;
          if (!e3) return false;
          if (n2.length > 1) return true;
          for (var o2 = 0; o2 < n2[0].length; o2++) if ("string" != typeof n2[0][o2]) return true;
          return false;
        }, b.Glob = x, s(x, a), x.prototype._finish = function() {
          if (u(this instanceof x), !this.aborted) {
            if (this.realpath && !this._didRealpath) return this._realpath();
            p.finish(this), this.emit("end", this.found);
          }
        }, x.prototype._realpath = function() {
          if (!this._didRealpath) {
            this._didRealpath = true;
            var e3 = this.matches.length;
            if (0 === e3) return this._finish();
            for (var t12 = this, r3 = 0; r3 < this.matches.length; r3++) this._realpathSet(r3, n2);
          }
          function n2() {
            0 == --e3 && t12._finish();
          }
          __name(n2, "n");
        }, x.prototype._realpathSet = function(e3, t12) {
          var r3 = this.matches[e3];
          if (!r3) return t12();
          var n2 = Object.keys(r3), i2 = this, s2 = n2.length;
          if (0 === s2) return t12();
          var a2 = this.matches[e3] = /* @__PURE__ */ Object.create(null);
          n2.forEach(function(r4, n3) {
            r4 = i2._makeAbs(r4), o.realpath(r4, i2.realpathCache, function(n4, o2) {
              n4 ? "stat" === n4.syscall ? a2[r4] = true : i2.emit("error", n4) : a2[o2] = true, 0 == --s2 && (i2.matches[e3] = a2, t12());
            });
          });
        }, x.prototype._mark = function(e3) {
          return p.mark(this, e3);
        }, x.prototype._makeAbs = function(e3) {
          return p.makeAbs(this, e3);
        }, x.prototype.abort = function() {
          this.aborted = true, this.emit("abort");
        }, x.prototype.pause = function() {
          this.paused || (this.paused = true, this.emit("pause"));
        }, x.prototype.resume = function() {
          if (this.paused) {
            if (this.emit("resume"), this.paused = false, this._emitQueue.length) {
              var e3 = this._emitQueue.slice(0);
              this._emitQueue.length = 0;
              for (var t12 = 0; t12 < e3.length; t12++) {
                var r3 = e3[t12];
                this._emitMatch(r3[0], r3[1]);
              }
            }
            if (this._processQueue.length) {
              var n2 = this._processQueue.slice(0);
              for (this._processQueue.length = 0, t12 = 0; t12 < n2.length; t12++) {
                var o2 = n2[t12];
                this._processing--, this._process(o2[0], o2[1], o2[2], o2[3]);
              }
            }
          }
        }, x.prototype._process = function(e3, t12, r3, n2) {
          if (u(this instanceof x), u("function" == typeof n2), !this.aborted) if (this._processing++, this.paused) this._processQueue.push([e3, t12, r3, n2]);
          else {
            for (var o2, s2 = 0; "string" == typeof e3[s2]; ) s2++;
            switch (s2) {
              case e3.length:
                return void this._processSimple(e3.join("/"), t12, n2);
              case 0:
                o2 = null;
                break;
              default:
                o2 = e3.slice(0, s2).join("/");
            }
            var a2, c2 = e3.slice(s2);
            null === o2 ? a2 = "." : l(o2) || l(e3.join("/")) ? (o2 && l(o2) || (o2 = "/" + o2), a2 = o2) : a2 = o2;
            var f2 = this._makeAbs(a2);
            if (g(this, a2)) return n2();
            c2[0] === i.GLOBSTAR ? this._processGlobStar(o2, a2, f2, c2, t12, r3, n2) : this._processReaddir(o2, a2, f2, c2, t12, r3, n2);
          }
        }, x.prototype._processReaddir = function(e3, t12, r3, n2, o2, i2, s2) {
          var a2 = this;
          this._readdir(r3, i2, function(c2, u2) {
            return a2._processReaddir2(e3, t12, r3, n2, o2, i2, u2, s2);
          });
        }, x.prototype._processReaddir2 = function(e3, t12, r3, n2, o2, i2, s2, a2) {
          if (!s2) return a2();
          for (var u2 = n2[0], l2 = !!this.minimatch.negate, f2 = u2._glob, p2 = this.dot || "." === f2.charAt(0), h2 = [], d2 = 0; d2 < s2.length; d2++) ("." !== (g2 = s2[d2]).charAt(0) || p2) && (l2 && !e3 ? !g2.match(u2) : g2.match(u2)) && h2.push(g2);
          var m2 = h2.length;
          if (0 === m2) return a2();
          if (1 === n2.length && !this.mark && !this.stat) {
            for (this.matches[o2] || (this.matches[o2] = /* @__PURE__ */ Object.create(null)), d2 = 0; d2 < m2; d2++) {
              var g2 = h2[d2];
              e3 && (g2 = "/" !== e3 ? e3 + "/" + g2 : e3 + g2), "/" !== g2.charAt(0) || this.nomount || (g2 = c.join(this.root, g2)), this._emitMatch(o2, g2);
            }
            return a2();
          }
          for (n2.shift(), d2 = 0; d2 < m2; d2++) g2 = h2[d2], e3 && (g2 = "/" !== e3 ? e3 + "/" + g2 : e3 + g2), this._process([g2].concat(n2), o2, i2, a2);
          a2();
        }, x.prototype._emitMatch = function(e3, t12) {
          if (!this.aborted && !v(this, t12)) if (this.paused) this._emitQueue.push([e3, t12]);
          else {
            var r3 = l(t12) ? t12 : this._makeAbs(t12);
            if (this.mark && (t12 = this._mark(t12)), this.absolute && (t12 = r3), !this.matches[e3][t12]) {
              if (this.nodir) {
                var n2 = this.cache[r3];
                if ("DIR" === n2 || Array.isArray(n2)) return;
              }
              this.matches[e3][t12] = true;
              var o2 = this.statCache[r3];
              o2 && this.emit("stat", t12, o2), this.emit("match", t12);
            }
          }
        }, x.prototype._readdirInGlobStar = function(e3, t12) {
          if (!this.aborted) {
            if (this.follow) return this._readdir(e3, false, t12);
            var r3 = this, o2 = m("lstat\0" + e3, function(n2, o3) {
              if (n2 && "ENOENT" === n2.code) return t12();
              var i2 = o3 && o3.isSymbolicLink();
              r3.symlinks[e3] = i2, i2 || !o3 || o3.isDirectory() ? r3._readdir(e3, false, t12) : (r3.cache[e3] = "FILE", t12());
            });
            o2 && n.lstat(e3, o2);
          }
        }, x.prototype._readdir = function(e3, t12, r3) {
          if (!this.aborted && (r3 = m("readdir\0" + e3 + "\0" + t12, r3))) {
            if (t12 && !d(this.symlinks, e3)) return this._readdirInGlobStar(e3, r3);
            if (d(this.cache, e3)) {
              var o2 = this.cache[e3];
              if (!o2 || "FILE" === o2) return r3();
              if (Array.isArray(o2)) return r3(null, o2);
            }
            n.readdir(e3, /* @__PURE__ */ function(e4, t13, r4) {
              return function(n2, o3) {
                n2 ? e4._readdirError(t13, n2, r4) : e4._readdirEntries(t13, o3, r4);
              };
            }(this, e3, r3));
          }
        }, x.prototype._readdirEntries = function(e3, t12, r3) {
          if (!this.aborted) {
            if (!this.mark && !this.stat) for (var n2 = 0; n2 < t12.length; n2++) {
              var o2 = t12[n2];
              o2 = "/" === e3 ? e3 + o2 : e3 + "/" + o2, this.cache[o2] = true;
            }
            return this.cache[e3] = t12, r3(null, t12);
          }
        }, x.prototype._readdirError = function(e3, t12, r3) {
          if (!this.aborted) {
            switch (t12.code) {
              case "ENOTSUP":
              case "ENOTDIR":
                var n2 = this._makeAbs(e3);
                if (this.cache[n2] = "FILE", n2 === this.cwdAbs) {
                  var o2 = new Error(t12.code + " invalid cwd " + this.cwd);
                  o2.path = this.cwd, o2.code = t12.code, this.emit("error", o2), this.abort();
                }
                break;
              case "ENOENT":
              case "ELOOP":
              case "ENAMETOOLONG":
              case "UNKNOWN":
                this.cache[this._makeAbs(e3)] = false;
                break;
              default:
                this.cache[this._makeAbs(e3)] = false, this.strict && (this.emit("error", t12), this.abort()), this.silent || console.error("glob error", t12);
            }
            return r3();
          }
        }, x.prototype._processGlobStar = function(e3, t12, r3, n2, o2, i2, s2) {
          var a2 = this;
          this._readdir(r3, i2, function(c2, u2) {
            a2._processGlobStar2(e3, t12, r3, n2, o2, i2, u2, s2);
          });
        }, x.prototype._processGlobStar2 = function(e3, t12, r3, n2, o2, i2, s2, a2) {
          if (!s2) return a2();
          var c2 = n2.slice(1), u2 = e3 ? [e3] : [], l2 = u2.concat(c2);
          this._process(l2, o2, false, a2);
          var f2 = this.symlinks[r3], p2 = s2.length;
          if (f2 && i2) return a2();
          for (var h2 = 0; h2 < p2; h2++) if ("." !== s2[h2].charAt(0) || this.dot) {
            var d2 = u2.concat(s2[h2], c2);
            this._process(d2, o2, true, a2);
            var m2 = u2.concat(s2[h2], n2);
            this._process(m2, o2, true, a2);
          }
          a2();
        }, x.prototype._processSimple = function(e3, t12, r3) {
          var n2 = this;
          this._stat(e3, function(o2, i2) {
            n2._processSimple2(e3, t12, o2, i2, r3);
          });
        }, x.prototype._processSimple2 = function(e3, t12, r3, n2, o2) {
          if (this.matches[t12] || (this.matches[t12] = /* @__PURE__ */ Object.create(null)), !n2) return o2();
          if (e3 && l(e3) && !this.nomount) {
            var i2 = /[\/\\]$/.test(e3);
            "/" === e3.charAt(0) ? e3 = c.join(this.root, e3) : (e3 = c.resolve(this.root, e3), i2 && (e3 += "/"));
          }
          "win32" === process.platform && (e3 = e3.replace(/\\/g, "/")), this._emitMatch(t12, e3), o2();
        }, x.prototype._stat = function(e3, t12) {
          var r3 = this._makeAbs(e3), o2 = "/" === e3.slice(-1);
          if (e3.length > this.maxLength) return t12();
          if (!this.stat && d(this.cache, r3)) {
            var i2 = this.cache[r3];
            if (Array.isArray(i2) && (i2 = "DIR"), !o2 || "DIR" === i2) return t12(null, i2);
            if (o2 && "FILE" === i2) return t12();
          }
          var s2 = this.statCache[r3];
          if (void 0 !== s2) {
            if (false === s2) return t12(null, s2);
            var a2 = s2.isDirectory() ? "DIR" : "FILE";
            return o2 && "FILE" === a2 ? t12() : t12(null, a2, s2);
          }
          var c2 = this, u2 = m("stat\0" + r3, function(o3, i3) {
            if (i3 && i3.isSymbolicLink()) return n.stat(r3, function(n2, o4) {
              n2 ? c2._stat2(e3, r3, null, i3, t12) : c2._stat2(e3, r3, n2, o4, t12);
            });
            c2._stat2(e3, r3, o3, i3, t12);
          });
          u2 && n.lstat(r3, u2);
        }, x.prototype._stat2 = function(e3, t12, r3, n2, o2) {
          if (r3 && ("ENOENT" === r3.code || "ENOTDIR" === r3.code)) return this.statCache[t12] = false, o2();
          var i2 = "/" === e3.slice(-1);
          if (this.statCache[t12] = n2, "/" === t12.slice(-1) && n2 && !n2.isDirectory()) return o2(null, false, n2);
          var s2 = true;
          return n2 && (s2 = n2.isDirectory() ? "DIR" : "FILE"), this.cache[t12] = this.cache[t12] || s2, i2 && "FILE" === s2 ? o2() : o2(null, s2, n2);
        };
      }, 4548: (e2, t11, r2) => {
        e2.exports = d, d.GlobSync = m;
        var n = r2(2058), o = r2(84), i = r2(836), s = (i.Minimatch, r2(808).Glob, r2(970), r2(7072)), a = r2(6608), c = r2(4832), u = r2(9712), l = (u.alphasort, u.alphasorti, u.setopts), f = u.ownProp, p = u.childrenIgnored, h = u.isIgnored;
        function d(e3, t12) {
          if ("function" == typeof t12 || 3 === arguments.length) throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
          return new m(e3, t12).found;
        }
        __name(d, "d");
        function m(e3, t12) {
          if (!e3) throw new Error("must provide pattern");
          if ("function" == typeof t12 || 3 === arguments.length) throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
          if (!(this instanceof m)) return new m(e3, t12);
          if (l(this, e3, t12), this.noprocess) return this;
          var r3 = this.minimatch.set.length;
          this.matches = new Array(r3);
          for (var n2 = 0; n2 < r3; n2++) this._process(this.minimatch.set[n2], n2, false);
          this._finish();
        }
        __name(m, "m");
        m.prototype._finish = function() {
          if (a(this instanceof m), this.realpath) {
            var e3 = this;
            this.matches.forEach(function(t12, r3) {
              var n2 = e3.matches[r3] = /* @__PURE__ */ Object.create(null);
              for (var i2 in t12) try {
                i2 = e3._makeAbs(i2), n2[o.realpathSync(i2, e3.realpathCache)] = true;
              } catch (t13) {
                if ("stat" !== t13.syscall) throw t13;
                n2[e3._makeAbs(i2)] = true;
              }
            });
          }
          u.finish(this);
        }, m.prototype._process = function(e3, t12, r3) {
          a(this instanceof m);
          for (var n2, o2 = 0; "string" == typeof e3[o2]; ) o2++;
          switch (o2) {
            case e3.length:
              return void this._processSimple(e3.join("/"), t12);
            case 0:
              n2 = null;
              break;
            default:
              n2 = e3.slice(0, o2).join("/");
          }
          var s2, u2 = e3.slice(o2);
          null === n2 ? s2 = "." : c(n2) || c(e3.join("/")) ? (n2 && c(n2) || (n2 = "/" + n2), s2 = n2) : s2 = n2;
          var l2 = this._makeAbs(s2);
          p(this, s2) || (u2[0] === i.GLOBSTAR ? this._processGlobStar(n2, s2, l2, u2, t12, r3) : this._processReaddir(n2, s2, l2, u2, t12, r3));
        }, m.prototype._processReaddir = function(e3, t12, r3, n2, o2, i2) {
          var a2 = this._readdir(r3, i2);
          if (a2) {
            for (var c2 = n2[0], u2 = !!this.minimatch.negate, l2 = c2._glob, f2 = this.dot || "." === l2.charAt(0), p2 = [], h2 = 0; h2 < a2.length; h2++) ("." !== (g = a2[h2]).charAt(0) || f2) && (u2 && !e3 ? !g.match(c2) : g.match(c2)) && p2.push(g);
            var d2 = p2.length;
            if (0 !== d2) if (1 !== n2.length || this.mark || this.stat) for (n2.shift(), h2 = 0; h2 < d2; h2++) {
              var m2;
              g = p2[h2], m2 = e3 ? [e3, g] : [g], this._process(m2.concat(n2), o2, i2);
            }
            else {
              this.matches[o2] || (this.matches[o2] = /* @__PURE__ */ Object.create(null));
              for (h2 = 0; h2 < d2; h2++) {
                var g = p2[h2];
                e3 && (g = "/" !== e3.slice(-1) ? e3 + "/" + g : e3 + g), "/" !== g.charAt(0) || this.nomount || (g = s.join(this.root, g)), this._emitMatch(o2, g);
              }
            }
          }
        }, m.prototype._emitMatch = function(e3, t12) {
          if (!h(this, t12)) {
            var r3 = this._makeAbs(t12);
            if (this.mark && (t12 = this._mark(t12)), this.absolute && (t12 = r3), !this.matches[e3][t12]) {
              if (this.nodir) {
                var n2 = this.cache[r3];
                if ("DIR" === n2 || Array.isArray(n2)) return;
              }
              this.matches[e3][t12] = true, this.stat && this._stat(t12);
            }
          }
        }, m.prototype._readdirInGlobStar = function(e3) {
          if (this.follow) return this._readdir(e3, false);
          var t12, r3;
          try {
            r3 = n.lstatSync(e3);
          } catch (e4) {
            if ("ENOENT" === e4.code) return null;
          }
          var o2 = r3 && r3.isSymbolicLink();
          return this.symlinks[e3] = o2, o2 || !r3 || r3.isDirectory() ? t12 = this._readdir(e3, false) : this.cache[e3] = "FILE", t12;
        }, m.prototype._readdir = function(e3, t12) {
          if (t12 && !f(this.symlinks, e3)) return this._readdirInGlobStar(e3);
          if (f(this.cache, e3)) {
            var r3 = this.cache[e3];
            if (!r3 || "FILE" === r3) return null;
            if (Array.isArray(r3)) return r3;
          }
          try {
            return this._readdirEntries(e3, n.readdirSync(e3));
          } catch (t13) {
            return this._readdirError(e3, t13), null;
          }
        }, m.prototype._readdirEntries = function(e3, t12) {
          if (!this.mark && !this.stat) for (var r3 = 0; r3 < t12.length; r3++) {
            var n2 = t12[r3];
            n2 = "/" === e3 ? e3 + n2 : e3 + "/" + n2, this.cache[n2] = true;
          }
          return this.cache[e3] = t12, t12;
        }, m.prototype._readdirError = function(e3, t12) {
          switch (t12.code) {
            case "ENOTSUP":
            case "ENOTDIR":
              var r3 = this._makeAbs(e3);
              if (this.cache[r3] = "FILE", r3 === this.cwdAbs) {
                var n2 = new Error(t12.code + " invalid cwd " + this.cwd);
                throw n2.path = this.cwd, n2.code = t12.code, n2;
              }
              break;
            case "ENOENT":
            case "ELOOP":
            case "ENAMETOOLONG":
            case "UNKNOWN":
              this.cache[this._makeAbs(e3)] = false;
              break;
            default:
              if (this.cache[this._makeAbs(e3)] = false, this.strict) throw t12;
              this.silent || console.error("glob error", t12);
          }
        }, m.prototype._processGlobStar = function(e3, t12, r3, n2, o2, i2) {
          var s2 = this._readdir(r3, i2);
          if (s2) {
            var a2 = n2.slice(1), c2 = e3 ? [e3] : [], u2 = c2.concat(a2);
            this._process(u2, o2, false);
            var l2 = s2.length;
            if (!this.symlinks[r3] || !i2) {
              for (var f2 = 0; f2 < l2; f2++) if ("." !== s2[f2].charAt(0) || this.dot) {
                var p2 = c2.concat(s2[f2], a2);
                this._process(p2, o2, true);
                var h2 = c2.concat(s2[f2], n2);
                this._process(h2, o2, true);
              }
            }
          }
        }, m.prototype._processSimple = function(e3, t12) {
          var r3 = this._stat(e3);
          if (this.matches[t12] || (this.matches[t12] = /* @__PURE__ */ Object.create(null)), r3) {
            if (e3 && c(e3) && !this.nomount) {
              var n2 = /[\/\\]$/.test(e3);
              "/" === e3.charAt(0) ? e3 = s.join(this.root, e3) : (e3 = s.resolve(this.root, e3), n2 && (e3 += "/"));
            }
            "win32" === process.platform && (e3 = e3.replace(/\\/g, "/")), this._emitMatch(t12, e3);
          }
        }, m.prototype._stat = function(e3) {
          var t12 = this._makeAbs(e3), r3 = "/" === e3.slice(-1);
          if (e3.length > this.maxLength) return false;
          if (!this.stat && f(this.cache, t12)) {
            var o2 = this.cache[t12];
            if (Array.isArray(o2) && (o2 = "DIR"), !r3 || "DIR" === o2) return o2;
            if (r3 && "FILE" === o2) return false;
          }
          var i2 = this.statCache[t12];
          if (!i2) {
            var s2;
            try {
              s2 = n.lstatSync(t12);
            } catch (e4) {
              if (e4 && ("ENOENT" === e4.code || "ENOTDIR" === e4.code)) return this.statCache[t12] = false, false;
            }
            if (s2 && s2.isSymbolicLink()) try {
              i2 = n.statSync(t12);
            } catch (e4) {
              i2 = s2;
            }
            else i2 = s2;
          }
          return this.statCache[t12] = i2, o2 = true, i2 && (o2 = i2.isDirectory() ? "DIR" : "FILE"), this.cache[t12] = this.cache[t12] || o2, (!r3 || "FILE" !== o2) && o2;
        }, m.prototype._mark = function(e3) {
          return u.mark(this, e3);
        }, m.prototype._makeAbs = function(e3) {
          return u.makeAbs(this, e3);
        };
      }, 363: (e2, t11, r2) => {
        var n = r2(2680), o = /* @__PURE__ */ Object.create(null), i = r2(4640);
        e2.exports = n(function(e3, t12) {
          return o[e3] ? (o[e3].push(t12), null) : (o[e3] = [t12], function(e4) {
            return i(/* @__PURE__ */ __name(function t13() {
              var r3 = o[e4], n2 = r3.length, i2 = function(e5) {
                for (var t14 = e5.length, r4 = [], n3 = 0; n3 < t14; n3++) r4[n3] = e5[n3];
                return r4;
              }(arguments);
              try {
                for (var s = 0; s < n2; s++) r3[s].apply(null, i2);
              } finally {
                r3.length > n2 ? (r3.splice(0, n2), process.nextTick(function() {
                  t13.apply(null, i2);
                })) : delete o[e4];
              }
            }, "t"));
          }(e3));
        });
      }, 3352: (e2, t11, r2) => {
        try {
          var n = r2(970);
          if ("function" != typeof n.inherits) throw "";
          e2.exports = n.inherits;
        } catch (t12) {
          e2.exports = r2(8248);
        }
      }, 8248: (e2) => {
        "function" == typeof Object.create ? e2.exports = function(e3, t11) {
          e3.super_ = t11, e3.prototype = Object.create(t11.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } });
        } : e2.exports = function(e3, t11) {
          e3.super_ = t11;
          var r2 = /* @__PURE__ */ __name(function() {
          }, "r");
          r2.prototype = t11.prototype, e3.prototype = new r2(), e3.prototype.constructor = e3;
        };
      }, 1392: (e2) => {
        "use strict";
        var t11 = e2.exports = function(e3) {
          return null !== e3 && "object" == typeof e3 && "function" == typeof e3.pipe;
        };
        t11.writable = function(e3) {
          return t11(e3) && false !== e3.writable && "function" == typeof e3._write && "object" == typeof e3._writableState;
        }, t11.readable = function(e3) {
          return t11(e3) && false !== e3.readable && "function" == typeof e3._read && "object" == typeof e3._readableState;
        }, t11.duplex = function(e3) {
          return t11.writable(e3) && t11.readable(e3);
        }, t11.transform = function(e3) {
          return t11.duplex(e3) && "function" == typeof e3._transform && "object" == typeof e3._transformState;
        };
      }, 9268: (e2, t11, r2) => {
        var n;
        function o(e3, t12, r3) {
          if ("function" == typeof t12 && (r3 = t12, t12 = {}), !r3) {
            if ("function" != typeof Promise) throw new TypeError("callback not provided");
            return new Promise(function(r4, n2) {
              o(e3, t12 || {}, function(e4, t13) {
                e4 ? n2(e4) : r4(t13);
              });
            });
          }
          n(e3, t12 || {}, function(e4, n2) {
            e4 && ("EACCES" === e4.code || t12 && t12.ignoreErrors) && (e4 = null, n2 = false), r3(e4, n2);
          });
        }
        __name(o, "o");
        r2(2058), n = "win32" === process.platform || global.TESTING_WINDOWS ? r2(8340) : r2(8692), e2.exports = o, o.sync = function(e3, t12) {
          try {
            return n.sync(e3, t12 || {});
          } catch (e4) {
            if (t12 && t12.ignoreErrors || "EACCES" === e4.code) return false;
            throw e4;
          }
        };
      }, 8692: (e2, t11, r2) => {
        e2.exports = o, o.sync = function(e3, t12) {
          return i(n.statSync(e3), t12);
        };
        var n = r2(2058);
        function o(e3, t12, r3) {
          n.stat(e3, function(e4, n2) {
            r3(e4, !e4 && i(n2, t12));
          });
        }
        __name(o, "o");
        function i(e3, t12) {
          return e3.isFile() && function(e4, t13) {
            var r3 = e4.mode, n2 = e4.uid, o2 = e4.gid, i2 = void 0 !== t13.uid ? t13.uid : process.getuid && process.getuid(), s = void 0 !== t13.gid ? t13.gid : process.getgid && process.getgid(), a = parseInt("100", 8), c = parseInt("010", 8);
            return r3 & parseInt("001", 8) || r3 & c && o2 === s || r3 & a && n2 === i2 || r3 & (a | c) && 0 === i2;
          }(e3, t12);
        }
        __name(i, "i");
      }, 8340: (e2, t11, r2) => {
        e2.exports = i, i.sync = function(e3, t12) {
          return o(n.statSync(e3), e3, t12);
        };
        var n = r2(2058);
        function o(e3, t12, r3) {
          return !(!e3.isSymbolicLink() && !e3.isFile()) && function(e4, t13) {
            var r4 = void 0 !== t13.pathExt ? t13.pathExt : process.env.PATHEXT;
            if (!r4) return true;
            if (-1 !== (r4 = r4.split(";")).indexOf("")) return true;
            for (var n2 = 0; n2 < r4.length; n2++) {
              var o2 = r4[n2].toLowerCase();
              if (o2 && e4.substr(-o2.length).toLowerCase() === o2) return true;
            }
            return false;
          }(t12, r3);
        }
        __name(o, "o");
        function i(e3, t12, r3) {
          n.stat(e3, function(n2, i2) {
            r3(n2, !n2 && o(i2, e3, t12));
          });
        }
        __name(i, "i");
      }, 2941: (e2, t11, r2) => {
        "use strict";
        const n = r2(8558), o = /* @__PURE__ */ new Map([[18, "Mojave"], [17, "High Sierra"], [16, "Sierra"], [15, "El Capitan"], [14, "Yosemite"], [13, "Mavericks"], [12, "Mountain Lion"], [11, "Lion"], [10, "Snow Leopard"], [9, "Leopard"], [8, "Tiger"], [7, "Panther"], [6, "Jaguar"], [5, "Puma"]]), i = /* @__PURE__ */ __name((e3) => (e3 = Number((e3 || n.release()).split(".")[0]), { name: o.get(e3), version: "10." + (e3 - 4) }), "i");
        e2.exports = i, e2.exports.default = i;
      }, 836: (e2, t11, r2) => {
        e2.exports = p, p.Minimatch = h;
        var n = { sep: "/" };
        try {
          n = r2(7072);
        } catch (e3) {
        }
        var o = p.GLOBSTAR = h.GLOBSTAR = {}, i = r2(1620), s = { "!": { open: "(?:(?!(?:", close: "))[^/]*?)" }, "?": { open: "(?:", close: ")?" }, "+": { open: "(?:", close: ")+" }, "*": { open: "(?:", close: ")*" }, "@": { open: "(?:", close: ")" } }, a = "[^/]", c = a + "*?", u = "().*{}+?[]^$\\!".split("").reduce(function(e3, t12) {
          return e3[t12] = true, e3;
        }, {}), l = /\/+/;
        function f(e3, t12) {
          e3 = e3 || {}, t12 = t12 || {};
          var r3 = {};
          return Object.keys(t12).forEach(function(e4) {
            r3[e4] = t12[e4];
          }), Object.keys(e3).forEach(function(t13) {
            r3[t13] = e3[t13];
          }), r3;
        }
        __name(f, "f");
        function p(e3, t12, r3) {
          if ("string" != typeof t12) throw new TypeError("glob pattern string required");
          return r3 || (r3 = {}), !(!r3.nocomment && "#" === t12.charAt(0)) && ("" === t12.trim() ? "" === e3 : new h(t12, r3).match(e3));
        }
        __name(p, "p");
        function h(e3, t12) {
          if (!(this instanceof h)) return new h(e3, t12);
          if ("string" != typeof e3) throw new TypeError("glob pattern string required");
          t12 || (t12 = {}), e3 = e3.trim(), "/" !== n.sep && (e3 = e3.split(n.sep).join("/")), this.options = t12, this.set = [], this.pattern = e3, this.regexp = null, this.negate = false, this.comment = false, this.empty = false, this.make();
        }
        __name(h, "h");
        function d(e3, t12) {
          if (t12 || (t12 = this instanceof h ? this.options : {}), void 0 === (e3 = void 0 === e3 ? this.pattern : e3)) throw new TypeError("undefined pattern");
          return t12.nobrace || !e3.match(/\{.*\}/) ? [e3] : i(e3);
        }
        __name(d, "d");
        p.filter = function(e3, t12) {
          return t12 = t12 || {}, function(r3, n2, o2) {
            return p(r3, e3, t12);
          };
        }, p.defaults = function(e3) {
          if (!e3 || !Object.keys(e3).length) return p;
          var t12 = p, r3 = /* @__PURE__ */ __name(function(r4, n2, o2) {
            return t12.minimatch(r4, n2, f(e3, o2));
          }, "r");
          return r3.Minimatch = function(r4, n2) {
            return new t12.Minimatch(r4, f(e3, n2));
          }, r3;
        }, h.defaults = function(e3) {
          return e3 && Object.keys(e3).length ? p.defaults(e3).Minimatch : h;
        }, h.prototype.debug = function() {
        }, h.prototype.make = function() {
          if (!this._made) {
            var e3 = this.pattern, t12 = this.options;
            if (t12.nocomment || "#" !== e3.charAt(0)) if (e3) {
              this.parseNegate();
              var r3 = this.globSet = this.braceExpand();
              t12.debug && (this.debug = console.error), this.debug(this.pattern, r3), r3 = this.globParts = r3.map(function(e4) {
                return e4.split(l);
              }), this.debug(this.pattern, r3), r3 = r3.map(function(e4, t13, r4) {
                return e4.map(this.parse, this);
              }, this), this.debug(this.pattern, r3), r3 = r3.filter(function(e4) {
                return -1 === e4.indexOf(false);
              }), this.debug(this.pattern, r3), this.set = r3;
            } else this.empty = true;
            else this.comment = true;
          }
        }, h.prototype.parseNegate = function() {
          var e3 = this.pattern, t12 = false, r3 = 0;
          if (!this.options.nonegate) {
            for (var n2 = 0, o2 = e3.length; n2 < o2 && "!" === e3.charAt(n2); n2++) t12 = !t12, r3++;
            r3 && (this.pattern = e3.substr(r3)), this.negate = t12;
          }
        }, p.braceExpand = function(e3, t12) {
          return d(e3, t12);
        }, h.prototype.braceExpand = d, h.prototype.parse = function(e3, t12) {
          if (e3.length > 65536) throw new TypeError("pattern is too long");
          var r3 = this.options;
          if (!r3.noglobstar && "**" === e3) return o;
          if ("" === e3) return "";
          var n2, i2 = "", l2 = !!r3.nocase, f2 = false, p2 = [], h2 = [], d2 = false, g = -1, v = -1, y = "." === e3.charAt(0) ? "" : r3.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", b = this;
          function w() {
            if (n2) {
              switch (n2) {
                case "*":
                  i2 += c, l2 = true;
                  break;
                case "?":
                  i2 += a, l2 = true;
                  break;
                default:
                  i2 += "\\" + n2;
              }
              b.debug("clearStateChar %j %j", n2, i2), n2 = false;
            }
          }
          __name(w, "w");
          for (var x, S = 0, P = e3.length; S < P && (x = e3.charAt(S)); S++) if (this.debug("%s	%s %s %j", e3, S, i2, x), f2 && u[x]) i2 += "\\" + x, f2 = false;
          else switch (x) {
            case "/":
              return false;
            case "\\":
              w(), f2 = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              if (this.debug("%s	%s %s %j <-- stateChar", e3, S, i2, x), d2) {
                this.debug("  in class"), "!" === x && S === v + 1 && (x = "^"), i2 += x;
                continue;
              }
              b.debug("call clearStateChar %j", n2), w(), n2 = x, r3.noext && w();
              continue;
            case "(":
              if (d2) {
                i2 += "(";
                continue;
              }
              if (!n2) {
                i2 += "\\(";
                continue;
              }
              p2.push({ type: n2, start: S - 1, reStart: i2.length, open: s[n2].open, close: s[n2].close }), i2 += "!" === n2 ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", n2, i2), n2 = false;
              continue;
            case ")":
              if (d2 || !p2.length) {
                i2 += "\\)";
                continue;
              }
              w(), l2 = true;
              var O = p2.pop();
              i2 += O.close, "!" === O.type && h2.push(O), O.reEnd = i2.length;
              continue;
            case "|":
              if (d2 || !p2.length || f2) {
                i2 += "\\|", f2 = false;
                continue;
              }
              w(), i2 += "|";
              continue;
            case "[":
              if (w(), d2) {
                i2 += "\\" + x;
                continue;
              }
              d2 = true, v = S, g = i2.length, i2 += x;
              continue;
            case "]":
              if (S === v + 1 || !d2) {
                i2 += "\\" + x, f2 = false;
                continue;
              }
              if (d2) {
                var I = e3.substring(v + 1, S);
                try {
                  RegExp("[" + I + "]");
                } catch (e4) {
                  var E = this.parse(I, m);
                  i2 = i2.substr(0, g) + "\\[" + E[0] + "\\]", l2 = l2 || E[1], d2 = false;
                  continue;
                }
              }
              l2 = true, d2 = false, i2 += x;
              continue;
            default:
              w(), f2 ? f2 = false : !u[x] || "^" === x && d2 || (i2 += "\\"), i2 += x;
          }
          for (d2 && (I = e3.substr(v + 1), E = this.parse(I, m), i2 = i2.substr(0, g) + "\\[" + E[0], l2 = l2 || E[1]), O = p2.pop(); O; O = p2.pop()) {
            var j = i2.slice(O.reStart + O.open.length);
            this.debug("setting tail", i2, O), j = j.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(e4, t13, r4) {
              return r4 || (r4 = "\\"), t13 + t13 + r4 + "|";
            }), this.debug("tail=%j\n   %s", j, j, O, i2);
            var _ = "*" === O.type ? c : "?" === O.type ? a : "\\" + O.type;
            l2 = true, i2 = i2.slice(0, O.reStart) + _ + "\\(" + j;
          }
          w(), f2 && (i2 += "\\\\");
          var A = false;
          switch (i2.charAt(0)) {
            case ".":
            case "[":
            case "(":
              A = true;
          }
          for (var k = h2.length - 1; k > -1; k--) {
            var N = h2[k], F = i2.slice(0, N.reStart), C = i2.slice(N.reStart, N.reEnd - 8), M = i2.slice(N.reEnd - 8, N.reEnd), V = i2.slice(N.reEnd);
            M += V;
            var T = F.split("(").length - 1, D = V;
            for (S = 0; S < T; S++) D = D.replace(/\)[+*?]?/, "");
            var L = "";
            "" === (V = D) && t12 !== m && (L = "$"), i2 = F + C + V + L + M;
          }
          if ("" !== i2 && l2 && (i2 = "(?=.)" + i2), A && (i2 = y + i2), t12 === m) return [i2, l2];
          if (!l2) return e3.replace(/\\(.)/g, "$1");
          var $ = r3.nocase ? "i" : "";
          try {
            var B = new RegExp("^" + i2 + "$", $);
          } catch (e4) {
            return new RegExp("$.");
          }
          return B._glob = e3, B._src = i2, B;
        };
        var m = {};
        p.makeRe = function(e3, t12) {
          return new h(e3, t12 || {}).makeRe();
        }, h.prototype.makeRe = function() {
          if (this.regexp || false === this.regexp) return this.regexp;
          var e3 = this.set;
          if (!e3.length) return this.regexp = false, this.regexp;
          var t12 = this.options, r3 = t12.noglobstar ? c : t12.dot ? "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?" : "(?:(?!(?:\\/|^)\\.).)*?", n2 = t12.nocase ? "i" : "", i2 = e3.map(function(e4) {
            return e4.map(function(e5) {
              return e5 === o ? r3 : "string" == typeof e5 ? e5.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : e5._src;
            }).join("\\/");
          }).join("|");
          i2 = "^(?:" + i2 + ")$", this.negate && (i2 = "^(?!" + i2 + ").*$");
          try {
            this.regexp = new RegExp(i2, n2);
          } catch (e4) {
            this.regexp = false;
          }
          return this.regexp;
        }, p.match = function(e3, t12, r3) {
          var n2 = new h(t12, r3 = r3 || {});
          return e3 = e3.filter(function(e4) {
            return n2.match(e4);
          }), n2.options.nonull && !e3.length && e3.push(t12), e3;
        }, h.prototype.match = function(e3, t12) {
          if (this.debug("match", e3, this.pattern), this.comment) return false;
          if (this.empty) return "" === e3;
          if ("/" === e3 && t12) return true;
          var r3 = this.options;
          "/" !== n.sep && (e3 = e3.split(n.sep).join("/")), e3 = e3.split(l), this.debug(this.pattern, "split", e3);
          var o2, i2, s2 = this.set;
          for (this.debug(this.pattern, "set", s2), i2 = e3.length - 1; i2 >= 0 && !(o2 = e3[i2]); i2--) ;
          for (i2 = 0; i2 < s2.length; i2++) {
            var a2 = s2[i2], c2 = e3;
            if (r3.matchBase && 1 === a2.length && (c2 = [o2]), this.matchOne(c2, a2, t12)) return !!r3.flipNegate || !this.negate;
          }
          return !r3.flipNegate && this.negate;
        }, h.prototype.matchOne = function(e3, t12, r3) {
          var n2 = this.options;
          this.debug("matchOne", { this: this, file: e3, pattern: t12 }), this.debug("matchOne", e3.length, t12.length);
          for (var i2 = 0, s2 = 0, a2 = e3.length, c2 = t12.length; i2 < a2 && s2 < c2; i2++, s2++) {
            this.debug("matchOne loop");
            var u2, l2 = t12[s2], f2 = e3[i2];
            if (this.debug(t12, l2, f2), false === l2) return false;
            if (l2 === o) {
              this.debug("GLOBSTAR", [t12, l2, f2]);
              var p2 = i2, h2 = s2 + 1;
              if (h2 === c2) {
                for (this.debug("** at the end"); i2 < a2; i2++) if ("." === e3[i2] || ".." === e3[i2] || !n2.dot && "." === e3[i2].charAt(0)) return false;
                return true;
              }
              for (; p2 < a2; ) {
                var d2 = e3[p2];
                if (this.debug("\nglobstar while", e3, p2, t12, h2, d2), this.matchOne(e3.slice(p2), t12.slice(h2), r3)) return this.debug("globstar found match!", p2, a2, d2), true;
                if ("." === d2 || ".." === d2 || !n2.dot && "." === d2.charAt(0)) {
                  this.debug("dot detected!", e3, p2, t12, h2);
                  break;
                }
                this.debug("globstar swallow a segment, and continue"), p2++;
              }
              return !(!r3 || (this.debug("\n>>> no match, partial?", e3, p2, t12, h2), p2 !== a2));
            }
            if ("string" == typeof l2 ? (u2 = n2.nocase ? f2.toLowerCase() === l2.toLowerCase() : f2 === l2, this.debug("string match", l2, f2, u2)) : (u2 = f2.match(l2), this.debug("pattern match", l2, f2, u2)), !u2) return false;
          }
          if (i2 === a2 && s2 === c2) return true;
          if (i2 === a2) return r3;
          if (s2 === c2) return i2 === a2 - 1 && "" === e3[i2];
          throw new Error("wtf?");
        };
      }, 9480: (e2) => {
        "use strict";
        e2.exports = function(e3) {
          try {
            return e3();
          } catch (e4) {
          }
        };
      }, 9584: (e2, t11, r2) => {
        "use strict";
        const n = r2(7072), o = r2(3032);
        e2.exports = (e3) => {
          let t12;
          e3 = Object.assign({ cwd: process.cwd(), path: process.env[o()] }, e3);
          let r3 = n.resolve(e3.cwd);
          const i = [];
          for (; t12 !== r3; ) i.push(n.join(r3, "node_modules/.bin")), t12 = r3, r3 = n.resolve(r3, "..");
          return i.push(n.dirname(process.execPath)), i.concat(e3.path).join(n.delimiter);
        }, e2.exports.env = (t12) => {
          t12 = Object.assign({ env: process.env }, t12);
          const r3 = Object.assign({}, t12.env), n2 = o({ env: r3 });
          return t12.path = r3[n2], r3[n2] = e2.exports(t12), r3;
        };
      }, 4640: (e2, t11, r2) => {
        var n = r2(2680);
        function o(e3) {
          var t12 = /* @__PURE__ */ __name(function() {
            return t12.called ? t12.value : (t12.called = true, t12.value = e3.apply(this, arguments));
          }, "t");
          return t12.called = false, t12;
        }
        __name(o, "o");
        function i(e3) {
          var t12 = /* @__PURE__ */ __name(function() {
            if (t12.called) throw new Error(t12.onceError);
            return t12.called = true, t12.value = e3.apply(this, arguments);
          }, "t"), r3 = e3.name || "Function wrapped with `once`";
          return t12.onceError = r3 + " shouldn't be called more than once", t12.called = false, t12;
        }
        __name(i, "i");
        e2.exports = n(o), e2.exports.strict = n(i), o.proto = o(function() {
          Object.defineProperty(Function.prototype, "once", { value: /* @__PURE__ */ __name(function() {
            return o(this);
          }, "value"), configurable: true }), Object.defineProperty(Function.prototype, "onceStrict", { value: /* @__PURE__ */ __name(function() {
            return i(this);
          }, "value"), configurable: true });
        });
      }, 2288: (e2, t11, r2) => {
        "use strict";
        const n = r2(8558), o = r2(2941), i = r2(6468);
        e2.exports = (e3, t12) => {
          if (!e3 && t12) throw new Error("You can't specify a `release` without specifying `platform`");
          let r3;
          if ("darwin" === (e3 = e3 || n.platform())) {
            t12 || "darwin" !== n.platform() || (t12 = n.release());
            const e4 = t12 ? Number(t12.split(".")[0]) > 15 ? "macOS" : "OS X" : "macOS";
            return r3 = t12 ? o(t12).name : "", e4 + (r3 ? " " + r3 : "");
          }
          return "linux" === e3 ? (t12 || "linux" !== n.platform() || (t12 = n.release()), r3 = t12 ? t12.replace(/^(\d+\.\d+).*/, "$1") : "", "Linux" + (r3 ? " " + r3 : "")) : "win32" === e3 ? (t12 || "win32" !== n.platform() || (t12 = n.release()), r3 = t12 ? i(t12) : "", "Windows" + (r3 ? " " + r3 : "")) : e3;
        };
      }, 1548: (e2) => {
        "use strict";
        e2.exports = (e3, t11) => (t11 = t11 || (() => {
        }), e3.then((e4) => new Promise((e5) => {
          e5(t11());
        }).then(() => e4), (e4) => new Promise((e5) => {
          e5(t11());
        }).then(() => {
          throw e4;
        })));
      }, 4832: (e2) => {
        "use strict";
        function t11(e3) {
          return "/" === e3.charAt(0);
        }
        __name(t11, "t");
        function r2(e3) {
          var t12 = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/.exec(e3), r3 = t12[1] || "", n = Boolean(r3 && ":" !== r3.charAt(1));
          return Boolean(t12[2] || n);
        }
        __name(r2, "r");
        e2.exports = "win32" === process.platform ? r2 : t11, e2.exports.posix = t11, e2.exports.win32 = r2;
      }, 3032: (e2) => {
        "use strict";
        e2.exports = (e3) => {
          const t11 = (e3 = e3 || {}).env || process.env;
          return "win32" !== (e3.platform || process.platform) ? "PATH" : Object.keys(t11).find((e4) => "PATH" === e4.toUpperCase()) || "Path";
        };
      }, 8984: (e2, t11, r2) => {
        var n = r2(4640), o = r2(9988), i = r2(2058), s = /* @__PURE__ */ __name(function() {
        }, "s"), a = /^v?\.0/.test(process.version), c = /* @__PURE__ */ __name(function(e3) {
          return "function" == typeof e3;
        }, "c"), u = /* @__PURE__ */ __name(function(e3) {
          e3();
        }, "u"), l = /* @__PURE__ */ __name(function(e3, t12) {
          return e3.pipe(t12);
        }, "l");
        e2.exports = function() {
          var e3, t12 = Array.prototype.slice.call(arguments), r3 = c(t12[t12.length - 1] || s) && t12.pop() || s;
          if (Array.isArray(t12[0]) && (t12 = t12[0]), t12.length < 2) throw new Error("pump requires two streams per minimum");
          var f = t12.map(function(l2, p) {
            var h = p < t12.length - 1;
            return function(e4, t13, r4, u2) {
              u2 = n(u2);
              var l3 = false;
              e4.on("close", function() {
                l3 = true;
              }), o(e4, { readable: t13, writable: r4 }, function(e5) {
                if (e5) return u2(e5);
                l3 = true, u2();
              });
              var f2 = false;
              return function(t14) {
                if (!l3 && !f2) return f2 = true, function(e5) {
                  return !!a && !!i && (e5 instanceof (i.ReadStream || s) || e5 instanceof (i.WriteStream || s)) && c(e5.close);
                }(e4) ? e4.close(s) : function(e5) {
                  return e5.setHeader && c(e5.abort);
                }(e4) ? e4.abort() : c(e4.destroy) ? e4.destroy() : void u2(t14 || new Error("stream was destroyed"));
              };
            }(l2, h, p > 0, function(t13) {
              e3 || (e3 = t13), t13 && f.forEach(u), h || (f.forEach(u), r3(e3));
            });
          });
          return t12.reduce(l);
        };
      }, 1716: (e2, t11) => {
        var r2;
        t11 = e2.exports = Y, r2 = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
          var e3 = Array.prototype.slice.call(arguments, 0);
          e3.unshift("SEMVER"), console.log.apply(console, e3);
        } : function() {
        }, t11.SEMVER_SPEC_VERSION = "2.0.0";
        var n = 256, o = Number.MAX_SAFE_INTEGER || 9007199254740991, i = t11.re = [], s = t11.src = [], a = 0, c = a++;
        s[c] = "0|[1-9]\\d*";
        var u = a++;
        s[u] = "[0-9]+";
        var l = a++;
        s[l] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
        var f = a++;
        s[f] = "(" + s[c] + ")\\.(" + s[c] + ")\\.(" + s[c] + ")";
        var p = a++;
        s[p] = "(" + s[u] + ")\\.(" + s[u] + ")\\.(" + s[u] + ")";
        var h = a++;
        s[h] = "(?:" + s[c] + "|" + s[l] + ")";
        var d = a++;
        s[d] = "(?:" + s[u] + "|" + s[l] + ")";
        var m = a++;
        s[m] = "(?:-(" + s[h] + "(?:\\." + s[h] + ")*))";
        var g = a++;
        s[g] = "(?:-?(" + s[d] + "(?:\\." + s[d] + ")*))";
        var v = a++;
        s[v] = "[0-9A-Za-z-]+";
        var y = a++;
        s[y] = "(?:\\+(" + s[v] + "(?:\\." + s[v] + ")*))";
        var b = a++, w = "v?" + s[f] + s[m] + "?" + s[y] + "?";
        s[b] = "^" + w + "$";
        var x = "[v=\\s]*" + s[p] + s[g] + "?" + s[y] + "?", S = a++;
        s[S] = "^" + x + "$";
        var P = a++;
        s[P] = "((?:<|>)?=?)";
        var O = a++;
        s[O] = s[u] + "|x|X|\\*";
        var I = a++;
        s[I] = s[c] + "|x|X|\\*";
        var E = a++;
        s[E] = "[v=\\s]*(" + s[I] + ")(?:\\.(" + s[I] + ")(?:\\.(" + s[I] + ")(?:" + s[m] + ")?" + s[y] + "?)?)?";
        var j = a++;
        s[j] = "[v=\\s]*(" + s[O] + ")(?:\\.(" + s[O] + ")(?:\\.(" + s[O] + ")(?:" + s[g] + ")?" + s[y] + "?)?)?";
        var _ = a++;
        s[_] = "^" + s[P] + "\\s*" + s[E] + "$";
        var A = a++;
        s[A] = "^" + s[P] + "\\s*" + s[j] + "$";
        var k = a++;
        s[k] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
        var N = a++;
        s[N] = "(?:~>?)";
        var F = a++;
        s[F] = "(\\s*)" + s[N] + "\\s+", i[F] = new RegExp(s[F], "g");
        var C = a++;
        s[C] = "^" + s[N] + s[E] + "$";
        var M = a++;
        s[M] = "^" + s[N] + s[j] + "$";
        var V = a++;
        s[V] = "(?:\\^)";
        var T = a++;
        s[T] = "(\\s*)" + s[V] + "\\s+", i[T] = new RegExp(s[T], "g");
        var D = a++;
        s[D] = "^" + s[V] + s[E] + "$";
        var L = a++;
        s[L] = "^" + s[V] + s[j] + "$";
        var $ = a++;
        s[$] = "^" + s[P] + "\\s*(" + x + ")$|^$";
        var B = a++;
        s[B] = "^" + s[P] + "\\s*(" + w + ")$|^$";
        var R = a++;
        s[R] = "(\\s*)" + s[P] + "\\s*(" + x + "|" + s[E] + ")", i[R] = new RegExp(s[R], "g");
        var G = a++;
        s[G] = "^\\s*(" + s[E] + ")\\s+-\\s+(" + s[E] + ")\\s*$";
        var W = a++;
        s[W] = "^\\s*(" + s[j] + ")\\s+-\\s+(" + s[j] + ")\\s*$";
        var U = a++;
        s[U] = "(<|>)?=?\\s*\\*";
        for (var K = 0; K < 35; K++) r2(K, s[K]), i[K] || (i[K] = new RegExp(s[K]));
        function q(e3, t12) {
          if (t12 && "object" == typeof t12 || (t12 = { loose: !!t12, includePrerelease: false }), e3 instanceof Y) return e3;
          if ("string" != typeof e3) return null;
          if (e3.length > n) return null;
          if (!(t12.loose ? i[S] : i[b]).test(e3)) return null;
          try {
            return new Y(e3, t12);
          } catch (e4) {
            return null;
          }
        }
        __name(q, "q");
        function Y(e3, t12) {
          if (t12 && "object" == typeof t12 || (t12 = { loose: !!t12, includePrerelease: false }), e3 instanceof Y) {
            if (e3.loose === t12.loose) return e3;
            e3 = e3.version;
          } else if ("string" != typeof e3) throw new TypeError("Invalid Version: " + e3);
          if (e3.length > n) throw new TypeError("version is longer than " + n + " characters");
          if (!(this instanceof Y)) return new Y(e3, t12);
          r2("SemVer", e3, t12), this.options = t12, this.loose = !!t12.loose;
          var s2 = e3.trim().match(t12.loose ? i[S] : i[b]);
          if (!s2) throw new TypeError("Invalid Version: " + e3);
          if (this.raw = e3, this.major = +s2[1], this.minor = +s2[2], this.patch = +s2[3], this.major > o || this.major < 0) throw new TypeError("Invalid major version");
          if (this.minor > o || this.minor < 0) throw new TypeError("Invalid minor version");
          if (this.patch > o || this.patch < 0) throw new TypeError("Invalid patch version");
          s2[4] ? this.prerelease = s2[4].split(".").map(function(e4) {
            if (/^[0-9]+$/.test(e4)) {
              var t13 = +e4;
              if (t13 >= 0 && t13 < o) return t13;
            }
            return e4;
          }) : this.prerelease = [], this.build = s2[5] ? s2[5].split(".") : [], this.format();
        }
        __name(Y, "Y");
        t11.parse = q, t11.valid = function(e3, t12) {
          var r3 = q(e3, t12);
          return r3 ? r3.version : null;
        }, t11.clean = function(e3, t12) {
          var r3 = q(e3.trim().replace(/^[=v]+/, ""), t12);
          return r3 ? r3.version : null;
        }, t11.SemVer = Y, Y.prototype.format = function() {
          return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
        }, Y.prototype.toString = function() {
          return this.version;
        }, Y.prototype.compare = function(e3) {
          return r2("SemVer.compare", this.version, this.options, e3), e3 instanceof Y || (e3 = new Y(e3, this.options)), this.compareMain(e3) || this.comparePre(e3);
        }, Y.prototype.compareMain = function(e3) {
          return e3 instanceof Y || (e3 = new Y(e3, this.options)), J(this.major, e3.major) || J(this.minor, e3.minor) || J(this.patch, e3.patch);
        }, Y.prototype.comparePre = function(e3) {
          if (e3 instanceof Y || (e3 = new Y(e3, this.options)), this.prerelease.length && !e3.prerelease.length) return -1;
          if (!this.prerelease.length && e3.prerelease.length) return 1;
          if (!this.prerelease.length && !e3.prerelease.length) return 0;
          var t12 = 0;
          do {
            var n2 = this.prerelease[t12], o2 = e3.prerelease[t12];
            if (r2("prerelease compare", t12, n2, o2), void 0 === n2 && void 0 === o2) return 0;
            if (void 0 === o2) return 1;
            if (void 0 === n2) return -1;
            if (n2 !== o2) return J(n2, o2);
          } while (++t12);
        }, Y.prototype.inc = function(e3, t12) {
          switch (e3) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t12);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t12);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", t12), this.inc("pre", t12);
              break;
            case "prerelease":
              0 === this.prerelease.length && this.inc("patch", t12), this.inc("pre", t12);
              break;
            case "major":
              0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              0 === this.prerelease.length && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (0 === this.prerelease.length) this.prerelease = [0];
              else {
                for (var r3 = this.prerelease.length; --r3 >= 0; ) "number" == typeof this.prerelease[r3] && (this.prerelease[r3]++, r3 = -2);
                -1 === r3 && this.prerelease.push(0);
              }
              t12 && (this.prerelease[0] === t12 ? isNaN(this.prerelease[1]) && (this.prerelease = [t12, 0]) : this.prerelease = [t12, 0]);
              break;
            default:
              throw new Error("invalid increment argument: " + e3);
          }
          return this.format(), this.raw = this.version, this;
        }, t11.inc = function(e3, t12, r3, n2) {
          "string" == typeof r3 && (n2 = r3, r3 = void 0);
          try {
            return new Y(e3, r3).inc(t12, n2).version;
          } catch (e4) {
            return null;
          }
        }, t11.diff = function(e3, t12) {
          if (Z(e3, t12)) return null;
          var r3 = q(e3), n2 = q(t12);
          if (r3.prerelease.length || n2.prerelease.length) {
            for (var o2 in r3) if (("major" === o2 || "minor" === o2 || "patch" === o2) && r3[o2] !== n2[o2]) return "pre" + o2;
            return "prerelease";
          }
          for (var o2 in r3) if (("major" === o2 || "minor" === o2 || "patch" === o2) && r3[o2] !== n2[o2]) return o2;
        }, t11.compareIdentifiers = J;
        var H = /^[0-9]+$/;
        function J(e3, t12) {
          var r3 = H.test(e3), n2 = H.test(t12);
          return r3 && n2 && (e3 = +e3, t12 = +t12), r3 && !n2 ? -1 : n2 && !r3 ? 1 : e3 < t12 ? -1 : e3 > t12 ? 1 : 0;
        }
        __name(J, "J");
        function z(e3, t12, r3) {
          return new Y(e3, r3).compare(new Y(t12, r3));
        }
        __name(z, "z");
        function Q(e3, t12, r3) {
          return z(e3, t12, r3) > 0;
        }
        __name(Q, "Q");
        function X(e3, t12, r3) {
          return z(e3, t12, r3) < 0;
        }
        __name(X, "X");
        function Z(e3, t12, r3) {
          return 0 === z(e3, t12, r3);
        }
        __name(Z, "Z");
        function ee(e3, t12, r3) {
          return 0 !== z(e3, t12, r3);
        }
        __name(ee, "ee");
        function te(e3, t12, r3) {
          return z(e3, t12, r3) >= 0;
        }
        __name(te, "te");
        function re(e3, t12, r3) {
          return z(e3, t12, r3) <= 0;
        }
        __name(re, "re");
        function ne(e3, t12, r3, n2) {
          var o2;
          switch (t12) {
            case "===":
              "object" == typeof e3 && (e3 = e3.version), "object" == typeof r3 && (r3 = r3.version), o2 = e3 === r3;
              break;
            case "!==":
              "object" == typeof e3 && (e3 = e3.version), "object" == typeof r3 && (r3 = r3.version), o2 = e3 !== r3;
              break;
            case "":
            case "=":
            case "==":
              o2 = Z(e3, r3, n2);
              break;
            case "!=":
              o2 = ee(e3, r3, n2);
              break;
            case ">":
              o2 = Q(e3, r3, n2);
              break;
            case ">=":
              o2 = te(e3, r3, n2);
              break;
            case "<":
              o2 = X(e3, r3, n2);
              break;
            case "<=":
              o2 = re(e3, r3, n2);
              break;
            default:
              throw new TypeError("Invalid operator: " + t12);
          }
          return o2;
        }
        __name(ne, "ne");
        function oe(e3, t12) {
          if (t12 && "object" == typeof t12 || (t12 = { loose: !!t12, includePrerelease: false }), e3 instanceof oe) {
            if (e3.loose === !!t12.loose) return e3;
            e3 = e3.value;
          }
          if (!(this instanceof oe)) return new oe(e3, t12);
          r2("comparator", e3, t12), this.options = t12, this.loose = !!t12.loose, this.parse(e3), this.semver === ie ? this.value = "" : this.value = this.operator + this.semver.version, r2("comp", this);
        }
        __name(oe, "oe");
        t11.rcompareIdentifiers = function(e3, t12) {
          return J(t12, e3);
        }, t11.major = function(e3, t12) {
          return new Y(e3, t12).major;
        }, t11.minor = function(e3, t12) {
          return new Y(e3, t12).minor;
        }, t11.patch = function(e3, t12) {
          return new Y(e3, t12).patch;
        }, t11.compare = z, t11.compareLoose = function(e3, t12) {
          return z(e3, t12, true);
        }, t11.rcompare = function(e3, t12, r3) {
          return z(t12, e3, r3);
        }, t11.sort = function(e3, r3) {
          return e3.sort(function(e4, n2) {
            return t11.compare(e4, n2, r3);
          });
        }, t11.rsort = function(e3, r3) {
          return e3.sort(function(e4, n2) {
            return t11.rcompare(e4, n2, r3);
          });
        }, t11.gt = Q, t11.lt = X, t11.eq = Z, t11.neq = ee, t11.gte = te, t11.lte = re, t11.cmp = ne, t11.Comparator = oe;
        var ie = {};
        function se(e3, t12) {
          if (t12 && "object" == typeof t12 || (t12 = { loose: !!t12, includePrerelease: false }), e3 instanceof se) return e3.loose === !!t12.loose && e3.includePrerelease === !!t12.includePrerelease ? e3 : new se(e3.raw, t12);
          if (e3 instanceof oe) return new se(e3.value, t12);
          if (!(this instanceof se)) return new se(e3, t12);
          if (this.options = t12, this.loose = !!t12.loose, this.includePrerelease = !!t12.includePrerelease, this.raw = e3, this.set = e3.split(/\s*\|\|\s*/).map(function(e4) {
            return this.parseRange(e4.trim());
          }, this).filter(function(e4) {
            return e4.length;
          }), !this.set.length) throw new TypeError("Invalid SemVer Range: " + e3);
          this.format();
        }
        __name(se, "se");
        function ae(e3) {
          return !e3 || "x" === e3.toLowerCase() || "*" === e3;
        }
        __name(ae, "ae");
        function ce(e3, t12, r3, n2, o2, i2, s2, a2, c2, u2, l2, f2, p2) {
          return ((t12 = ae(r3) ? "" : ae(n2) ? ">=" + r3 + ".0.0" : ae(o2) ? ">=" + r3 + "." + n2 + ".0" : ">=" + t12) + " " + (a2 = ae(c2) ? "" : ae(u2) ? "<" + (+c2 + 1) + ".0.0" : ae(l2) ? "<" + c2 + "." + (+u2 + 1) + ".0" : f2 ? "<=" + c2 + "." + u2 + "." + l2 + "-" + f2 : "<=" + a2)).trim();
        }
        __name(ce, "ce");
        function ue(e3, t12, n2) {
          for (var o2 = 0; o2 < e3.length; o2++) if (!e3[o2].test(t12)) return false;
          if (n2 || (n2 = {}), t12.prerelease.length && !n2.includePrerelease) {
            for (o2 = 0; o2 < e3.length; o2++) if (r2(e3[o2].semver), e3[o2].semver !== ie && e3[o2].semver.prerelease.length > 0) {
              var i2 = e3[o2].semver;
              if (i2.major === t12.major && i2.minor === t12.minor && i2.patch === t12.patch) return true;
            }
            return false;
          }
          return true;
        }
        __name(ue, "ue");
        function le(e3, t12, r3) {
          try {
            t12 = new se(t12, r3);
          } catch (e4) {
            return false;
          }
          return t12.test(e3);
        }
        __name(le, "le");
        function fe(e3, t12, r3, n2) {
          var o2, i2, s2, a2, c2;
          switch (e3 = new Y(e3, n2), t12 = new se(t12, n2), r3) {
            case ">":
              o2 = Q, i2 = re, s2 = X, a2 = ">", c2 = ">=";
              break;
            case "<":
              o2 = X, i2 = te, s2 = Q, a2 = "<", c2 = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (le(e3, t12, n2)) return false;
          for (var u2 = 0; u2 < t12.set.length; ++u2) {
            var l2 = t12.set[u2], f2 = null, p2 = null;
            if (l2.forEach(function(e4) {
              e4.semver === ie && (e4 = new oe(">=0.0.0")), f2 = f2 || e4, p2 = p2 || e4, o2(e4.semver, f2.semver, n2) ? f2 = e4 : s2(e4.semver, p2.semver, n2) && (p2 = e4);
            }), f2.operator === a2 || f2.operator === c2) return false;
            if ((!p2.operator || p2.operator === a2) && i2(e3, p2.semver)) return false;
            if (p2.operator === c2 && s2(e3, p2.semver)) return false;
          }
          return true;
        }
        __name(fe, "fe");
        oe.prototype.parse = function(e3) {
          var t12 = this.options.loose ? i[$] : i[B], r3 = e3.match(t12);
          if (!r3) throw new TypeError("Invalid comparator: " + e3);
          this.operator = r3[1], "=" === this.operator && (this.operator = ""), r3[2] ? this.semver = new Y(r3[2], this.options.loose) : this.semver = ie;
        }, oe.prototype.toString = function() {
          return this.value;
        }, oe.prototype.test = function(e3) {
          return r2("Comparator.test", e3, this.options.loose), this.semver === ie || ("string" == typeof e3 && (e3 = new Y(e3, this.options)), ne(e3, this.operator, this.semver, this.options));
        }, oe.prototype.intersects = function(e3, t12) {
          if (!(e3 instanceof oe)) throw new TypeError("a Comparator is required");
          var r3;
          if (t12 && "object" == typeof t12 || (t12 = { loose: !!t12, includePrerelease: false }), "" === this.operator) return r3 = new se(e3.value, t12), le(this.value, r3, t12);
          if ("" === e3.operator) return r3 = new se(this.value, t12), le(e3.semver, r3, t12);
          var n2 = !(">=" !== this.operator && ">" !== this.operator || ">=" !== e3.operator && ">" !== e3.operator), o2 = !("<=" !== this.operator && "<" !== this.operator || "<=" !== e3.operator && "<" !== e3.operator), i2 = this.semver.version === e3.semver.version, s2 = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== e3.operator && "<=" !== e3.operator), a2 = ne(this.semver, "<", e3.semver, t12) && (">=" === this.operator || ">" === this.operator) && ("<=" === e3.operator || "<" === e3.operator), c2 = ne(this.semver, ">", e3.semver, t12) && ("<=" === this.operator || "<" === this.operator) && (">=" === e3.operator || ">" === e3.operator);
          return n2 || o2 || i2 && s2 || a2 || c2;
        }, t11.Range = se, se.prototype.format = function() {
          return this.range = this.set.map(function(e3) {
            return e3.join(" ").trim();
          }).join("||").trim(), this.range;
        }, se.prototype.toString = function() {
          return this.range;
        }, se.prototype.parseRange = function(e3) {
          var t12 = this.options.loose;
          e3 = e3.trim();
          var n2 = t12 ? i[W] : i[G];
          e3 = e3.replace(n2, ce), r2("hyphen replace", e3), e3 = e3.replace(i[R], "$1$2$3"), r2("comparator trim", e3, i[R]), e3 = (e3 = (e3 = e3.replace(i[F], "$1~")).replace(i[T], "$1^")).split(/\s+/).join(" ");
          var o2 = t12 ? i[$] : i[B], s2 = e3.split(" ").map(function(e4) {
            return function(e5, t13) {
              return r2("comp", e5, t13), e5 = function(e6, t14) {
                return e6.trim().split(/\s+/).map(function(e7) {
                  return function(e8, t15) {
                    r2("caret", e8, t15), t15 && "object" == typeof t15 || (t15 = { loose: !!t15, includePrerelease: false });
                    var n3 = t15.loose ? i[L] : i[D];
                    return e8.replace(n3, function(t16, n4, o3, i2, s3) {
                      var a2;
                      return r2("caret", e8, t16, n4, o3, i2, s3), ae(n4) ? a2 = "" : ae(o3) ? a2 = ">=" + n4 + ".0.0 <" + (+n4 + 1) + ".0.0" : ae(i2) ? a2 = "0" === n4 ? ">=" + n4 + "." + o3 + ".0 <" + n4 + "." + (+o3 + 1) + ".0" : ">=" + n4 + "." + o3 + ".0 <" + (+n4 + 1) + ".0.0" : s3 ? (r2("replaceCaret pr", s3), "-" !== s3.charAt(0) && (s3 = "-" + s3), a2 = "0" === n4 ? "0" === o3 ? ">=" + n4 + "." + o3 + "." + i2 + s3 + " <" + n4 + "." + o3 + "." + (+i2 + 1) : ">=" + n4 + "." + o3 + "." + i2 + s3 + " <" + n4 + "." + (+o3 + 1) + ".0" : ">=" + n4 + "." + o3 + "." + i2 + s3 + " <" + (+n4 + 1) + ".0.0") : (r2("no pr"), a2 = "0" === n4 ? "0" === o3 ? ">=" + n4 + "." + o3 + "." + i2 + " <" + n4 + "." + o3 + "." + (+i2 + 1) : ">=" + n4 + "." + o3 + "." + i2 + " <" + n4 + "." + (+o3 + 1) + ".0" : ">=" + n4 + "." + o3 + "." + i2 + " <" + (+n4 + 1) + ".0.0"), r2("caret return", a2), a2;
                    });
                  }(e7, t14);
                }).join(" ");
              }(e5, t13), r2("caret", e5), e5 = function(e6, t14) {
                return e6.trim().split(/\s+/).map(function(e7) {
                  return function(e8, t15) {
                    t15 && "object" == typeof t15 || (t15 = { loose: !!t15, includePrerelease: false });
                    var n3 = t15.loose ? i[M] : i[C];
                    return e8.replace(n3, function(t16, n4, o3, i2, s3) {
                      var a2;
                      return r2("tilde", e8, t16, n4, o3, i2, s3), ae(n4) ? a2 = "" : ae(o3) ? a2 = ">=" + n4 + ".0.0 <" + (+n4 + 1) + ".0.0" : ae(i2) ? a2 = ">=" + n4 + "." + o3 + ".0 <" + n4 + "." + (+o3 + 1) + ".0" : s3 ? (r2("replaceTilde pr", s3), "-" !== s3.charAt(0) && (s3 = "-" + s3), a2 = ">=" + n4 + "." + o3 + "." + i2 + s3 + " <" + n4 + "." + (+o3 + 1) + ".0") : a2 = ">=" + n4 + "." + o3 + "." + i2 + " <" + n4 + "." + (+o3 + 1) + ".0", r2("tilde return", a2), a2;
                    });
                  }(e7, t14);
                }).join(" ");
              }(e5, t13), r2("tildes", e5), e5 = function(e6, t14) {
                return r2("replaceXRanges", e6, t14), e6.split(/\s+/).map(function(e7) {
                  return function(e8, t15) {
                    e8 = e8.trim(), t15 && "object" == typeof t15 || (t15 = { loose: !!t15, includePrerelease: false });
                    var n3 = t15.loose ? i[A] : i[_];
                    return e8.replace(n3, function(t16, n4, o3, i2, s3, a2) {
                      r2("xRange", e8, t16, n4, o3, i2, s3, a2);
                      var c2 = ae(o3), u2 = c2 || ae(i2), l2 = u2 || ae(s3);
                      return "=" === n4 && l2 && (n4 = ""), c2 ? t16 = ">" === n4 || "<" === n4 ? "<0.0.0" : "*" : n4 && l2 ? (u2 && (i2 = 0), l2 && (s3 = 0), ">" === n4 ? (n4 = ">=", u2 ? (o3 = +o3 + 1, i2 = 0, s3 = 0) : l2 && (i2 = +i2 + 1, s3 = 0)) : "<=" === n4 && (n4 = "<", u2 ? o3 = +o3 + 1 : i2 = +i2 + 1), t16 = n4 + o3 + "." + i2 + "." + s3) : u2 ? t16 = ">=" + o3 + ".0.0 <" + (+o3 + 1) + ".0.0" : l2 && (t16 = ">=" + o3 + "." + i2 + ".0 <" + o3 + "." + (+i2 + 1) + ".0"), r2("xRange return", t16), t16;
                    });
                  }(e7, t14);
                }).join(" ");
              }(e5, t13), r2("xrange", e5), e5 = function(e6, t14) {
                return r2("replaceStars", e6, t14), e6.trim().replace(i[U], "");
              }(e5, t13), r2("stars", e5), e5;
            }(e4, this.options);
          }, this).join(" ").split(/\s+/);
          return this.options.loose && (s2 = s2.filter(function(e4) {
            return !!e4.match(o2);
          })), s2.map(function(e4) {
            return new oe(e4, this.options);
          }, this);
        }, se.prototype.intersects = function(e3, t12) {
          if (!(e3 instanceof se)) throw new TypeError("a Range is required");
          return this.set.some(function(r3) {
            return r3.every(function(r4) {
              return e3.set.some(function(e4) {
                return e4.every(function(e5) {
                  return r4.intersects(e5, t12);
                });
              });
            });
          });
        }, t11.toComparators = function(e3, t12) {
          return new se(e3, t12).set.map(function(e4) {
            return e4.map(function(e5) {
              return e5.value;
            }).join(" ").trim().split(" ");
          });
        }, se.prototype.test = function(e3) {
          if (!e3) return false;
          "string" == typeof e3 && (e3 = new Y(e3, this.options));
          for (var t12 = 0; t12 < this.set.length; t12++) if (ue(this.set[t12], e3, this.options)) return true;
          return false;
        }, t11.satisfies = le, t11.maxSatisfying = function(e3, t12, r3) {
          var n2 = null, o2 = null;
          try {
            var i2 = new se(t12, r3);
          } catch (e4) {
            return null;
          }
          return e3.forEach(function(e4) {
            i2.test(e4) && (n2 && -1 !== o2.compare(e4) || (o2 = new Y(n2 = e4, r3)));
          }), n2;
        }, t11.minSatisfying = function(e3, t12, r3) {
          var n2 = null, o2 = null;
          try {
            var i2 = new se(t12, r3);
          } catch (e4) {
            return null;
          }
          return e3.forEach(function(e4) {
            i2.test(e4) && (n2 && 1 !== o2.compare(e4) || (o2 = new Y(n2 = e4, r3)));
          }), n2;
        }, t11.validRange = function(e3, t12) {
          try {
            return new se(e3, t12).range || "*";
          } catch (e4) {
            return null;
          }
        }, t11.ltr = function(e3, t12, r3) {
          return fe(e3, t12, "<", r3);
        }, t11.gtr = function(e3, t12, r3) {
          return fe(e3, t12, ">", r3);
        }, t11.outside = fe, t11.prerelease = function(e3, t12) {
          var r3 = q(e3, t12);
          return r3 && r3.prerelease.length ? r3.prerelease : null;
        }, t11.intersects = function(e3, t12, r3) {
          return e3 = new se(e3, r3), t12 = new se(t12, r3), e3.intersects(t12);
        }, t11.coerce = function(e3) {
          if (e3 instanceof Y) return e3;
          if ("string" != typeof e3) return null;
          var t12 = e3.match(i[k]);
          return null == t12 ? null : q((t12[1] || "0") + "." + (t12[2] || "0") + "." + (t12[3] || "0"));
        };
      }, 6176: (e2, t11, r2) => {
        "use strict";
        var n = r2(184);
        e2.exports = function(e3) {
          var t12 = e3.match(n);
          if (!t12) return null;
          var r3 = t12[0].replace(/#! ?/, "").split(" "), o = r3[0].split("/").pop(), i = r3[1];
          return "env" === o ? i : o + (i ? " " + i : "");
        };
      }, 184: (e2) => {
        "use strict";
        e2.exports = /^#!.*/;
      }, 200: (e2, t11, r2) => {
        var n, o = r2(6608), i = r2(6132), s = r2(467);
        function a() {
          l && (l = false, i.forEach(function(e3) {
            try {
              process.removeListener(e3, u[e3]);
            } catch (e4) {
            }
          }), process.emit = d, process.reallyExit = p, n.count -= 1);
        }
        __name(a, "a");
        function c(e3, t12, r3) {
          n.emitted[e3] || (n.emitted[e3] = true, n.emit(e3, t12, r3));
        }
        __name(c, "c");
        "function" != typeof s && (s = s.EventEmitter), process.__signal_exit_emitter__ ? n = process.__signal_exit_emitter__ : ((n = process.__signal_exit_emitter__ = new s()).count = 0, n.emitted = {}), n.infinite || (n.setMaxListeners(1 / 0), n.infinite = true), e2.exports = function(e3, t12) {
          o.equal(typeof e3, "function", "a callback must be provided for exit handler"), false === l && f();
          var r3 = "exit";
          return t12 && t12.alwaysLast && (r3 = "afterexit"), n.on(r3, e3), function() {
            n.removeListener(r3, e3), 0 === n.listeners("exit").length && 0 === n.listeners("afterexit").length && a();
          };
        }, e2.exports.unload = a;
        var u = {};
        i.forEach(function(e3) {
          u[e3] = function() {
            process.listeners(e3).length === n.count && (a(), c("exit", null, e3), c("afterexit", null, e3), process.kill(process.pid, e3));
          };
        }), e2.exports.signals = function() {
          return i;
        }, e2.exports.load = f;
        var l = false;
        function f() {
          l || (l = true, n.count += 1, i = i.filter(function(e3) {
            try {
              return process.on(e3, u[e3]), true;
            } catch (e4) {
              return false;
            }
          }), process.emit = m, process.reallyExit = h);
        }
        __name(f, "f");
        var p = process.reallyExit;
        function h(e3) {
          process.exitCode = e3 || 0, c("exit", process.exitCode, null), c("afterexit", process.exitCode, null), p.call(process, process.exitCode);
        }
        __name(h, "h");
        var d = process.emit;
        function m(e3, t12) {
          if ("exit" === e3) {
            void 0 !== t12 && (process.exitCode = t12);
            var r3 = d.apply(this, arguments);
            return c("exit", process.exitCode, null), c("afterexit", process.exitCode, null), r3;
          }
          return d.apply(this, arguments);
        }
        __name(m, "m");
      }, 6132: (e2) => {
        e2.exports = ["SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM"], "win32" !== process.platform && e2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT"), "linux" === process.platform && e2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
      }, 9860: (e2) => {
        "use strict";
        e2.exports = function(e3) {
          var t11 = "string" == typeof e3 ? "\n" : "\n".charCodeAt(), r2 = "string" == typeof e3 ? "\r" : "\r".charCodeAt();
          return e3[e3.length - 1] === t11 && (e3 = e3.slice(0, e3.length - 1)), e3[e3.length - 1] === r2 && (e3 = e3.slice(0, e3.length - 1)), e3;
        };
      }, 8460: (e2, t11, r2) => {
        e2.exports = u, u.sync = function(e3, t12) {
          for (var r3 = c(e3, t12 = t12 || {}), n2 = r3.env, i2 = r3.ext, u2 = r3.extExe, l = [], f = 0, p = n2.length; f < p; f++) {
            var h = n2[f];
            '"' === h.charAt(0) && '"' === h.slice(-1) && (h = h.slice(1, -1));
            var d = o.join(h, e3);
            !h && /^\.[\\\/]/.test(e3) && (d = e3.slice(0, 2) + d);
            for (var m = 0, g = i2.length; m < g; m++) {
              var v = d + i2[m];
              try {
                if (s.sync(v, { pathExt: u2 })) {
                  if (!t12.all) return v;
                  l.push(v);
                }
              } catch (e4) {
              }
            }
          }
          if (t12.all && l.length) return l;
          if (t12.nothrow) return null;
          throw a(e3);
        };
        var n = "win32" === process.platform || "cygwin" === process.env.OSTYPE || "msys" === process.env.OSTYPE, o = r2(7072), i = n ? ";" : ":", s = r2(9268);
        function a(e3) {
          var t12 = new Error("not found: " + e3);
          return t12.code = "ENOENT", t12;
        }
        __name(a, "a");
        function c(e3, t12) {
          var r3 = t12.colon || i, o2 = t12.path || process.env.PATH || "", s2 = [""];
          o2 = o2.split(r3);
          var a2 = "";
          return n && (o2.unshift(process.cwd()), s2 = (a2 = t12.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM").split(r3), -1 !== e3.indexOf(".") && "" !== s2[0] && s2.unshift("")), (e3.match(/\//) || n && e3.match(/\\/)) && (o2 = [""]), { env: o2, ext: s2, extExe: a2 };
        }
        __name(c, "c");
        function u(e3, t12, r3) {
          "function" == typeof t12 && (r3 = t12, t12 = {});
          var n2 = c(e3, t12), i2 = n2.env, u2 = n2.ext, l = n2.extExe, f = [];
          !(/* @__PURE__ */ __name(function n3(c2, p) {
            if (c2 === p) return t12.all && f.length ? r3(null, f) : r3(a(e3));
            var h = i2[c2];
            '"' === h.charAt(0) && '"' === h.slice(-1) && (h = h.slice(1, -1));
            var d = o.join(h, e3);
            !h && /^\.[\\\/]/.test(e3) && (d = e3.slice(0, 2) + d), (/* @__PURE__ */ __name(function e4(o2, i3) {
              if (o2 === i3) return n3(c2 + 1, p);
              var a2 = u2[o2];
              s(d + a2, { pathExt: l }, function(n4, s2) {
                if (!n4 && s2) {
                  if (!t12.all) return r3(null, d + a2);
                  f.push(d + a2);
                }
                return e4(o2 + 1, i3);
              });
            }, "e"))(0, u2.length);
          }, "n"))(0, i2.length);
        }
        __name(u, "u");
      }, 6468: (e2, t11, r2) => {
        "use strict";
        const n = r2(8558), o = r2(8636), i = /* @__PURE__ */ new Map([["10.0", "10"], ["6.3", "8.1"], ["6.2", "8"], ["6.1", "7"], ["6.0", "Vista"], ["5.2", "Server 2003"], ["5.1", "XP"], ["5.0", "2000"], ["4.9", "ME"], ["4.1", "98"], ["4.0", "95"]]);
        e2.exports = (e3) => {
          const t12 = /\d+\.\d/.exec(e3 || n.release());
          if (e3 && !t12) throw new Error("`release` argument doesn't match `n.n`");
          const r3 = (t12 || [])[0];
          if ((!e3 || e3 === n.release()) && ["6.1", "6.2", "6.3", "10.0"].includes(r3)) {
            const e4 = ((o.sync("wmic", ["os", "get", "Caption"]).stdout || "").match(/2008|2012|2016/) || [])[0];
            if (e4) return `Server ${e4}`;
          }
          return i.get(r3);
        };
      }, 8636: (e2, t11, r2) => {
        "use strict";
        const n = r2(7072), o = r2(4368), i = r2(7468), s = r2(9860), a = r2(9584), c = r2(1392), u = r2(9068), l = r2(1548), f = r2(200), p = r2(7688), h = r2(6174);
        function d(e3, t12, r3) {
          let o2;
          return (r3 = Object.assign({ extendEnv: true, env: {} }, r3)).extendEnv && (r3.env = Object.assign({}, process.env, r3.env)), true === r3.__winShell ? (delete r3.__winShell, o2 = { command: e3, args: t12, options: r3, file: e3, original: { cmd: e3, args: t12 } }) : o2 = i._parse(e3, t12, r3), (r3 = Object.assign({ maxBuffer: 1e7, buffer: true, stripEof: true, preferLocal: true, localDir: o2.options.cwd || process.cwd(), encoding: "utf8", reject: true, cleanup: true }, o2.options)).stdio = h(r3), r3.preferLocal && (r3.env = a.env(Object.assign({}, r3, { cwd: r3.localDir }))), r3.detached && (r3.cleanup = false), "win32" === process.platform && "cmd.exe" === n.basename(o2.command) && o2.args.unshift("/q"), { cmd: o2.command, args: o2.args, opts: r3, parsed: o2 };
        }
        __name(d, "d");
        function m(e3, t12) {
          return t12 && e3.stripEof && (t12 = s(t12)), t12;
        }
        __name(m, "m");
        function g(e3, t12, r3) {
          let n2 = "/bin/sh", o2 = ["-c", t12];
          return r3 = Object.assign({}, r3), "win32" === process.platform && (r3.__winShell = true, n2 = process.env.comspec || "cmd.exe", o2 = ["/s", "/c", `"${t12}"`], r3.windowsVerbatimArguments = true), r3.shell && (n2 = r3.shell, delete r3.shell), e3(n2, o2, r3);
        }
        __name(g, "g");
        function v(e3, t12, { encoding: r3, buffer: n2, maxBuffer: o2 }) {
          if (!e3[t12]) return null;
          let i2;
          return i2 = n2 ? r3 ? u(e3[t12], { encoding: r3, maxBuffer: o2 }) : u.buffer(e3[t12], { maxBuffer: o2 }) : new Promise((r4, n3) => {
            e3[t12].once("end", r4).once("error", n3);
          }), i2.catch((e4) => {
            throw e4.stream = t12, e4.message = `${t12} ${e4.message}`, e4;
          });
        }
        __name(v, "v");
        function y(e3, t12) {
          const { stdout: r3, stderr: n2 } = e3;
          let o2 = e3.error;
          const { code: i2, signal: s2 } = e3, { parsed: a2, joinedCmd: c2 } = t12, u2 = t12.timedOut || false;
          if (!o2) {
            let e4 = "";
            Array.isArray(a2.opts.stdio) ? ("inherit" !== a2.opts.stdio[2] && (e4 += e4.length > 0 ? n2 : `
${n2}`), "inherit" !== a2.opts.stdio[1] && (e4 += `
${r3}`)) : "inherit" !== a2.opts.stdio && (e4 = `
${n2}${r3}`), o2 = new Error(`Command failed: ${c2}${e4}`), o2.code = i2 < 0 ? p(i2) : i2;
          }
          return o2.stdout = r3, o2.stderr = n2, o2.failed = true, o2.signal = s2 || null, o2.cmd = c2, o2.timedOut = u2, o2;
        }
        __name(y, "y");
        function b(e3, t12) {
          let r3 = e3;
          return Array.isArray(t12) && t12.length > 0 && (r3 += " " + t12.join(" ")), r3;
        }
        __name(b, "b");
        e2.exports = (e3, t12, r3) => {
          const n2 = d(e3, t12, r3), { encoding: s2, buffer: a2, maxBuffer: u2 } = n2.opts, p2 = b(e3, t12);
          let h2, g2;
          try {
            h2 = o.spawn(n2.cmd, n2.args, n2.opts);
          } catch (e4) {
            return Promise.reject(e4);
          }
          n2.opts.cleanup && (g2 = f(() => {
            h2.kill();
          }));
          let w = null, x = false;
          const S = /* @__PURE__ */ __name(() => {
            w && (clearTimeout(w), w = null), g2 && g2();
          }, "S");
          n2.opts.timeout > 0 && (w = setTimeout(() => {
            w = null, x = true, h2.kill(n2.opts.killSignal);
          }, n2.opts.timeout));
          const P = new Promise((e4) => {
            h2.on("exit", (t13, r4) => {
              S(), e4({ code: t13, signal: r4 });
            }), h2.on("error", (t13) => {
              S(), e4({ error: t13 });
            }), h2.stdin && h2.stdin.on("error", (t13) => {
              S(), e4({ error: t13 });
            });
          });
          function O() {
            h2.stdout && h2.stdout.destroy(), h2.stderr && h2.stderr.destroy();
          }
          __name(O, "O");
          const I = /* @__PURE__ */ __name(() => l(Promise.all([P, v(h2, "stdout", { encoding: s2, buffer: a2, maxBuffer: u2 }), v(h2, "stderr", { encoding: s2, buffer: a2, maxBuffer: u2 })]).then((e4) => {
            const t13 = e4[0];
            if (t13.stdout = e4[1], t13.stderr = e4[2], t13.error || 0 !== t13.code || null !== t13.signal) {
              const e5 = y(t13, { joinedCmd: p2, parsed: n2, timedOut: x });
              if (e5.killed = e5.killed || h2.killed, !n2.opts.reject) return e5;
              throw e5;
            }
            return { stdout: m(n2.opts, t13.stdout), stderr: m(n2.opts, t13.stderr), code: 0, failed: false, killed: false, signal: null, cmd: p2, timedOut: false };
          }), O), "I");
          return i._enoent.hookChildProcess(h2, n2.parsed), function(e4, t13) {
            null != t13 && (c(t13) ? t13.pipe(e4.stdin) : e4.stdin.end(t13));
          }(h2, n2.opts.input), h2.then = (e4, t13) => I().then(e4, t13), h2.catch = (e4) => I().catch(e4), h2;
        }, e2.exports.stdout = (...t12) => e2.exports(...t12).then((e3) => e3.stdout), e2.exports.stderr = (...t12) => e2.exports(...t12).then((e3) => e3.stderr), e2.exports.shell = (t12, r3) => g(e2.exports, t12, r3), e2.exports.sync = (e3, t12, r3) => {
          const n2 = d(e3, t12, r3), i2 = b(e3, t12);
          if (c(n2.opts.input)) throw new TypeError("The `input` option cannot be a stream in sync mode");
          const s2 = o.spawnSync(n2.cmd, n2.args, n2.opts);
          if (s2.code = s2.status, s2.error || 0 !== s2.status || null !== s2.signal) {
            const e4 = y(s2, { joinedCmd: i2, parsed: n2 });
            if (!n2.opts.reject) return e4;
            throw e4;
          }
          return { stdout: m(n2.opts, s2.stdout), stderr: m(n2.opts, s2.stderr), code: 0, failed: false, signal: null, cmd: i2, timedOut: false };
        }, e2.exports.shellSync = (t12, r3) => g(e2.exports.sync, t12, r3);
      }, 7688: (e2, t11, r2) => {
        "use strict";
        const n = r2(970);
        let o;
        if ("function" == typeof n.getSystemErrorName) e2.exports = n.getSystemErrorName;
        else {
          try {
            if (o = process.binding("uv"), "function" != typeof o.errname) throw new TypeError("uv.errname is not a function");
          } catch (e3) {
            console.error("execa/lib/errname: unable to establish process.binding('uv')", e3), o = null;
          }
          e2.exports = (e3) => i(o, e3);
        }
        function i(e3, t12) {
          if (e3) return e3.errname(t12);
          if (!(t12 < 0)) throw new Error("err >= 0");
          return `Unknown system error ${t12}`;
        }
        __name(i, "i");
        e2.exports.__test__ = i;
      }, 6174: (e2) => {
        "use strict";
        const t11 = ["stdin", "stdout", "stderr"];
        e2.exports = (e3) => {
          if (!e3) return null;
          if (e3.stdio && ((e4) => t11.some((t12) => Boolean(e4[t12])))(e3)) throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${t11.map((e4) => `\`${e4}\``).join(", ")}`);
          if ("string" == typeof e3.stdio) return e3.stdio;
          const r2 = e3.stdio || [];
          if (!Array.isArray(r2)) throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof r2}\``);
          const n = [], o = Math.max(r2.length, t11.length);
          for (let i = 0; i < o; i++) {
            let o2 = null;
            void 0 !== r2[i] ? o2 = r2[i] : void 0 !== e3[t11[i]] && (o2 = e3[t11[i]]), n[i] = o2;
          }
          return n;
        };
      }, 656: (e2, t11, r2) => {
        "use strict";
        const { PassThrough: n } = r2(8378);
        e2.exports = (e3) => {
          e3 = Object.assign({}, e3);
          const { array: t12 } = e3;
          let { encoding: r3 } = e3;
          const o = "buffer" === r3;
          let i = false;
          t12 ? i = !(r3 || o) : r3 = r3 || "utf8", o && (r3 = null);
          let s = 0;
          const a = [], c = new n({ objectMode: i });
          return r3 && c.setEncoding(r3), c.on("data", (e4) => {
            a.push(e4), i ? s = a.length : s += e4.length;
          }), c.getBufferedValue = () => t12 ? a : o ? Buffer.concat(a, s) : a.join(""), c.getBufferedLength = () => s, c;
        };
      }, 9068: (e2, t11, r2) => {
        "use strict";
        const n = r2(8984), o = r2(656);
        class i extends Error {
          static {
            __name(this, "i");
          }
          constructor() {
            super("maxBuffer exceeded"), this.name = "MaxBufferError";
          }
        }
        function s(e3, t12) {
          if (!e3) return Promise.reject(new Error("Expected a stream"));
          t12 = Object.assign({ maxBuffer: 1 / 0 }, t12);
          const { maxBuffer: r3 } = t12;
          let s2;
          return new Promise((a, c) => {
            const u = /* @__PURE__ */ __name((e4) => {
              e4 && (e4.bufferedData = s2.getBufferedValue()), c(e4);
            }, "u");
            s2 = n(e3, o(t12), (e4) => {
              e4 ? u(e4) : a();
            }), s2.on("data", () => {
              s2.getBufferedLength() > r3 && u(new i());
            });
          }).then(() => s2.getBufferedValue());
        }
        __name(s, "s");
        e2.exports = s, e2.exports.buffer = (e3, t12) => s(e3, Object.assign({}, t12, { encoding: "buffer" })), e2.exports.array = (e3, t12) => s(e3, Object.assign({}, t12, { array: true })), e2.exports.MaxBufferError = i;
      }, 2680: (e2) => {
        e2.exports = /* @__PURE__ */ __name(function e3(t11, r2) {
          if (t11 && r2) return e3(t11)(r2);
          if ("function" != typeof t11) throw new TypeError("need wrapper function");
          return Object.keys(t11).forEach(function(e4) {
            n[e4] = t11[e4];
          }), n;
          function n() {
            for (var e4 = new Array(arguments.length), r3 = 0; r3 < e4.length; r3++) e4[r3] = arguments[r3];
            var n2 = t11.apply(this, e4), o = e4[e4.length - 1];
            return "function" == typeof n2 && n2 !== o && Object.keys(o).forEach(function(e5) {
              n2[e5] = o[e5];
            }), n2;
          }
          __name(n, "n");
        }, "e");
      }, 4824: (e2) => {
        "use strict";
        function t11(e3) {
          return e3;
        }
        __name(t11, "t");
        e2.exports = { date: t11, error: t11, symbol: t11, string: t11, number: t11, boolean: t11, null: t11, undefined: t11 };
      }, 324: (e2, t11, r2) => {
        "use strict";
        var n = r2(3648), o = r2(4616), i = r2(4824);
        function s(e3, t12) {
          return void 0 === e3 ? t12 : e3;
        }
        __name(s, "s");
        e2.exports = function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          return { indent: s(e3.indent, " "), prefix: s(e3.prefix, "\n"), postfix: s(e3.postfix, ""), errorToString: e3.errorToString || n, dateToString: e3.dateToString || o, colors: Object.assign({}, i, e3.colors) };
        };
      }, 4616: (e2) => {
        "use strict";
        e2.exports = function(e3) {
          return `new Date(${Date.prototype.toISOString.call(e3)})`;
        };
      }, 3648: (e2) => {
        "use strict";
        e2.exports = function(e3) {
          return Error.prototype.toString.call(e3);
        };
      }, 9411: (e2) => {
        "use strict";
        e2.exports = function() {
          for (var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "  ", r2 = "", n = 0; n < e3; n += 1) r2 += t11;
          return r2;
        };
      }, 6232: (e2, t11, r2) => {
        "use strict";
        var n = r2(7344), o = r2(324), i = r2(9411), s = ["object", "array"];
        e2.exports = function(e3, t12) {
          var r3 = o(t12), a = r3.colors, c = r3.prefix, u = r3.postfix, l = r3.dateToString, f = r3.errorToString, p = r3.indent, h = /* @__PURE__ */ new Map();
          function d(e4) {
            var t13 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, r4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            if (0 === Object.keys(e4).length) return " {}";
            var o2 = "\n", a2 = i(t13, p);
            return Object.keys(e4).forEach(function(c2) {
              var u2 = e4[c2], l2 = n(u2), f2 = i(r4, "  "), p2 = -1 !== s.indexOf(l2) ? "" : " ", h2 = v(u2) ? " [Circular]" : g(l2, u2, t13 + 1, r4);
              o2 += `${f2}${a2}${c2}:${p2}${h2}
`;
            }), o2.substring(0, o2.length - 1);
          }
          __name(d, "d");
          function m(e4) {
            var t13 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, r4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            if (0 === e4.length) return " []";
            var o2 = "\n", s2 = i(t13, p);
            return e4.forEach(function(e5) {
              var a2 = n(e5), c2 = i(r4, "  "), u2 = v(e5) ? "[Circular]" : g(a2, e5, t13, r4 + 1).toString().trimLeft();
              o2 += `${c2}${s2}- ${u2}
`;
            }), o2.substring(0, o2.length - 1);
          }
          __name(m, "m");
          function g(e4, t13, r4, n2) {
            switch (e4) {
              case "array":
                return m(t13, r4, n2);
              case "object":
                return d(t13, r4, n2);
              case "string":
                return a.string(t13);
              case "symbol":
                return a.symbol(t13.toString());
              case "number":
                return a.number(t13);
              case "boolean":
                return a.boolean(t13);
              case "null":
                return a.null("null");
              case "undefined":
                return a.undefined("undefined");
              case "date":
                return a.date(l(t13));
              case "error":
                return a.error(f(t13));
              default:
                return t13 && t13.toString ? t13.toString() : Object.prototype.toString.call(t13);
            }
          }
          __name(g, "g");
          function v(e4) {
            return !(-1 === ["object", "array"].indexOf(n(e4)) || !h.has(e4) && (h.set(e4), 1));
          }
          __name(v, "v");
          var y = "";
          return h.set(e3), "object" === n(e3) && Object.keys(e3).length > 0 ? y = d(e3) : "array" === n(e3) && e3.length > 0 && (y = m(e3)), 0 === y.length ? "" : `${c}${y.slice(1)}${u}`;
        };
      }, 7344: (e2) => {
        "use strict";
        e2.exports = function(e3) {
          return Array.isArray(e3) ? "array" : e3 instanceof Date ? "date" : e3 instanceof Error ? "error" : null === e3 ? "null" : "object" == typeof e3 && "[object Object]" === Object.prototype.toString.call(e3) ? "object" : typeof e3;
        };
      }, 6608: (e2) => {
        "use strict";
        e2.exports = __require("assert");
      }, 4368: (e2) => {
        "use strict";
        e2.exports = __require("child_process");
      }, 467: (e2) => {
        "use strict";
        e2.exports = __require("events");
      }, 2058: (e2) => {
        "use strict";
        e2.exports = __require("fs");
      }, 8558: (e2) => {
        "use strict";
        e2.exports = __require("os");
      }, 7072: (e2) => {
        "use strict";
        e2.exports = __require("path");
      }, 8378: (e2) => {
        "use strict";
        e2.exports = __require("stream");
      }, 970: (e2) => {
        "use strict";
        e2.exports = __require("util");
      } }, t10 = {}, r = (/* @__PURE__ */ __name(function r2(n) {
        var o = t10[n];
        if (void 0 !== o) return o.exports;
        var i = t10[n] = { exports: {} };
        return e[n](i, i.exports, r2), i.exports;
      }, "r"))(2980);
      module.exports = r;
    })();
  }
});

// ../../node_modules/isexe/windows.js
var require_windows = __commonJS({
  "../../node_modules/isexe/windows.js"(exports, module) {
    module.exports = isexe;
    isexe.sync = sync;
    var fs2 = __require("fs");
    function checkPathExt(path4, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path4.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    __name(checkPathExt, "checkPathExt");
    function checkStat(stat, path4, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path4, options);
    }
    __name(checkStat, "checkStat");
    function isexe(path4, options, cb) {
      fs2.stat(path4, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path4, options));
      });
    }
    __name(isexe, "isexe");
    function sync(path4, options) {
      return checkStat(fs2.statSync(path4), path4, options);
    }
    __name(sync, "sync");
  }
});

// ../../node_modules/isexe/mode.js
var require_mode = __commonJS({
  "../../node_modules/isexe/mode.js"(exports, module) {
    module.exports = isexe;
    isexe.sync = sync;
    var fs2 = __require("fs");
    function isexe(path4, options, cb) {
      fs2.stat(path4, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    __name(isexe, "isexe");
    function sync(path4, options) {
      return checkStat(fs2.statSync(path4), options);
    }
    __name(sync, "sync");
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    __name(checkStat, "checkStat");
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
    __name(checkMode, "checkMode");
  }
});

// ../../node_modules/isexe/index.js
var require_isexe = __commonJS({
  "../../node_modules/isexe/index.js"(exports, module) {
    var fs2 = __require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module.exports = isexe;
    isexe.sync = sync;
    function isexe(path4, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve2, reject) {
          isexe(path4, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve2(is);
            }
          });
        });
      }
      core(path4, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    __name(isexe, "isexe");
    function sync(path4, options) {
      try {
        return core.sync(path4, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
    __name(sync, "sync");
  }
});

// ../../node_modules/which/which.js
var require_which = __commonJS({
  "../../node_modules/which/which.js"(exports, module) {
    var isWindows2 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path4 = __require("path");
    var COLON = isWindows2 ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = /* @__PURE__ */ __name((cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" }), "getNotFoundError");
    var getPathInfo = /* @__PURE__ */ __name((cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows2 && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows2 ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ];
      const pathExtExe = isWindows2 ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows2 ? pathExtExe.split(colon) : [""];
      if (isWindows2) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    }, "getPathInfo");
    var which = /* @__PURE__ */ __name((cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = /* @__PURE__ */ __name((i) => new Promise((resolve2, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve2(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path4.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve2(subStep(p, i, 0));
      }), "step");
      const subStep = /* @__PURE__ */ __name((p, i, ii) => new Promise((resolve2, reject) => {
        if (ii === pathExt.length)
          return resolve2(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve2(p + ext);
          }
          return resolve2(subStep(p, i, ii + 1));
        });
      }), "subStep");
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    }, "which");
    var whichSync = /* @__PURE__ */ __name((cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path4.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    }, "whichSync");
    module.exports = which;
    which.sync = whichSync;
  }
});

// ../../node_modules/path-key/index.js
var require_path_key = __commonJS({
  "../../node_modules/path-key/index.js"(exports, module) {
    "use strict";
    var pathKey = /* @__PURE__ */ __name((options = {}) => {
      const environment = options.env || process.env;
      const platform = options.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    }, "pathKey");
    module.exports = pathKey;
    module.exports.default = pathKey;
  }
});

// ../../node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "../../node_modules/cross-spawn/lib/util/resolveCommand.js"(exports, module) {
    "use strict";
    var path4 = __require("path");
    var which = require_which();
    var getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: env[getPathKey({ env })],
          pathExt: withoutPathExt ? path4.delimiter : void 0
        });
      } catch (e) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path4.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    __name(resolveCommandAttempt, "resolveCommandAttempt");
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    __name(resolveCommand, "resolveCommand");
    module.exports = resolveCommand;
  }
});

// ../../node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "../../node_modules/cross-spawn/lib/util/escape.js"(exports, module) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    __name(escapeCommand, "escapeCommand");
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"');
      arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    __name(escapeArgument, "escapeArgument");
    module.exports.command = escapeCommand;
    module.exports.argument = escapeArgument;
  }
});

// ../../node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "../../node_modules/shebang-regex/index.js"(exports, module) {
    "use strict";
    module.exports = /^#!(.*)/;
  }
});

// ../../node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "../../node_modules/shebang-command/index.js"(exports, module) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module.exports = (string = "") => {
      const match = string.match(shebangRegex);
      if (!match) {
        return null;
      }
      const [path4, argument] = match[0].replace(/#! ?/, "").split(" ");
      const binary = path4.split("/").pop();
      if (binary === "env") {
        return argument;
      }
      return argument ? `${binary} ${argument}` : binary;
    };
  }
});

// ../../node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "../../node_modules/cross-spawn/lib/util/readShebang.js"(exports, module) {
    "use strict";
    var fs2 = __require("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command2) {
      const size = 150;
      const buffer = Buffer.alloc(size);
      let fd;
      try {
        fd = fs2.openSync(command2, "r");
        fs2.readSync(fd, buffer, 0, size, 0);
        fs2.closeSync(fd);
      } catch (e) {
      }
      return shebangCommand(buffer.toString());
    }
    __name(readShebang, "readShebang");
    module.exports = readShebang;
  }
});

// ../../node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/cross-spawn/lib/parse.js"(exports, module) {
    "use strict";
    var path4 = __require("path");
    var resolveCommand = require_resolveCommand();
    var escape = require_escape();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    __name(detectShebang, "detectShebang");
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path4.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    __name(parseNonShell, "parseNonShell");
    function parse2(command2, args, options) {
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command: command2,
        args,
        options,
        file: void 0,
        original: {
          command: command2,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    __name(parse2, "parse");
    module.exports = parse2;
  }
});

// ../../node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "../../node_modules/cross-spawn/lib/enoent.js"(exports, module) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    __name(notFoundError, "notFoundError");
    function hookChildProcess(cp, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed);
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    __name(hookChildProcess, "hookChildProcess");
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    __name(verifyENOENT, "verifyENOENT");
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    __name(verifyENOENTSync, "verifyENOENTSync");
    module.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// ../../node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "../../node_modules/cross-spawn/index.js"(exports, module) {
    "use strict";
    var cp = __require("child_process");
    var parse2 = require_parse();
    var enoent = require_enoent();
    function spawn(command2, args, options) {
      const parsed = parse2(command2, args, options);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    __name(spawn, "spawn");
    function spawnSync3(command2, args, options) {
      const parsed = parse2(command2, args, options);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    __name(spawnSync3, "spawnSync");
    module.exports = spawn;
    module.exports.spawn = spawn;
    module.exports.sync = spawnSync3;
    module.exports._parse = parse2;
    module.exports._enoent = enoent;
  }
});

// src/bin/run.ts
var import_envinfo = __toESM(require_envinfo(), 1);
import { globalSettings } from "storybook/internal/cli";
import {
  HandledError as HandledError2,
  JsPackageManagerFactory as JsPackageManagerFactory3,
  isCI as isCI2,
  optionalEnvToBoolean as optionalEnvToBoolean3,
  removeAddon as remove,
  versions as versions5
} from "storybook/internal/common";
import { withTelemetry as withTelemetry2 } from "storybook/internal/core-server";
import { CLI_COLORS as CLI_COLORS4, logTracker as logTracker4, logger as logger21, prompt as prompt7 } from "storybook/internal/node-logger";
import { addToGlobalContext, telemetry as telemetry2 } from "storybook/internal/telemetry";
import { program } from "commander";

// ../../node_modules/leven/index.js
var array = [];
var characterCodeCache = [];
function leven(first, second, options) {
  if (first === second) {
    return 0;
  }
  const maxDistance = options?.maxDistance;
  const swap = first;
  if (first.length > second.length) {
    first = second;
    second = swap;
  }
  let firstLength = first.length;
  let secondLength = second.length;
  while (firstLength > 0 && first.charCodeAt(~-firstLength) === second.charCodeAt(~-secondLength)) {
    firstLength--;
    secondLength--;
  }
  let start = 0;
  while (start < firstLength && first.charCodeAt(start) === second.charCodeAt(start)) {
    start++;
  }
  firstLength -= start;
  secondLength -= start;
  if (maxDistance !== void 0 && secondLength - firstLength > maxDistance) {
    return maxDistance;
  }
  if (firstLength === 0) {
    return maxDistance !== void 0 && secondLength > maxDistance ? maxDistance : secondLength;
  }
  let bCharacterCode;
  let result;
  let temporary;
  let temporary2;
  let index = 0;
  let index2 = 0;
  while (index < firstLength) {
    characterCodeCache[index] = first.charCodeAt(start + index);
    array[index] = ++index;
  }
  while (index2 < secondLength) {
    bCharacterCode = second.charCodeAt(start + index2);
    temporary = index2++;
    result = index2;
    for (index = 0; index < firstLength; index++) {
      temporary2 = bCharacterCode === characterCodeCache[index] ? temporary : temporary + 1;
      temporary = array[index];
      result = array[index] = temporary > result ? temporary2 > result ? result + 1 : temporary2 : temporary2 > temporary ? temporary + 1 : temporary2;
    }
    if (maxDistance !== void 0) {
      let rowMinimum = result;
      for (index = 0; index < firstLength; index++) {
        if (array[index] < rowMinimum) {
          rowMinimum = array[index];
        }
      }
      if (rowMinimum > maxDistance) {
        return maxDistance;
      }
    }
  }
  array.length = firstLength;
  characterCodeCache.length = firstLength;
  return maxDistance !== void 0 && result > maxDistance ? maxDistance : result;
}
__name(leven, "leven");

// src/bin/run.ts
var import_picocolors17 = __toESM(require_picocolors(), 1);

// package.json
var version = "10.0.6";

// src/add.ts
var import_semver = __toESM(require_semver(), 1);
import {
  loadMainConfig,
  syncStorybookAddons,
  versions
} from "storybook/internal/common";
import { readConfig, writeConfig } from "storybook/internal/csf-tools";
import { prompt } from "storybook/internal/node-logger";
import { dedent } from "ts-dedent";

// src/automigrate/fixes/wrap-getAbsolutePath-utils.ts
import { types as t } from "storybook/internal/babel";
var PREFERRED_GET_ABSOLUTE_PATH_WRAPPER_NAME = "getAbsolutePath";
var ALTERNATIVE_GET_ABSOLUTE_PATH_WRAPPER_NAME = "wrapForPnp";
function doesVariableOrFunctionDeclarationExist(node, name) {
  return t.isVariableDeclaration(node) && node.declarations.length === 1 && t.isVariableDeclarator(node.declarations[0]) && t.isIdentifier(node.declarations[0].id) && node.declarations[0].id?.name === name || t.isFunctionDeclaration(node) && t.isIdentifier(node.id) && node.id.name === name;
}
__name(doesVariableOrFunctionDeclarationExist, "doesVariableOrFunctionDeclarationExist");
function getReferenceToGetAbsolutePathWrapper(config, value) {
  return t.callExpression(
    t.identifier(getAbsolutePathWrapperName(config) ?? PREFERRED_GET_ABSOLUTE_PATH_WRAPPER_NAME),
    [t.stringLiteral(value)]
  );
}
__name(getReferenceToGetAbsolutePathWrapper, "getReferenceToGetAbsolutePathWrapper");
function getAbsolutePathWrapperName(config) {
  const declarationName = config.getBodyDeclarations().flatMap(
    (node) => doesVariableOrFunctionDeclarationExist(node, ALTERNATIVE_GET_ABSOLUTE_PATH_WRAPPER_NAME) ? [ALTERNATIVE_GET_ABSOLUTE_PATH_WRAPPER_NAME] : doesVariableOrFunctionDeclarationExist(node, PREFERRED_GET_ABSOLUTE_PATH_WRAPPER_NAME) ? [PREFERRED_GET_ABSOLUTE_PATH_WRAPPER_NAME] : []
  );
  if (declarationName.length) {
    return declarationName[0];
  }
  return null;
}
__name(getAbsolutePathWrapperName, "getAbsolutePathWrapperName");
function isGetAbsolutePathWrapperNecessary(node, cb = () => {
}) {
  if (t.isStringLiteral(node)) {
    cb(node);
    return true;
  }
  if (t.isObjectExpression(node)) {
    const nameProperty = node.properties.find(
      (property) => t.isObjectProperty(property) && t.isIdentifier(property.key) && property.key.name === "name"
    );
    if (nameProperty && t.isStringLiteral(nameProperty.value)) {
      cb(nameProperty);
      return true;
    }
  }
  if (t.isArrayExpression(node) && node.elements.some((element) => element && isGetAbsolutePathWrapperNecessary(element))) {
    cb(node);
    return true;
  }
  return false;
}
__name(isGetAbsolutePathWrapperNecessary, "isGetAbsolutePathWrapperNecessary");
function getFieldsForGetAbsolutePathWrapper(config) {
  const frameworkNode = config.getFieldNode(["framework"]);
  const builderNode = config.getFieldNode(["core", "builder"]);
  const rendererNode = config.getFieldNode(["core", "renderer"]);
  const addons = config.getFieldNode(["addons"]);
  const fieldsWithRequireWrapper = [
    ...frameworkNode ? [frameworkNode] : [],
    ...builderNode ? [builderNode] : [],
    ...rendererNode ? [rendererNode] : [],
    ...addons && t.isArrayExpression(addons) ? [addons] : []
  ];
  return fieldsWithRequireWrapper;
}
__name(getFieldsForGetAbsolutePathWrapper, "getFieldsForGetAbsolutePathWrapper");
function getAbsolutePathWrapperAsCallExpression(isConfigTypescript) {
  const functionDeclaration = {
    ...t.functionDeclaration(
      t.identifier(PREFERRED_GET_ABSOLUTE_PATH_WRAPPER_NAME),
      [
        {
          ...t.identifier("value"),
          ...isConfigTypescript ? { typeAnnotation: t.tsTypeAnnotation(t.tSStringKeyword()) } : {}
        }
      ],
      t.blockStatement([
        t.returnStatement(
          t.callExpression(t.identifier("dirname"), [
            t.callExpression(t.identifier("fileURLToPath"), [
              t.callExpression(
                t.memberExpression(
                  t.metaProperty(t.identifier("import"), t.identifier("meta")),
                  t.identifier("resolve")
                ),
                [
                  t.templateLiteral(
                    [
                      t.templateElement({ raw: "" }),
                      t.templateElement({ raw: "/package.json" }, true)
                    ],
                    [t.identifier("value")]
                  )
                ]
              )
            ])
          ])
        )
      ])
    ),
    ...isConfigTypescript ? { returnType: t.tSTypeAnnotation(t.tsAnyKeyword()) } : {}
  };
  t.addComment(
    functionDeclaration,
    "leading",
    "*\n * This function is used to resolve the absolute path of a package.\n * It is needed in projects that use Yarn PnP or are set up within a monorepo.\n"
  );
  return functionDeclaration;
}
__name(getAbsolutePathWrapperAsCallExpression, "getAbsolutePathWrapperAsCallExpression");
function wrapValueWithGetAbsolutePathWrapper(config, node) {
  isGetAbsolutePathWrapperNecessary(node, (n) => {
    if (t.isStringLiteral(n)) {
      const wrapperNode = getReferenceToGetAbsolutePathWrapper(config, n.value);
      Object.keys(n).forEach((k) => {
        delete n[k];
      });
      Object.keys(wrapperNode).forEach((k) => {
        n[k] = wrapperNode[k];
      });
    }
    if (t.isObjectProperty(n) && t.isStringLiteral(n.value)) {
      n.value = getReferenceToGetAbsolutePathWrapper(config, n.value.value);
    }
    if (t.isArrayExpression(n)) {
      n.elements.forEach((element) => {
        if (element && isGetAbsolutePathWrapperNecessary(element)) {
          wrapValueWithGetAbsolutePathWrapper(config, element);
        }
      });
    }
  });
}
__name(wrapValueWithGetAbsolutePathWrapper, "wrapValueWithGetAbsolutePathWrapper");

// src/postinstallAddon.ts
import { createRequire as createRequire2 } from "node:module";
import { fileURLToPath as fileURLToPath2 } from "node:url";

// ../../core/src/shared/utils/module.ts
import { createRequire, register } from "node:module";
import { win32 } from "node:path/win32";
import { fileURLToPath, pathToFileURL } from "node:url";

// ../../node_modules/exsolve/dist/index.mjs
import assert from "node:assert";
import v8 from "node:v8";
import { format, inspect } from "node:util";
var own$1 = {}.hasOwnProperty;
var classRegExp = /^([A-Z][a-z\d]*)+$/;
var kTypes = /* @__PURE__ */ new Set([
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
]);
var messages = /* @__PURE__ */ new Map();
var nodeInternalPrefix = "__node_internal_";
var userStackTraceLimit;
function formatList(array2, type = "and") {
  return array2.length < 3 ? array2.join(` ${type} `) : `${array2.slice(0, -1).join(", ")}, ${type} ${array2.at(-1)}`;
}
__name(formatList, "formatList");
function createError(sym, value, constructor) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(constructor, sym);
}
__name(createError, "createError");
function makeNodeErrorWithCode(Base, key) {
  return /* @__PURE__ */ __name(function NodeError(...parameters) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key, parameters, error);
    Object.defineProperties(error, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error);
    error.code = key;
    return error;
  }, "NodeError");
}
__name(makeNodeErrorWithCode, "makeNodeErrorWithCode");
function isErrorStackTraceLimitWritable() {
  try {
    if (v8.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
__name(isErrorStackTraceLimitWritable, "isErrorStackTraceLimitWritable");
function hideStackFrames(wrappedFunction) {
  const hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, "name", { value: hidden });
  return wrappedFunction;
}
__name(hideStackFrames, "hideStackFrames");
var captureLargerStackTrace = hideStackFrames(function(error) {
  const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
  if (stackTraceLimitIsWritable) {
    userStackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Number.POSITIVE_INFINITY;
  }
  Error.captureStackTrace(error);
  if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
  return error;
});
function getMessage(key, parameters, self2) {
  const message = messages.get(key);
  assert(message !== void 0, "expected `message` to be found");
  if (typeof message === "function") {
    assert(
      message.length <= parameters.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self2, parameters);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null) expectedLength++;
  assert(
    expectedLength === parameters.length,
    `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`
  );
  if (parameters.length === 0) return message;
  parameters.unshift(message);
  return Reflect.apply(format, null, parameters);
}
__name(getMessage, "getMessage");
function determineSpecificType(value) {
  if (value === null || value === void 0) {
    return String(value);
  }
  if (typeof value === "function" && value.name) {
    return `function ${value.name}`;
  }
  if (typeof value === "object") {
    if (value.constructor && value.constructor.name) {
      return `an instance of ${value.constructor.name}`;
    }
    return `${inspect(value, { depth: -1 })}`;
  }
  let inspected = inspect(value, { colors: false });
  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value} (${inspected})`;
}
__name(determineSpecificType, "determineSpecificType");
createError(
  "ERR_INVALID_ARG_TYPE",
  (name, expected, actual) => {
    assert(typeof name === "string", "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }
    let message = "The ";
    if (name.endsWith(" argument")) {
      message += `${name} `;
    } else {
      const type = name.includes(".") ? "property" : "argument";
      message += `"${name}" ${type} `;
    }
    message += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected) {
      assert(
        typeof value === "string",
        "All expected entries have to be of type string"
      );
      if (kTypes.has(value)) {
        types.push(value.toLowerCase());
      } else if (classRegExp.exec(value) === null) {
        assert(
          value !== "object",
          'The value "object" should be written as "Object"'
        );
        other.push(value);
      } else {
        instances.push(value);
      }
    }
    if (instances.length > 0) {
      const pos = types.indexOf("object");
      if (pos !== -1) {
        types.slice(pos, 1);
        instances.push("Object");
      }
    }
    if (types.length > 0) {
      message += `${types.length > 1 ? "one of type" : "of type"} ${formatList(
        types,
        "or"
      )}`;
      if (instances.length > 0 || other.length > 0) message += " or ";
    }
    if (instances.length > 0) {
      message += `an instance of ${formatList(instances, "or")}`;
      if (other.length > 0) message += " or ";
    }
    if (other.length > 0) {
      if (other.length > 1) {
        message += `one of ${formatList(other, "or")}`;
      } else {
        if (other[0]?.toLowerCase() !== other[0]) message += "an ";
        message += `${other[0]}`;
      }
    }
    message += `. Received ${determineSpecificType(actual)}`;
    return message;
  },
  TypeError
);
var ERR_INVALID_MODULE_SPECIFIER = createError(
  "ERR_INVALID_MODULE_SPECIFIER",
  /**
   * @param {string} request
   * @param {string} reason
   * @param {string} [base]
   */
  (request, reason, base) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
  },
  TypeError
);
var ERR_INVALID_PACKAGE_CONFIG = createError(
  "ERR_INVALID_PACKAGE_CONFIG",
  (path4, base, message) => {
    return `Invalid package config ${path4}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
  },
  Error
);
var ERR_INVALID_PACKAGE_TARGET = createError(
  "ERR_INVALID_PACKAGE_TARGET",
  (packagePath, key, target, isImport = false, base) => {
    const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
    if (key === ".") {
      assert(isImport === false);
      return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
    }
    return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
      target
    )} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
  },
  Error
);
var ERR_MODULE_NOT_FOUND = createError(
  "ERR_MODULE_NOT_FOUND",
  (path4, base, exactUrl = false) => {
    return `Cannot find ${exactUrl ? "module" : "package"} '${path4}' imported from ${base}`;
  },
  Error
);
createError(
  "ERR_NETWORK_IMPORT_DISALLOWED",
  "import of '%s' by %s is not supported: %s",
  Error
);
var ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
  "ERR_PACKAGE_IMPORT_NOT_DEFINED",
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath || ""}package.json` : ""} imported from ${base}`;
  },
  TypeError
);
var ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  /**
   * @param {string} packagePath
   * @param {string} subpath
   * @param {string} [base]
   */
  (packagePath, subpath, base) => {
    if (subpath === ".")
      return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
  },
  Error
);
var ERR_UNSUPPORTED_DIR_IMPORT = createError(
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "Directory import '%s' is not supported resolving ES modules imported from %s",
  Error
);
var ERR_UNSUPPORTED_RESOLVE_REQUEST = createError(
  "ERR_UNSUPPORTED_RESOLVE_REQUEST",
  'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',
  TypeError
);
var ERR_UNKNOWN_FILE_EXTENSION = createError(
  "ERR_UNKNOWN_FILE_EXTENSION",
  (extension, path4) => {
    return `Unknown file extension "${extension}" for ${path4}`;
  },
  TypeError
);
createError(
  "ERR_INVALID_ARG_VALUE",
  (name, value, reason = "is invalid") => {
    let inspected = inspect(value);
    if (inspected.length > 128) {
      inspected = `${inspected.slice(0, 128)}...`;
    }
    const type = name.includes(".") ? "property" : "argument";
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
  },
  TypeError
  // Note: extra classes have been shaken out.
  // , RangeError
);
var hasOwnProperty$1 = {}.hasOwnProperty;
var hasOwnProperty = {}.hasOwnProperty;
var RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
var own = {}.hasOwnProperty;
var isWindows = (() => process.platform === "win32")();
var globalCache = (() => (
  // eslint-disable-next-line unicorn/no-unreadable-iife
  globalThis["__EXSOLVE_CACHE__"] ||= /* @__PURE__ */ new Map()
))();

// ../../node_modules/pathe/dist/shared/pathe.ff20891b.mjs
var _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}
__name(normalizeWindowsPath, "normalizeWindowsPath");
var _UNC_REGEX = /^[/\\]{2}/;
var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
var _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
var normalize = /* @__PURE__ */ __name(function(path4) {
  if (path4.length === 0) {
    return ".";
  }
  path4 = normalizeWindowsPath(path4);
  const isUNCPath = path4.match(_UNC_REGEX);
  const isPathAbsolute = isAbsolute(path4);
  const trailingSeparator = path4[path4.length - 1] === "/";
  path4 = normalizeString(path4, !isPathAbsolute);
  if (path4.length === 0) {
    if (isPathAbsolute) {
      return "/";
    }
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator) {
    path4 += "/";
  }
  if (_DRIVE_LETTER_RE.test(path4)) {
    path4 += "/";
  }
  if (isUNCPath) {
    if (!isPathAbsolute) {
      return `//./${path4}`;
    }
    return `//${path4}`;
  }
  return isPathAbsolute && !isAbsolute(path4) ? `/${path4}` : path4;
}, "normalize");
var join = /* @__PURE__ */ __name(function(...arguments_) {
  if (arguments_.length === 0) {
    return ".";
  }
  let joined;
  for (const argument of arguments_) {
    if (argument && argument.length > 0) {
      if (joined === void 0) {
        joined = argument;
      } else {
        joined += `/${argument}`;
      }
    }
  }
  if (joined === void 0) {
    return ".";
  }
  return normalize(joined.replace(/\/\/+/g, "/"));
}, "join");
function normalizeString(path4, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path4.length; ++index) {
    if (index < path4.length) {
      char = path4[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path4.slice(lastSlash + 1, index)}`;
        } else {
          res = path4.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
__name(normalizeString, "normalizeString");
var isAbsolute = /* @__PURE__ */ __name(function(p) {
  return _IS_ABSOLUTE_RE.test(p);
}, "isAbsolute");

// ../../core/src/shared/utils/module.ts
var importMetaResolve = /* @__PURE__ */ __name((...args) => {
  if (typeof import.meta.resolve !== "function" && process.env.VITEST === "true") {
    console.warn(
      "importMetaResolve from within Storybook is being used in a Vitest test, but it shouldn't be. Please report this at https://github.com/storybookjs/storybook/issues/new?template=bug_report.yml"
    );
    return pathToFileURL(args[0]).href;
  }
  return import.meta.resolve(...args);
}, "importMetaResolve");
var isTypescriptLoaderRegistered = false;
async function importModule(path4, { skipCache = false } = {}) {
  if (!isTypescriptLoaderRegistered) {
    const typescriptLoaderUrl = importMetaResolve("storybook/internal/bin/loader");
    register(typescriptLoaderUrl, import.meta.url);
    isTypescriptLoaderRegistered = true;
  }
  let mod;
  try {
    const resolvedPath = win32.isAbsolute(path4) ? pathToFileURL(path4).href : path4;
    const importUrl = skipCache ? `${resolvedPath}?${Date.now()}` : resolvedPath;
    mod = await import(importUrl);
  } catch (importError) {
    try {
      const require3 = createRequire(import.meta.url);
      if (skipCache) {
        delete require3.cache[require3.resolve(path4)];
      }
      mod = require3(path4);
    } catch (requireError) {
      throw importError;
    }
  }
  return mod.default ?? mod;
}
__name(importModule, "importModule");

// src/postinstallAddon.ts
var DIR_CWD = process.cwd();
var require2 = createRequire2(DIR_CWD);
var postinstallAddon = /* @__PURE__ */ __name(async (addonName, options) => {
  const hookPath = `${addonName}/postinstall`;
  let modulePath;
  try {
    modulePath = import.meta.resolve(hookPath, DIR_CWD);
  } catch (e) {
    try {
      modulePath = require2.resolve(hookPath, { paths: [DIR_CWD] });
    } catch (e2) {
      return;
    }
  }
  let moduledLoaded;
  try {
    moduledLoaded = await import(hookPath).catch(() => importModule(hookPath)).catch(() => importModule(modulePath)).catch(() => importModule(fileURLToPath2(modulePath))).catch(() => require2(hookPath)).catch(() => require2(modulePath)).catch(() => require2(fileURLToPath2(modulePath)));
  } catch (e) {
    return;
  }
  const postinstall = moduledLoaded?.default || moduledLoaded?.postinstall || moduledLoaded;
  if (!postinstall || typeof postinstall !== "function") {
    console.log(`Error finding postinstall function for ${addonName}`);
    return;
  }
  try {
    console.log(`Running postinstall script for ${addonName}`);
    await postinstall(options);
  } catch (e) {
    console.error(`Error running postinstall script for ${addonName}`);
    console.error(e);
  }
}, "postinstallAddon");

// src/add.ts
var getVersionSpecifier = /* @__PURE__ */ __name((addon) => {
  const groups = /^(@{0,1}[^@]+)(?:@(.+))?$/.exec(addon);
  if (groups) {
    return [groups[1], groups[2]];
  }
  return [addon, void 0];
}, "getVersionSpecifier");
var checkInstalled = /* @__PURE__ */ __name((addonName, main) => {
  const existingAddon = main.addons?.find((entry) => {
    const name = typeof entry === "string" ? entry : entry.name;
    return name?.endsWith(addonName);
  });
  return !!existingAddon;
}, "checkInstalled");
var isCoreAddon = /* @__PURE__ */ __name((addonName) => Object.hasOwn(versions, addonName), "isCoreAddon");
async function add(addon, {
  packageManager: pkgMgr,
  skipPostinstall,
  configDir: userSpecifiedConfigDir,
  yes,
  skipInstall
}, logger22 = console) {
  const [addonName, inputVersion] = getVersionSpecifier(addon);
  const { mainConfig, mainConfigPath, configDir, previewConfigPath, packageManager } = await getStorybookData({
    configDir: userSpecifiedConfigDir,
    packageManagerName: pkgMgr
  });
  if (typeof configDir === "undefined") {
    throw new Error(dedent`
      Unable to find storybook config directory. Please specify your Storybook config directory with the --config-dir flag.
    `);
  }
  if (!mainConfigPath) {
    logger22.error("Unable to find Storybook main.js config");
    return;
  }
  let shouldAddToMain = true;
  if (checkInstalled(addonName, mainConfig)) {
    shouldAddToMain = false;
    if (!yes) {
      logger22.log(`The Storybook addon "${addonName}" is already present in ${mainConfigPath}.`);
      const shouldForceInstall = await prompt.confirm({
        message: `Do you wish to install it again?`
      });
      if (!shouldForceInstall) {
        return;
      }
    }
  }
  const main = await readConfig(mainConfigPath);
  logger22.log(`Verifying ${addonName}`);
  let version2 = inputVersion;
  if (!version2 && isCoreAddon(addonName)) {
    version2 = versions.storybook;
  }
  if (!version2) {
    const latestVersion = await packageManager.latestVersion(addonName);
    if (!latestVersion) {
      throw new Error(`No version found for ${addonName}`);
    }
    version2 = latestVersion;
  }
  const storybookVersion = versions.storybook;
  const versionIsStorybook = version2 === versions.storybook;
  if (isCoreAddon(addonName) && !versionIsStorybook) {
    logger22.warn(
      `The version of ${addonName} (${version2}) you are installing is not the same as the version of Storybook you are using (${storybookVersion}). This may lead to unexpected behavior.`
    );
  }
  const storybookVersionSpecifier = packageManager.getDependencyVersion("storybook");
  const versionRange = storybookVersionSpecifier?.match(/^[~^]/)?.[0] ?? "";
  const addonWithVersion = versionIsStorybook ? `${addonName}@${versionRange}${storybookVersion}` : isValidVersion(version2) && !version2.includes("-pr-") ? `${addonName}@^${version2}` : `${addonName}@${version2}`;
  logger22.log(`Installing ${addonWithVersion}`);
  await packageManager.addDependencies(
    { type: "devDependencies", writeOutputToFile: false, skipInstall },
    [addonWithVersion]
  );
  if (shouldAddToMain) {
    logger22.log(`Adding '${addon}' to the "addons" field in ${mainConfigPath}`);
    const mainConfigAddons = main.getFieldNode(["addons"]);
    if (mainConfigAddons && getAbsolutePathWrapperName(main) !== null) {
      const addonNode = main.valueToNode(addonName);
      main.appendNodeToArray(["addons"], addonNode);
      wrapValueWithGetAbsolutePathWrapper(main, addonNode);
    } else {
      main.appendValueToArray(["addons"], addonName);
    }
    await writeConfig(main);
  }
  try {
    const newMainConfig = await loadMainConfig({ configDir, skipCache: true });
    await syncStorybookAddons(newMainConfig, previewConfigPath, configDir);
  } catch (e) {
  }
  if (!skipPostinstall && isCoreAddon(addonName)) {
    await postinstallAddon(addonName, {
      packageManager: packageManager.type,
      configDir,
      yes,
      skipInstall
    });
  }
}
__name(add, "add");
function isValidVersion(version2) {
  return import_semver.default.valid(version2) || version2.match(/^\d+$/);
}
__name(isValidVersion, "isValidVersion");

// src/automigrate/index.ts
var import_picocolors13 = __toESM(require_picocolors(), 1);
import { logTracker as logTracker2, logger as logger15, prompt as prompt3 } from "storybook/internal/node-logger";

// ../../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = process.env.NODE_ENV === "production";
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}
__name(invariant, "invariant");

// src/automigrate/index.ts
import { dedent as dedent13 } from "ts-dedent";

// src/doctor/index.ts
var import_picocolors4 = __toESM(require_picocolors(), 1);
import { JsPackageManager } from "storybook/internal/common";
import { CLI_COLORS, logTracker, logger as logger2 } from "storybook/internal/node-logger";
import { dedent as dedent2 } from "ts-dedent";

// src/doctor/getDuplicatedDepsWarnings.ts
var import_picocolors = __toESM(require_picocolors(), 1);
import { frameworkPackages, rendererPackages } from "storybook/internal/common";

// src/doctor/hasMultipleVersions.ts
var import_semver2 = __toESM(require_semver(), 1);
function hasMultipleVersions(versions6) {
  return versions6.find((v) => {
    const major = import_semver2.default.major(v);
    if (major === 0) {
      const minor = import_semver2.default.minor(v);
      if (minor === 0) {
        const patch = import_semver2.default.patch(v);
        return versions6.some((v2) => {
          return import_semver2.default.patch(v2) !== patch;
        });
      }
      return versions6.some((v2) => {
        return import_semver2.default.minor(v2) !== minor;
      });
    }
    return versions6.some((v2) => {
      return import_semver2.default.major(v2) !== major;
    });
  });
}
__name(hasMultipleVersions, "hasMultipleVersions");

// src/doctor/getDuplicatedDepsWarnings.ts
var messageDivider = "\n\n";
var allowList = [
  "@storybook/csf",
  // see this file for more info: code/lib/preview/src/globals/types.ts
  "@storybook/addons",
  "@storybook/channel-postmessage",
  "@storybook/channel-websocket",
  "@storybook/client-api",
  "@storybook/core-client",
  "@storybook/preview-web",
  "@storybook/store",
  // see this file for more info: code/ui/manager/src/globals/types.ts
  "@storybook/components",
  "@storybook/router",
  "@storybook/theming",
  "@storybook/api",
  "@storybook/manager-api"
];
var disallowList = [
  Object.keys(rendererPackages),
  Object.keys(frameworkPackages),
  "storybook",
  "@storybook/instrumenter",
  "@storybook/core-server",
  "@storybook/manager",
  "@storybook/preview"
];
function getDuplicatedDepsWarnings(installationMetadata) {
  try {
    if (!installationMetadata || !installationMetadata?.duplicatedDependencies || Object.keys(installationMetadata.duplicatedDependencies).length === 0) {
      return void 0;
    }
    const messages2 = [];
    const { critical, trivial } = Object.entries(
      installationMetadata?.duplicatedDependencies
    ).reduce(
      (acc, [dep, packageVersions]) => {
        if (allowList.includes(dep)) {
          return acc;
        }
        const hasMultipleMajorVersions = hasMultipleVersions(packageVersions);
        if (disallowList.includes(dep) && hasMultipleMajorVersions) {
          acc.critical.push(
            `${import_picocolors.default.bold(import_picocolors.default.red(dep))}:
${packageVersions.join(", ")}`
          );
        } else {
          acc.trivial.push(`${import_picocolors.default.yellow(dep)}:
${packageVersions.join(", ")}`);
        }
        return acc;
      },
      { critical: [], trivial: [] }
    );
    if (critical.length === 0 && trivial.length === 0) {
      return messages2;
    }
    if (critical.length > 0) {
      messages2.push(
        `${import_picocolors.default.bold(
          "Critical:"
        )} The following dependencies are duplicated and WILL cause unexpected behavior:`
      );
      messages2.push(critical.join(messageDivider), "\n");
    }
    if (trivial.length > 0) {
      messages2.push(
        `${import_picocolors.default.bold(
          "Attention:"
        )} The following dependencies are duplicated which might cause unexpected behavior:`
      );
      messages2.push(trivial.join(messageDivider));
    }
    messages2.push(
      "\n",
      `Please try de-duplicating these dependencies by running ${import_picocolors.default.cyan(
        `${installationMetadata.dedupeCommand}`
      )}`
    );
    messages2.push(
      "\n",
      `You can find more information for a given dependency by running ${import_picocolors.default.cyan(
        `${installationMetadata.infoCommand} <package-name>`
      )}`
    );
    return messages2;
  } catch (err) {
    return void 0;
  }
}
__name(getDuplicatedDepsWarnings, "getDuplicatedDepsWarnings");

// src/doctor/getIncompatibleStorybookPackages.ts
var import_picocolors2 = __toESM(require_picocolors(), 1);
var import_semver3 = __toESM(require_semver(), 1);
import { versions as storybookCorePackages } from "storybook/internal/common";
import { logger } from "storybook/internal/node-logger";

// src/automigrate/helpers/consolidated-packages.ts
var consolidatedPackages = {
  "@storybook/channels": "storybook/internal/channels",
  "@storybook/client-logger": "storybook/internal/client-logger",
  "@storybook/core-common": "storybook/internal/common",
  "@storybook/core-events": "storybook/internal/core-events",
  "@storybook/csf": "storybook/internal/csf",
  "@storybook/csf-tools": "storybook/internal/csf-tools",
  "@storybook/docs-tools": "storybook/internal/docs-tools",
  "@storybook/node-logger": "storybook/internal/node-logger",
  "@storybook/preview-api": "storybook/preview-api",
  "@storybook/router": "storybook/internal/router",
  "@storybook/telemetry": "storybook/internal/telemetry",
  "@storybook/theming": "storybook/theming",
  "@storybook/types": "storybook/internal/types",
  "@storybook/manager-api": "storybook/manager-api",
  "@storybook/manager": "storybook/internal/manager",
  "@storybook/preview": "storybook/internal/preview",
  "@storybook/core-server": "storybook/internal/core-server",
  "@storybook/builder-manager": "storybook/internal/builder-manager",
  "@storybook/components": "storybook/internal/components",
  "@storybook/test": "storybook/test",
  "@storybook/experimental-nextjs-vite": "@storybook/nextjs-vite",
  "@storybook/instrumenter": "storybook/internal/instrumenter",
  "@storybook/blocks": "@storybook/addon-docs/blocks"
};

// src/doctor/getIncompatibleStorybookPackages.ts
var checkPackageCompatibility = /* @__PURE__ */ __name(async (dependency, context) => {
  const { currentStorybookVersion, skipErrors, packageManager } = context;
  try {
    const dependencyPackageJson = await packageManager.getModulePackageJSON(dependency);
    if (dependencyPackageJson === null) {
      return { packageName: dependency };
    }
    const {
      version: packageVersion,
      name = dependency,
      dependencies,
      peerDependencies,
      homepage
    } = dependencyPackageJson;
    const packageStorybookVersion = Object.entries({
      ...dependencies,
      ...peerDependencies
    }).filter(
      ([dep]) => storybookCorePackages[dep] || consolidatedPackages[dep]
    ).map(([_, versionRange]) => versionRange).find((versionRange) => {
      return versionRange && // We can't check compatibility for 0.x packages, so we skip them
      !/^[~^]?0\./.test(versionRange) && import_semver3.default.validRange(versionRange) && !import_semver3.default.satisfies(currentStorybookVersion, versionRange);
    });
    const isCorePackage3 = storybookCorePackages[name];
    let availableUpdate;
    let availableCoreUpdate;
    if (isCorePackage3 && packageVersion && import_semver3.default.gt(currentStorybookVersion, packageVersion)) {
      availableUpdate = currentStorybookVersion;
    }
    if (isCorePackage3 && packageVersion && import_semver3.default.gt(packageVersion, currentStorybookVersion)) {
      availableCoreUpdate = packageVersion;
    }
    return {
      packageName: name,
      packageVersion,
      homepage,
      hasIncompatibleDependencies: packageStorybookVersion != null,
      packageStorybookVersion,
      availableUpdate,
      availableCoreUpdate
    };
  } catch (err) {
    if (!skipErrors) {
      logger.log(
        `Error checking compatibility for ${dependency}, please report an issue:
` + String(err)
      );
    }
    return { packageName: dependency };
  }
}, "checkPackageCompatibility");
var getIncompatibleStorybookPackages = /* @__PURE__ */ __name(async (context) => {
  if (context.currentStorybookVersion.includes("0.0.0")) {
    return [];
  }
  const allDeps = context.packageManager.getAllDependencies();
  const storybookLikeDeps = Object.keys(allDeps).filter((dep) => dep.includes("storybook"));
  if (storybookLikeDeps.length === 0 && !context.skipErrors) {
    throw new Error("No Storybook dependencies found in the package.json");
  }
  return Promise.all(
    storybookLikeDeps.filter((dep) => !storybookCorePackages[dep]).map((dep) => checkPackageCompatibility(dep, context))
  );
}, "getIncompatibleStorybookPackages");
var getIncompatiblePackagesSummary = /* @__PURE__ */ __name((dependencyAnalysis, currentStorybookVersion) => {
  const summaryMessage = [];
  const incompatiblePackages = dependencyAnalysis.filter(
    (dep) => dep.hasIncompatibleDependencies
  );
  if (incompatiblePackages.length > 0) {
    summaryMessage.push(
      `You are currently using Storybook ${import_picocolors2.default.bold(
        currentStorybookVersion
      )} but you have packages which are incompatible with it:
`
    );
    incompatiblePackages.forEach(
      ({
        packageName: addonName,
        packageVersion: addonVersion,
        homepage,
        availableUpdate,
        packageStorybookVersion
      }) => {
        const packageDescription = `${addonName}@${addonVersion}`;
        const updateMessage = availableUpdate ? ` (${availableUpdate} available!)` : "";
        const dependsOnStorybook = packageStorybookVersion != null ? ` which depends on ${packageStorybookVersion}` : "";
        const packageRepo = homepage ? `
 Repo: ${homepage}` : "";
        summaryMessage.push(
          `- ${packageDescription}${updateMessage}${dependsOnStorybook}${packageRepo}`
        );
      }
    );
    summaryMessage.push(
      "\nPlease consider updating your packages or contacting the maintainers for compatibility details.",
      "\nFor more on Storybook 9 compatibility, see the linked GitHub issue:",
      "https://github.com/storybookjs/storybook/issues/30944"
    );
    if (incompatiblePackages.some((dep) => dep.availableCoreUpdate)) {
      summaryMessage.push(
        "\n",
        `The version of ${import_picocolors2.default.blue(`storybook@${currentStorybookVersion}`)} is behind the following core packages:`,
        `${incompatiblePackages.filter((dep) => dep.availableCoreUpdate).map(
          ({ packageName, packageVersion }) => `- ${import_picocolors2.default.blue(`${packageName}@${packageVersion}`)}`
        ).join("\n")}`,
        "\n",
        `Upgrade Storybook with:`,
        import_picocolors2.default.blue("npx storybook@latest upgrade")
      );
    }
  }
  return summaryMessage.join("\n");
}, "getIncompatiblePackagesSummary");

// src/doctor/getMismatchingVersionsWarning.ts
var import_picocolors3 = __toESM(require_picocolors(), 1);
var import_semver4 = __toESM(require_semver(), 1);
import { frameworkPackages as frameworkPackages2, versions as storybookCorePackages2 } from "storybook/internal/common";
function getPrimaryVersion(name, installationMetadata) {
  if (!name) {
    return void 0;
  }
  const packageMetadata = installationMetadata?.dependencies[name];
  if (!packageMetadata) {
    return void 0;
  }
  return packageMetadata[0]?.version;
}
__name(getPrimaryVersion, "getPrimaryVersion");
function getMismatchingVersionsWarnings(installationMetadata) {
  if (!installationMetadata) {
    return void 0;
  }
  const messages2 = [];
  try {
    const frameworkPackageName = Object.keys(installationMetadata?.dependencies || []).find(
      (packageName) => {
        return Object.keys(frameworkPackages2).includes(packageName);
      }
    );
    const cliVersion = getPrimaryVersion("storybook", installationMetadata);
    const frameworkVersion = getPrimaryVersion(frameworkPackageName, installationMetadata);
    if (!cliVersion || !frameworkVersion || import_semver4.default.eq(cliVersion, frameworkVersion)) {
      return void 0;
    }
    messages2.push(
      `${import_picocolors3.default.bold(
        "Attention:"
      )} There seems to be a mismatch between your Storybook package versions. This can result in a broken Storybook installation.`
    );
    let versionToCompare;
    let packageToDisplay;
    if (import_semver4.default.lt(cliVersion, frameworkVersion)) {
      versionToCompare = frameworkVersion;
      packageToDisplay = frameworkPackageName;
    } else {
      versionToCompare = cliVersion;
      packageToDisplay = "storybook";
    }
    messages2.push(
      `The version of your storybook core packages should align with ${import_picocolors3.default.yellow(
        versionToCompare
      )} (from the ${import_picocolors3.default.cyan(packageToDisplay)} package) or higher.`
    );
    const filteredDependencies = Object.entries(installationMetadata?.dependencies || []).filter(
      ([name, packages]) => {
        if (Object.keys(storybookCorePackages2).includes(name)) {
          const packageVersion = packages[0].version;
          return packageVersion !== versionToCompare;
        }
        return false;
      }
    );
    if (filteredDependencies.length > 0) {
      messages2.push(
        `Based on your lockfile, these dependencies should be aligned:`,
        filteredDependencies.map(([name, dep]) => `${import_picocolors3.default.yellow(name)}: ${dep[0].version}`).join("\n")
      );
    }
    messages2.push(
      `You can run ${import_picocolors3.default.cyan("npx storybook@latest upgrade")} to upgrade all of your Storybook packages to the latest version.

Alternatively you can try manually changing the versions to match in your package.json. We also recommend regenerating your lockfile, or running the following command to possibly deduplicate your Storybook package versions: ${import_picocolors3.default.cyan(installationMetadata?.dedupeCommand)}`
    );
    return messages2.join("\n\n");
  } catch (err) {
    return void 0;
  }
}
__name(getMismatchingVersionsWarnings, "getMismatchingVersionsWarnings");

// src/doctor/types.ts
var DiagnosticType = /* @__PURE__ */ ((DiagnosticType2) => {
  DiagnosticType2["MISSING_STORYBOOK_DEPENDENCY"] = "missing_storybook_dependency";
  DiagnosticType2["INCOMPATIBLE_PACKAGES"] = "incompatible_packages";
  DiagnosticType2["MISMATCHING_VERSIONS"] = "mismatching_versions";
  DiagnosticType2["DUPLICATED_DEPENDENCIES"] = "duplicated_dependencies";
  DiagnosticType2["CONFIGURATION_ERROR"] = "configuration_error";
  return DiagnosticType2;
})(DiagnosticType || {});

// src/doctor/index.ts
function collectDeduplicatedDiagnostics(projectResults) {
  const diagnosticMap = /* @__PURE__ */ new Map();
  Object.entries(projectResults).forEach(([configDir, result]) => {
    Object.entries(result.diagnostics).forEach(([type, status]) => {
      if (status !== "passed" /* PASSED */) {
        const diagnosticType = type;
        const message = result.messages[diagnosticType];
        if (message) {
          const existing = diagnosticMap.get(diagnosticType);
          if (existing) {
            existing.projects.push({ configDir });
          } else {
            diagnosticMap.set(diagnosticType, {
              type: diagnosticType,
              title: type.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase()),
              message,
              projects: [{ configDir }]
            });
          }
        }
      }
    });
  });
  return Array.from(diagnosticMap.values());
}
__name(collectDeduplicatedDiagnostics, "collectDeduplicatedDiagnostics");
function displayDoctorResults(projectResults) {
  const projectCount = Object.keys(projectResults).length;
  if (projectCount === 0) {
    return false;
  }
  const hasAnyIssues = Object.values(projectResults).some((result) => result.status !== "healthy");
  if (!hasAnyIssues) {
    if (projectCount === 1) {
      logger2.log(`Your Storybook project looks good!`);
    } else {
      logger2.log(`All ${projectCount} Storybook projects look good!`);
    }
    return false;
  }
  if (projectCount === 1) {
    const [configDir, result] = Object.entries(projectResults)[0];
    const projectName = shortenPath(configDir) || ".";
    if (result.status === "healthy") {
      logger2.log(`\u2705 ${projectName}: No issues found`);
    } else {
      const issueCount = Object.values(result.diagnostics).filter(
        (status) => status !== "passed" /* PASSED */
      ).length;
      if (result.status === "check_error") {
        logger2.error(
          `${projectName}: ${issueCount} ${issueCount === 1 ? "problem" : "problems"} found`
        );
      } else {
        logger2.warn(`${projectName}: ${issueCount} ${issueCount === 1 ? "issue" : "issues"} found`);
      }
      Object.entries(result.diagnostics).forEach(([type, status]) => {
        if (status !== "passed" /* PASSED */) {
          const message = result.messages[type];
          if (message) {
            const title = type.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
            logger2.logBox(message, {
              title: status === "check_error" /* CHECK_ERROR */ ? CLI_COLORS.error(title) : CLI_COLORS.warning(title)
            });
          }
        }
      });
    }
  } else {
    const deduplicatedDiagnostics = collectDeduplicatedDiagnostics(projectResults);
    const totalIssues = deduplicatedDiagnostics.length;
    const errorCount = Object.values(projectResults).filter(
      (result) => result.status === "check_error"
    ).length;
    if (errorCount > 0) {
      logger2.error(
        `Found ${totalIssues} ${totalIssues === 1 ? "issue" : "issues"} across ${projectCount} projects`
      );
    } else {
      logger2.warn(
        `Found ${totalIssues} ${totalIssues === 1 ? "issue" : "issues"} across ${projectCount} projects`
      );
    }
    deduplicatedDiagnostics.forEach((diagnostic) => {
      let messageWithProjects = diagnostic.message;
      if (diagnostic.projects.length > 1) {
        const projectNames = diagnostic.projects.map((p) => shortenPath(p.configDir) || ".").join(", ");
        messageWithProjects += `

Affected projects: ${projectNames}`;
      } else {
        const projectName = shortenPath(diagnostic.projects[0].configDir) || ".";
        messageWithProjects += `

Affected project: ${projectName}`;
      }
      logger2.logBox(messageWithProjects, {
        title: CLI_COLORS.warning(diagnostic.title)
      });
    });
  }
  logger2.step("Storybook doctor is complete!");
  const commandMessage = `You can always recheck the health of your project(s) by running:
${import_picocolors4.default.cyan(
    "npx storybook doctor"
  )}`;
  logger2.log(commandMessage);
  return true;
}
__name(displayDoctorResults, "displayDoctorResults");
async function runMultiProjectDoctor(projects) {
  if (projects.length === 0) {
    return {};
  }
  const projectOptions = projects.map((project) => ({
    configDir: project.configDir,
    packageManager: project.packageManager,
    storybookVersion: project.storybookVersion,
    mainConfig: project.mainConfig
  }));
  return await collectDoctorResultsByProject(projectOptions);
}
__name(runMultiProjectDoctor, "runMultiProjectDoctor");
var doctor = /* @__PURE__ */ __name(async ({
  configDir: userSpecifiedConfigDir,
  packageManager: packageManagerName
}) => {
  logger2.step("Checking the health of your Storybook..");
  const diagnosticResults = [];
  let packageManager;
  let configDir;
  let storybookVersion;
  let mainConfig;
  try {
    ({ packageManager, configDir, storybookVersion, mainConfig } = await getStorybookData({
      configDir: userSpecifiedConfigDir,
      packageManagerName
    }));
  } catch (err) {
    const title = "Configuration Error";
    let message;
    if (err.message.includes("No configuration files have been found")) {
      message = dedent2`
          Could not find or evaluate your Storybook main.js config directory at ${import_picocolors4.default.blue(
        configDir || ".storybook"
      )} so the doctor command cannot proceed. You might be running this command in a monorepo or a non-standard project structure. If that is the case, please rerun this command by specifying the path to your Storybook config directory via the --config-dir option.
        `;
    } else {
      message = `\u274C ${err.message}`;
    }
    diagnosticResults.push({
      type: "configuration_error" /* CONFIGURATION_ERROR */,
      title,
      message,
      projects: [{ configDir }]
    });
  }
  const doctorResults = await collectDoctorResultsByProject([
    {
      configDir,
      packageManager,
      storybookVersion,
      mainConfig
    }
  ]);
  const foundIssues = displayDoctorResults(doctorResults);
  if (foundIssues) {
    logTracker.enableLogWriting();
  }
}, "doctor");
async function getDoctorDiagnostics({
  configDir,
  packageManager,
  storybookVersion,
  mainConfig
}) {
  const results = [];
  if (!storybookVersion) {
    results.push({
      type: "configuration_error" /* CONFIGURATION_ERROR */,
      title: "Version Detection Failed",
      message: dedent2`
         Unable to determine Storybook version so the command will not proceed.
         Are you running storybook doctor from your project directory? Please specify your Storybook config directory with the --config-dir flag.
      `,
      project: { configDir }
    });
    return results;
  }
  if (!mainConfig) {
    results.push({
      type: "configuration_error" /* CONFIGURATION_ERROR */,
      title: "Main Config Error",
      message: "mainConfig is undefined",
      project: { configDir }
    });
    return results;
  }
  const hasStorybookDependency = packageManager.packageJsonPaths.some(
    JsPackageManager.hasStorybookDependency
  );
  if (!hasStorybookDependency) {
    results.push({
      type: "missing_storybook_dependency" /* MISSING_STORYBOOK_DEPENDENCY */,
      title: `Package "storybook" not found`,
      message: dedent2`
        The "storybook" package was not found in your package.json.
        Installing "storybook" as a direct dev dependency in your package.json is required.
      `,
      project: { configDir }
    });
  }
  const incompatibleStorybookPackagesList = await getIncompatibleStorybookPackages({
    currentStorybookVersion: storybookVersion,
    packageManager
  });
  const incompatiblePackagesMessage = getIncompatiblePackagesSummary(
    incompatibleStorybookPackagesList,
    storybookVersion
  );
  if (incompatiblePackagesMessage) {
    results.push({
      type: "incompatible_packages" /* INCOMPATIBLE_PACKAGES */,
      title: "Incompatible packages found",
      message: incompatiblePackagesMessage,
      project: { configDir }
    });
  }
  const installationMetadata = await packageManager.findInstallations([
    "@storybook/*",
    "storybook"
  ]);
  if (!incompatiblePackagesMessage) {
    const mismatchingVersionMessage = getMismatchingVersionsWarnings(installationMetadata);
    if (mismatchingVersionMessage) {
      results.push({
        type: "mismatching_versions" /* MISMATCHING_VERSIONS */,
        title: "Diagnostics",
        message: mismatchingVersionMessage,
        project: { configDir }
      });
    } else {
      const list = installationMetadata ? getDuplicatedDepsWarnings(installationMetadata) : getDuplicatedDepsWarnings();
      if (Array.isArray(list) && list.length > 0) {
        results.push({
          type: "duplicated_dependencies" /* DUPLICATED_DEPENDENCIES */,
          title: "Duplicated dependencies found",
          message: list.join("\n"),
          project: { configDir }
        });
      }
    }
  }
  return results;
}
__name(getDoctorDiagnostics, "getDoctorDiagnostics");
async function collectDoctorResultsByProject(projectOptions) {
  const projectResults = {};
  for (const options of projectOptions) {
    const { configDir } = options;
    try {
      const checkResults = await getDoctorDiagnostics(options);
      const diagnostics = {};
      const messages2 = {};
      Object.values(DiagnosticType).forEach((type) => {
        diagnostics[type] = "passed" /* PASSED */;
      });
      let hasIssues = false;
      let hasErrors = false;
      for (const checkResult of checkResults) {
        if (checkResult.type === "configuration_error" /* CONFIGURATION_ERROR */) {
          diagnostics[checkResult.type] = "check_error" /* CHECK_ERROR */;
          hasErrors = true;
        } else {
          diagnostics[checkResult.type] = "has_issues" /* HAS_ISSUES */;
          hasIssues = true;
        }
        messages2[checkResult.type] = checkResult.message;
      }
      const status = hasErrors ? "check_error" : hasIssues ? "has_issues" : "healthy";
      projectResults[configDir] = {
        configDir,
        status,
        diagnostics,
        messages: messages2
      };
    } catch (error) {
      logger2.error(`Failed to run doctor checks for project ${configDir}:
${error}`);
      const diagnostics = {};
      const messages2 = {};
      Object.values(DiagnosticType).forEach((type) => {
        diagnostics[type] = "passed" /* PASSED */;
      });
      diagnostics["configuration_error" /* CONFIGURATION_ERROR */] = "check_error" /* CHECK_ERROR */;
      messages2["configuration_error" /* CONFIGURATION_ERROR */] = `Failed to run doctor checks: ${error instanceof Error ? error.message : String(error)}`;
      projectResults[configDir] = {
        configDir,
        status: "check_error",
        diagnostics,
        messages: messages2
      };
    }
  }
  return projectResults;
}
__name(collectDoctorResultsByProject, "collectDoctorResultsByProject");

// src/codemod/csf-factories.ts
var import_picocolors7 = __toESM(require_picocolors(), 1);
import {
  optionalEnvToBoolean,
  syncStorybookAddons as syncStorybookAddons2
} from "storybook/internal/common";
import { logger as logger6, prompt as prompt2 } from "storybook/internal/node-logger";
import { dedent as dedent3 } from "ts-dedent";

// src/automigrate/codemod.ts
var import_picocolors5 = __toESM(require_picocolors(), 1);
import os from "node:os";
import { formatFileContent } from "storybook/internal/common";
import { logger as logger3 } from "storybook/internal/node-logger";
import { promises as fs } from "fs";
var maxConcurrentTasks = Math.max(1, os.cpus().length - 1);
async function runCodemod(globPattern = "**/*.stories.*", transform, { dryRun = false, skipFormatting = false } = {}) {
  let modifiedCount = 0;
  let unmodifiedCount = 0;
  let errorCount = 0;
  const { globby } = await import("./globby-J3T2ZND4.js");
  const files = await globby(slash(globPattern), {
    followSymbolicLinks: true,
    ignore: ["**/node_modules/**", "**/dist/**", "**/storybook-static/**", "**/build/**"]
  });
  if (!files.length) {
    logger3.error(
      `No files found for glob pattern "${globPattern}".
Please try a different pattern.
`
    );
    throw new Error("No files matched");
  }
  try {
    const pLimit = (await import("./p-limit-OEC3Z6OA.js")).default;
    const limit = pLimit(maxConcurrentTasks);
    await Promise.all(
      files.map(
        (file) => limit(async () => {
          try {
            let filePath = file;
            try {
              filePath = await fs.realpath(file);
            } catch (err) {
            }
            const source = await fs.readFile(filePath, "utf-8");
            const fileInfo = { path: filePath, source };
            const transformedSource = await transform(fileInfo);
            if (transformedSource !== source) {
              if (!dryRun) {
                const fileContent = skipFormatting ? transformedSource : await formatFileContent(file, transformedSource);
                await fs.writeFile(file, fileContent, "utf-8");
              }
              modifiedCount++;
            } else {
              unmodifiedCount++;
            }
          } catch (fileError) {
            logger3.error(`Error processing file ${file}: ${String(fileError)}`);
            errorCount++;
          }
        })
      )
    );
  } catch (error) {
    logger3.error(`Error applying transform: ${String(error)}`);
    errorCount++;
  }
  logger3.log(
    `Summary: ${import_picocolors5.default.green(`${modifiedCount} transformed`)}, ${import_picocolors5.default.yellow(`${unmodifiedCount} unmodified`)}, ${import_picocolors5.default.red(`${errorCount} errors`)}`
  );
  if (dryRun) {
    logger3.log(
      import_picocolors5.default.bold(
        `This was a dry run. Run without --dry-run to apply the transformation to ${modifiedCount} files.`
      )
    );
  }
}
__name(runCodemod, "runCodemod");

// src/codemod/helpers/config-to-csf-factory.ts
var import_picocolors6 = __toESM(require_picocolors(), 1);
import { types as t3 } from "storybook/internal/babel";
import { formatFileContent as formatFileContent2 } from "storybook/internal/common";
import { loadConfig, printConfig } from "storybook/internal/csf-tools";
import { logger as logger4 } from "storybook/internal/node-logger";

// src/codemod/helpers/csf-factories-utils.ts
import { types as t2, traverse } from "storybook/internal/babel";
var projectAnnotationNames = [
  "decorators",
  "parameters",
  "args",
  "argTypes",
  "loaders",
  "beforeEach",
  "afterEach",
  "render",
  "tags",
  "mount",
  "argsEnhancers",
  "argTypesEnhancers",
  "beforeAll",
  "initialGlobals",
  "globalTypes",
  "applyDecorators",
  "runStep"
];
function cleanupTypeImports(programNode, disallowList2) {
  const usedIdentifiers = /* @__PURE__ */ new Set();
  try {
    traverse(programNode, {
      Identifier(path4) {
        if (!path4.findParent((p) => p.isImportDeclaration())) {
          usedIdentifiers.add(path4.node.name);
        }
      },
      noScope: true
    });
  } catch (err) {
  }
  return programNode.body.filter((node) => {
    if (t2.isImportDeclaration(node)) {
      const { source, specifiers } = node;
      if (source.value.startsWith("@storybook/")) {
        const allowedSpecifiers = specifiers.filter((specifier) => {
          if (t2.isImportSpecifier(specifier) && t2.isIdentifier(specifier.imported)) {
            const name = specifier.imported.name;
            return !disallowList2.includes(name) || usedIdentifiers.has(name);
          }
          return true;
        });
        if (allowedSpecifiers.length > 0) {
          node.specifiers = allowedSpecifiers;
          return true;
        }
        return false;
      }
    }
    return true;
  });
}
__name(cleanupTypeImports, "cleanupTypeImports");
function removeExportDeclarations(programNode, exportDecls) {
  return programNode.body.filter((node) => {
    if (t2.isExportNamedDeclaration(node) && node.declaration) {
      if (t2.isVariableDeclaration(node.declaration)) {
        node.declaration.declarations = node.declaration.declarations.filter(
          (decl) => t2.isIdentifier(decl.id) && !exportDecls[decl.id.name]
        );
        return node.declaration.declarations.length > 0;
      } else if (t2.isFunctionDeclaration(node.declaration)) {
        const funcDecl = node.declaration;
        return t2.isIdentifier(funcDecl.id) && !exportDecls[funcDecl.id.name];
      }
    }
    return true;
  });
}
__name(removeExportDeclarations, "removeExportDeclarations");
function getConfigProperties(exportDecls, options) {
  const properties = [];
  for (const [name, decl] of Object.entries(exportDecls)) {
    if (options.configType === "preview" && !projectAnnotationNames.includes(name)) {
      continue;
    }
    if (t2.isVariableDeclarator(decl) && decl.init) {
      properties.push(t2.objectProperty(t2.identifier(name), decl.init));
    } else if (t2.isFunctionDeclaration(decl)) {
      properties.push(
        t2.objectProperty(t2.identifier(name), t2.arrowFunctionExpression([], decl.body))
      );
    }
  }
  return properties;
}
__name(getConfigProperties, "getConfigProperties");

// src/codemod/helpers/config-to-csf-factory.ts
async function configToCsfFactory(info, { configType, frameworkPackage }, { dryRun = false, skipFormatting = false } = {}) {
  const config = loadConfig(info.source);
  try {
    config.parse();
  } catch (err) {
    logger4.log(`Error when parsing ${info.path}, skipping:
${err}`);
    return info.source;
  }
  const methodName = configType === "main" ? "defineMain" : "definePreview";
  const programNode = config._ast.program;
  const exportDecls = config._exportDecls;
  const defineConfigProps = getConfigProperties(exportDecls, { configType });
  const hasNamedExports = defineConfigProps.length > 0;
  function findDeclarationNodeIndex(declarationName) {
    return programNode.body.findIndex(
      (n) => t3.isVariableDeclaration(n) && n.declarations.some((d) => {
        let declaration = d.init;
        if (t3.isTSAsExpression(declaration) || t3.isTSSatisfiesExpression(declaration)) {
          declaration = declaration.expression;
        }
        return t3.isIdentifier(d.id) && d.id.name === declarationName && t3.isObjectExpression(declaration);
      })
    );
  }
  __name(findDeclarationNodeIndex, "findDeclarationNodeIndex");
  if (config._exportsObject && hasNamedExports) {
    config._exportsObject.properties = [...defineConfigProps, ...config._exportsObject.properties];
    programNode.body = removeExportDeclarations(programNode, exportDecls);
    const defineConfigCall = t3.callExpression(t3.identifier(methodName), [config._exportsObject]);
    let exportDefaultNode = null;
    let declarationNodeIndex = -1;
    programNode.body.forEach((node) => {
      if (t3.isExportDefaultDeclaration(node) && t3.isIdentifier(node.declaration)) {
        const declarationName = node.declaration.name;
        declarationNodeIndex = findDeclarationNodeIndex(declarationName);
        if (declarationNodeIndex !== -1) {
          exportDefaultNode = node;
          const declarationNode = programNode.body[declarationNodeIndex];
          if (t3.isVariableDeclaration(declarationNode)) {
            const id = declarationNode.declarations[0].id;
            const variableName = t3.isIdentifier(id) && id.name;
            if (variableName) {
              programNode.body.splice(declarationNodeIndex, 1);
            }
          }
        }
      } else if (t3.isExportDefaultDeclaration(node) && t3.isObjectExpression(node.declaration)) {
        exportDefaultNode = node;
      }
    });
    if (exportDefaultNode !== null) {
      exportDefaultNode.declaration = defineConfigCall;
    }
  } else if (config._exportsObject) {
    const defineConfigCall = t3.callExpression(t3.identifier(methodName), [config._exportsObject]);
    let exportDefaultNode = null;
    let declarationNodeIndex = -1;
    programNode.body.forEach((node) => {
      const declaration = t3.isExportDefaultDeclaration(node) && config._unwrap(node.declaration);
      if (t3.isExportDefaultDeclaration(node) && t3.isIdentifier(declaration)) {
        const declarationName = declaration.name;
        declarationNodeIndex = findDeclarationNodeIndex(declarationName);
        if (declarationNodeIndex !== -1) {
          exportDefaultNode = node;
          const declarationNode = programNode.body[declarationNodeIndex];
          if (t3.isVariableDeclaration(declarationNode)) {
            const id = declarationNode.declarations[0].id;
            const variableName = t3.isIdentifier(id) && id.name;
            if (variableName) {
              programNode.body.splice(declarationNodeIndex, 1);
            }
          }
        }
      } else if (t3.isExportDefaultDeclaration(node) && t3.isObjectExpression(node.declaration)) {
        exportDefaultNode = node;
      }
    });
    if (exportDefaultNode !== null) {
      exportDefaultNode.declaration = defineConfigCall;
    }
  } else if (hasNamedExports) {
    const defineConfigCall = t3.callExpression(t3.identifier(methodName), [
      t3.objectExpression(defineConfigProps)
    ]);
    programNode.body = removeExportDeclarations(programNode, exportDecls);
    programNode.body.push(t3.exportDefaultDeclaration(defineConfigCall));
  }
  const configImport = t3.importDeclaration(
    [t3.importSpecifier(t3.identifier(methodName), t3.identifier(methodName))],
    t3.stringLiteral(frameworkPackage + `${configType === "main" ? "/node" : ""}`)
  );
  const existingImport = programNode.body.find(
    (node) => t3.isImportDeclaration(node) && node.importKind !== "type" && node.source.value === configImport.source.value
  );
  if (existingImport && t3.isImportDeclaration(existingImport)) {
    const hasMethodName = existingImport.specifiers.some(
      (specifier) => t3.isImportSpecifier(specifier) && t3.isIdentifier(specifier.imported) && specifier.imported.name === methodName
    );
    if (!hasMethodName) {
      existingImport.specifiers.push(
        t3.importSpecifier(t3.identifier(methodName), t3.identifier(methodName))
      );
    }
  } else {
    programNode.body.unshift(configImport);
  }
  const disallowList2 = ["StorybookConfig", "Preview"];
  programNode.body = cleanupTypeImports(programNode, disallowList2);
  const output = printConfig(config).code;
  if (dryRun) {
    logger4.log(`Would write to ${import_picocolors6.default.yellow(info.path)}:
${import_picocolors6.default.green(output)}`);
    return info.source;
  }
  return skipFormatting ? output : formatFileContent2(info.path, output);
}
__name(configToCsfFactory, "configToCsfFactory");

// src/codemod/helpers/story-to-csf-factory.ts
import { types as t4, traverse as traverse2 } from "storybook/internal/babel";
import { isValidPreviewPath, loadCsf, printCsf } from "storybook/internal/csf-tools";
import { logger as logger5 } from "storybook/internal/node-logger";
import path2 from "path";
var reuseDisallowList = ["play", "run", "extends", "story"];
var typesDisallowList = [
  "Story",
  "StoryFn",
  "StoryObj",
  "Meta",
  "MetaObj",
  "ComponentStory",
  "ComponentMeta"
];
async function storyToCsfFactory(info, { previewConfigPath, useSubPathImports }) {
  const csf = loadCsf(info.source, { makeTitle: /* @__PURE__ */ __name(() => "FIXME", "makeTitle") });
  try {
    csf.parse();
  } catch (err) {
    logger5.log(`Error when parsing ${info.path}, skipping:
${err}`);
    return info.source;
  }
  const detectedStories = csf.stories;
  const detectedStoryNames = detectedStories.map((story) => story.name);
  const transformedStoryExports = /* @__PURE__ */ new Set();
  const metaVariableName = csf._metaVariableName ?? "meta";
  const programNode = csf._ast.program;
  let previewImport;
  const hasRootLevelConfig = programNode.body.some(
    (n) => t4.isVariableDeclaration(n) && n.declarations.some((declaration) => t4.isIdentifier(declaration.id, { name: "preview" }))
  );
  let previewPath = "#.storybook/preview";
  if (!useSubPathImports) {
    const relativePath = path2.relative(path2.dirname(info.path), previewConfigPath);
    const { dir, name } = path2.parse(relativePath);
    previewPath = `${dir ? `${dir}/` : ""}${name}`;
    if (!previewPath.startsWith(".")) {
      previewPath = `./${previewPath}`;
    }
    previewPath = previewPath.replace(/\\/g, "/");
  }
  let sbConfigImportName = hasRootLevelConfig ? "storybookPreview" : "preview";
  const sbConfigImportSpecifier = t4.importDefaultSpecifier(t4.identifier(sbConfigImportName));
  programNode.body.forEach((node) => {
    if (t4.isImportDeclaration(node) && isValidPreviewPath(node.source.value)) {
      const defaultImportSpecifier = node.specifiers.find(
        (specifier) => t4.isImportDefaultSpecifier(specifier)
      );
      if (!defaultImportSpecifier) {
        node.specifiers.push(sbConfigImportSpecifier);
      } else if (defaultImportSpecifier.local.name !== sbConfigImportName) {
        sbConfigImportName = defaultImportSpecifier.local.name;
      }
      previewImport = node;
    }
  });
  const hasMeta = !!csf._meta;
  Object.entries(csf._storyExports).forEach(([exportName, decl]) => {
    const id = decl.id;
    const declarator = decl;
    let init = t4.isVariableDeclarator(declarator) ? declarator.init : void 0;
    if (t4.isIdentifier(id) && init) {
      if (id.typeAnnotation) {
        id.typeAnnotation = null;
      }
      if (t4.isTSSatisfiesExpression(init) || t4.isTSAsExpression(init)) {
        init = init.expression;
      }
      if (t4.isObjectExpression(init)) {
        declarator.init = t4.callExpression(
          t4.memberExpression(t4.identifier(metaVariableName), t4.identifier("story")),
          init.properties.length === 0 ? [] : [init]
        );
        if (t4.isIdentifier(id)) {
          transformedStoryExports.add(exportName);
        }
      } else if (t4.isArrowFunctionExpression(init)) {
        declarator.init = t4.callExpression(
          t4.memberExpression(t4.identifier(metaVariableName), t4.identifier("story")),
          [init]
        );
        if (t4.isIdentifier(id)) {
          transformedStoryExports.add(exportName);
        }
      }
    }
  });
  Object.entries(csf._storyExports).forEach(([exportName, decl]) => {
    if (t4.isFunctionDeclaration(decl) && decl.id) {
      const arrowFn = t4.arrowFunctionExpression(decl.params, decl.body);
      arrowFn.async = !!decl.async;
      const wrappedCall = t4.callExpression(
        t4.memberExpression(t4.identifier(metaVariableName), t4.identifier("story")),
        [arrowFn]
      );
      const replacement = t4.exportNamedDeclaration(
        t4.variableDeclaration("const", [
          t4.variableDeclarator(t4.identifier(exportName), wrappedCall)
        ])
      );
      const pathForExport = csf._storyPaths?.[exportName];
      if (pathForExport && pathForExport.replaceWith) {
        pathForExport.replaceWith(replacement);
        transformedStoryExports.add(exportName);
      }
    }
  });
  const storyExportDecls = new Map(
    Object.entries(csf._storyExports).filter(
      (entry) => !t4.isFunctionDeclaration(entry[1])
    )
  );
  traverse2(csf._ast, {
    Identifier(nodePath) {
      const identifierName = nodePath.node.name;
      const binding = nodePath.scope.getBinding(identifierName);
      const isStoryExport = binding && storyExportDecls.has(binding.identifier.name);
      const isMetaVariable = identifierName === metaVariableName;
      if (isStoryExport || isMetaVariable) {
        const parent = nodePath.parent;
        if (t4.isVariableDeclarator(parent) && parent.id === nodePath.node) {
          return;
        }
        if (t4.isImportSpecifier(parent)) {
          return;
        }
        if (t4.isExportSpecifier(parent) || t4.isExportDefaultDeclaration(parent)) {
          return;
        }
        if (t4.isMemberExpression(parent) && t4.isIdentifier(parent.property, { name: "input" })) {
          return;
        }
        if (t4.isMemberExpression(parent) && t4.isIdentifier(parent.property) && reuseDisallowList.includes(parent.property.name)) {
          return;
        }
        try {
          nodePath.replaceWith(
            t4.memberExpression(t4.identifier(identifierName), t4.identifier("input"))
          );
        } catch (err) {
          if (err.message.includes(`instead got "MemberExpression"`)) {
            return;
          } else {
            throw err;
          }
        }
      }
    }
  });
  if (transformedStoryExports.size === 0) {
    logger5.warn(
      `Skipping codemod for ${info.path}: no stories were transformed. Either there are no stories, file has been already transformed or some stories are written in an unsupported format.`
    );
    return info.source;
  }
  if (detectedStoryNames.length > 0 && transformedStoryExports.size !== detectedStoryNames.length) {
    logger5.warn(
      `Skipping codemod for ${info.path}:
Some of the detected stories [${detectedStoryNames.map((name) => `"${name}"`).join(", ")}] would not be transformed because they are written in an unsupported format.`
    );
    return info.source;
  }
  if (csf._metaPath) {
    let declaration = csf._metaPath.node.declaration;
    if (t4.isTSSatisfiesExpression(declaration) || t4.isTSAsExpression(declaration)) {
      declaration = declaration.expression;
    }
    if (t4.isObjectExpression(declaration)) {
      const metaVariable = t4.variableDeclaration("const", [
        t4.variableDeclarator(
          t4.identifier(metaVariableName),
          t4.callExpression(
            t4.memberExpression(t4.identifier(sbConfigImportName), t4.identifier("meta")),
            [declaration]
          )
        )
      ]);
      csf._metaPath.replaceWith(metaVariable);
    } else if (t4.isIdentifier(declaration)) {
      const binding = csf._metaPath.scope.getBinding(declaration.name);
      if (binding && binding.path.isVariableDeclarator()) {
        const originalName = declaration.name;
        binding.path.node.id = t4.identifier(metaVariableName);
        let init = binding.path.node.init;
        if (t4.isTSSatisfiesExpression(init) || t4.isTSAsExpression(init)) {
          init = init.expression;
        }
        if (t4.isObjectExpression(init)) {
          binding.path.node.init = t4.callExpression(
            t4.memberExpression(t4.identifier(sbConfigImportName), t4.identifier("meta")),
            [init]
          );
        }
        csf._metaPath.scope.rename(originalName, metaVariableName);
      }
      csf._metaPath.remove();
    }
  }
  if (previewImport) {
    if (previewImport.source.value !== previewPath) {
      previewImport.source = t4.stringLiteral(previewPath);
    }
  } else if (hasMeta) {
    const configImport = t4.importDeclaration(
      [t4.importDefaultSpecifier(t4.identifier(sbConfigImportName))],
      t4.stringLiteral(previewPath)
    );
    programNode.body.unshift(configImport);
  }
  programNode.body.forEach((node, index) => {
    if (t4.isTSTypeAliasDeclaration(node)) {
      const isUsed = programNode.body.some((otherNode) => {
        if (t4.isVariableDeclaration(otherNode)) {
          return otherNode.declarations.some(
            (declaration) => t4.isIdentifier(declaration.init) && declaration.init.name === node.id.name
          );
        }
        return false;
      });
      if (!isUsed) {
        programNode.body.splice(index, 1);
      }
    }
  });
  programNode.body = cleanupTypeImports(programNode, typesDisallowList);
  return printCsf(csf).code;
}
__name(storyToCsfFactory, "storyToCsfFactory");

// src/codemod/csf-factories.ts
async function runStoriesCodemod(options) {
  const { dryRun, packageManager, ...codemodOptions } = options;
  try {
    let globString = "{stories,src}/**/{Button,Header,Page}.stories.*";
    if (!optionalEnvToBoolean(process.env.IN_STORYBOOK_SANDBOX)) {
      logger6.log("Please enter the glob for your stories to migrate");
      globString = await prompt2.text({
        message: "glob",
        initialValue: "**/*.stories.*"
      });
    }
    logger6.log("\n\u{1F6E0}\uFE0F  Applying codemod on your stories, this might take some time...");
    await packageManager.executeCommand({
      command: packageManager.getRemoteRunCommand("storybook", [
        "migrate",
        "csf-2-to-3",
        `--glob='${globString}'`
      ]),
      args: [],
      stdio: "ignore",
      ignoreError: true
    });
    await runCodemod(globString, (info) => storyToCsfFactory(info, codemodOptions), {
      dryRun
    });
  } catch (err) {
    if (err.message === "No files matched") {
      await runStoriesCodemod(options);
    } else {
      throw err;
    }
  }
}
__name(runStoriesCodemod, "runStoriesCodemod");
var csfFactories = {
  id: "csf-factories",
  promptType: "command",
  async run({ dryRun, mainConfig, mainConfigPath, previewConfigPath, packageManager, configDir }) {
    let useSubPathImports = true;
    if (!optionalEnvToBoolean(process.env.IN_STORYBOOK_SANDBOX)) {
      logger6.logBox(dedent3`
        The CSF Factories format can benefit from using absolute imports of your ${import_picocolors7.default.cyan(previewConfigPath)} file. We can configure that for you, using subpath imports (a node standard), by adjusting the imports property of your package.json.
        
        However, we cannot broadly recommend it for all projects, because it might not work in some monorepo setups or if you have an outdated tsconfig, use custom paths, or have type alias plugins configured in your project. You can always rerun this codemod and select another option to update your code later.
        
        More info: ${import_picocolors7.default.yellow("https://storybook.js.org/docs/10/api/csf/csf-next#subpath-imports?ref=upgrade")}
      `);
      useSubPathImports = await prompt2.select({
        message: "Which import type would you like to use for your story files?",
        options: [
          {
            label: "Relative imports (import preview from '../../.storybook/preview')",
            value: false
          },
          { label: "Subpath imports (import preview from '#.storybook/preview')", value: true }
        ]
      });
    }
    const { packageJson } = packageManager.primaryPackageJson;
    if (useSubPathImports && !packageJson.imports?.["#*"]) {
      logger6.log(
        `\u{1F5FA}\uFE0F Adding imports map in ${import_picocolors7.default.cyan(packageManager.primaryPackageJson.packageJsonPath)}`
      );
      packageJson.imports = {
        ...packageJson.imports,
        // @ts-expect-error we need to upgrade type-fest
        "#*": ["./*", "./*.ts", "./*.tsx", "./*.js", "./*.jsx"]
      };
      packageManager.writePackageJson(packageJson);
    }
    await runStoriesCodemod({
      dryRun,
      packageManager,
      useSubPathImports,
      previewConfigPath
    });
    logger6.log("\n\u{1F6E0}\uFE0F  Applying codemod on your main config...");
    const frameworkPackage = getFrameworkPackageName(mainConfig) || "@storybook/your-framework-here";
    await runCodemod(
      mainConfigPath,
      (fileInfo) => configToCsfFactory(fileInfo, { configType: "main", frameworkPackage }, { dryRun })
    );
    logger6.log("\n\u{1F6E0}\uFE0F  Applying codemod on your preview config...");
    await runCodemod(
      previewConfigPath,
      (fileInfo) => configToCsfFactory(fileInfo, { configType: "preview", frameworkPackage }, { dryRun })
    );
    await syncStorybookAddons2(mainConfig, previewConfigPath, configDir);
    logger6.logBox(
      dedent3`
          You can now run Storybook with the new CSF factories format.
          
          For more info, check out the docs:
          ${import_picocolors7.default.yellow("https://storybook.js.org/docs/10/api/csf/csf-next?ref=upgrade")}
        `
    );
  }
};

// src/automigrate/fixes/addon-a11y-addon-test.ts
var import_picocolors8 = __toESM(require_picocolors(), 1);
import { formatFileContent as formatFileContent3, getAddonNames } from "storybook/internal/common";
import { formatConfig, loadConfig as loadConfig2 } from "storybook/internal/csf-tools";
import { existsSync, readFileSync, writeFileSync } from "fs";
import jscodeshift from "jscodeshift";
import path3 from "path";
import { dedent as dedent4 } from "ts-dedent";

// ../../core/src/component-testing/constants.ts
var ADDON_ID = "storybook/interactions";
var PANEL_ID = `${ADDON_ID}/panel`;
var DOCUMENTATION_LINK = "writing-tests/integrations/vitest-addon";
var DOCUMENTATION_DISCREPANCY_LINK = `${DOCUMENTATION_LINK}#what-happens-when-there-are-different-test-results-in-multiple-environments`;

// ../../addons/a11y/src/constants.ts
var ADDON_ID2 = "storybook/a11y";
var PANEL_ID2 = `${ADDON_ID2}/panel`;
var UI_STATE_ID = `${ADDON_ID2}/ui`;
var RESULT = `${ADDON_ID2}/result`;
var REQUEST = `${ADDON_ID2}/request`;
var RUNNING = `${ADDON_ID2}/running`;
var ERROR = `${ADDON_ID2}/error`;
var MANUAL = `${ADDON_ID2}/manual`;
var SELECT = `${ADDON_ID2}/select`;
var DOCUMENTATION_LINK2 = "writing-tests/accessibility-testing";
var DOCUMENTATION_DISCREPANCY_LINK2 = `${DOCUMENTATION_LINK2}#why-are-my-tests-failing-in-different-environments`;

// ../../addons/vitest/src/constants.ts
var ADDON_ID3 = "storybook/test";
var TEST_PROVIDER_ID = `${ADDON_ID3}/test-provider`;
var DOCUMENTATION_LINK3 = "writing-tests/integrations/vitest-addon";
var DOCUMENTATION_FATAL_ERROR_LINK = `${DOCUMENTATION_LINK3}#what-happens-if-vitest-itself-has-an-error`;
var SUPPORTED_FRAMEWORKS = [
  "@storybook/nextjs",
  "@storybook/nextjs-vite",
  "@storybook/react-vite",
  "@storybook/preact-vite",
  "@storybook/svelte-vite",
  "@storybook/vue3-vite",
  "@storybook/html-vite",
  "@storybook/web-components-vite",
  "@storybook/sveltekit",
  "@storybook/react-native-web-vite"
];
var storeOptions = {
  id: ADDON_ID3,
  initialState: {
    config: {
      coverage: false,
      a11y: false
    },
    watching: false,
    cancelling: false,
    fatalError: void 0,
    indexUrl: void 0,
    previewAnnotations: [],
    currentRun: {
      triggeredBy: void 0,
      config: {
        coverage: false,
        a11y: false
      },
      componentTestCount: {
        success: 0,
        error: 0
      },
      a11yCount: {
        success: 0,
        warning: 0,
        error: 0
      },
      storyIds: void 0,
      totalTestCount: void 0,
      startedAt: void 0,
      finishedAt: void 0,
      unhandledErrors: [],
      coverageSummary: void 0
    }
  }
};
var STORE_CHANNEL_EVENT_NAME = `UNIVERSAL_STORE:${storeOptions.id}`;

// src/automigrate/fixes/addon-a11y-addon-test.ts
var fileExtensions = [
  ".js",
  ".ts",
  ".cts",
  ".mts",
  ".cjs",
  ".mjs",
  ".jsx",
  ".tsx"
];
var addonA11yAddonTest = {
  id: "addon-a11y-addon-test",
  link: "https://storybook.js.org/docs/writing-tests/accessibility-testing#test-addon-integration",
  promptType: "auto",
  async check({ mainConfig, configDir }) {
    const addons = getAddonNames(mainConfig);
    const frameworkPackageName = getFrameworkPackageName(mainConfig);
    const hasA11yAddon = !!addons.find((addon) => addon.includes("@storybook/addon-a11y"));
    const hasTestAddon = !!addons.find((addon) => addon.includes("@storybook/addon-vitest"));
    if (!SUPPORTED_FRAMEWORKS.find((framework) => frameworkPackageName?.includes(framework))) {
      return null;
    }
    if (!hasA11yAddon || !hasTestAddon || !configDir) {
      return null;
    }
    const vitestSetupFile = fileExtensions.map((ext) => path3.join(configDir, `vitest.setup${ext}`)).find((filePath) => existsSync(filePath)) ?? null;
    const previewFile = fileExtensions.map((ext) => path3.join(configDir, `preview${ext}`)).find((filePath) => existsSync(filePath)) ?? null;
    let skipVitestSetupTransformation = false;
    let skipPreviewTransformation = false;
    if (vitestSetupFile && previewFile) {
      const vitestSetupSource = readFileSync(vitestSetupFile, "utf8");
      const previewSetupSource = readFileSync(previewFile, "utf8");
      skipVitestSetupTransformation = vitestSetupSource.includes("@storybook/addon-a11y");
      skipPreviewTransformation = !shouldPreviewFileBeTransformed(previewSetupSource);
      if (skipVitestSetupTransformation && skipPreviewTransformation) {
        return null;
      }
    }
    const getTransformedSetupCode = /* @__PURE__ */ __name(() => {
      if (!vitestSetupFile || skipVitestSetupTransformation) {
        return null;
      }
      try {
        const vitestSetupSource = readFileSync(vitestSetupFile, "utf8");
        return transformSetupFile(vitestSetupSource);
      } catch (e) {
        return null;
      }
    }, "getTransformedSetupCode");
    const getTransformedPreviewCode = /* @__PURE__ */ __name(() => {
      if (!previewFile || skipPreviewTransformation) {
        return null;
      }
      try {
        const previewSetupSource = readFileSync(previewFile, "utf8");
        return transformPreviewFile(previewSetupSource, previewFile);
      } catch (e) {
        return null;
      }
    }, "getTransformedPreviewCode");
    return {
      setupFile: vitestSetupFile,
      previewFile,
      transformedSetupCode: getTransformedSetupCode(),
      transformedPreviewCode: await getTransformedPreviewCode(),
      skipVitestSetupTransformation,
      skipPreviewTransformation
    };
  },
  prompt() {
    return "We have detected that you have @storybook/addon-a11y and @storybook/addon-vitest installed. The automigration will configure both for the new testing experience in Storybook 9";
  },
  async run({ result }) {
    let counter = 1;
    const {
      transformedSetupCode,
      skipPreviewTransformation,
      skipVitestSetupTransformation,
      setupFile,
      previewFile,
      transformedPreviewCode
    } = result;
    const errorMessage = [];
    if (!skipVitestSetupTransformation) {
      if (transformedSetupCode === null) {
        errorMessage.push(dedent4`
          ${counter++}) We couldn't find or automatically update ${import_picocolors8.default.cyan(`.storybook/vitest.setup.<ts|js>`)} in your project to smoothly set up project annotations from ${import_picocolors8.default.magenta(`@storybook/addon-a11y`)}. 
          Please manually update your ${import_picocolors8.default.cyan(`vitest.setup.ts`)} file to include the following:

          ${import_picocolors8.default.gray("...")}   
          ${import_picocolors8.default.green('+ import * as a11yAddonAnnotations from "@storybook/addon-a11y/preview";')}

          ${import_picocolors8.default.gray("setProjectAnnotations([")}
          ${import_picocolors8.default.gray("  ...")}
          ${import_picocolors8.default.green("+ a11yAddonAnnotations,")}
          ${import_picocolors8.default.gray("]);")}
        `);
      }
    }
    if (!skipPreviewTransformation) {
      if (transformedPreviewCode === null) {
        errorMessage.push(dedent4`
          ${counter++}) We couldn't find or automatically update your .storybook/preview.<ts|js> in your project to smoothly set up ${import_picocolors8.default.cyan("parameters.a11y.test")} from @storybook/addon-a11y. Please manually update your .storybook/preview.<ts|js> file to include the following:

          ${import_picocolors8.default.gray("export default {")}
          ${import_picocolors8.default.gray("  ...")}
          ${import_picocolors8.default.gray("  parameters: {")}
          ${import_picocolors8.default.green("+   a11y: {")}
          ${import_picocolors8.default.gray('+      test: "todo"')}
          ${import_picocolors8.default.green("+   }")}
          ${import_picocolors8.default.gray("  }")}
          ${import_picocolors8.default.gray("}")}
        `);
      }
    }
    if (errorMessage.length > 0) {
      throw new Error(
        dedent4`The ${this.id} automigration couldn't make the changes but here are instructions for doing them yourself:\n${errorMessage.join("\n")}`
      );
    }
    if (transformedSetupCode && setupFile) {
      writeFileSync(setupFile, transformedSetupCode, "utf8");
    }
    if (transformedPreviewCode && previewFile) {
      writeFileSync(previewFile, transformedPreviewCode, "utf8");
    }
  }
};
function transformSetupFile(source) {
  const j = jscodeshift.withParser("ts");
  const root = j(source);
  const importDeclaration = j.importDeclaration(
    [j.importNamespaceSpecifier(j.identifier("a11yAddonAnnotations"))],
    j.literal("@storybook/addon-a11y/preview")
  );
  const setProjectAnnotationsCall = root.find(j.CallExpression, {
    callee: {
      type: "Identifier",
      name: "setProjectAnnotations"
    }
  });
  if (setProjectAnnotationsCall.length === 0) {
    throw new Error("Could not find setProjectAnnotations call in vitest.setup file");
  }
  setProjectAnnotationsCall.forEach((p) => {
    if (p.value.arguments.length === 1 && p.value.arguments[0].type === "ArrayExpression") {
      p.value.arguments[0].elements.unshift(j.identifier("a11yAddonAnnotations"));
    } else if (p.value.arguments.length === 1 && p.value.arguments[0].type === "Identifier") {
      const arg = p.value.arguments[0];
      p.value.arguments[0] = j.arrayExpression([j.identifier("a11yAddonAnnotations"), arg]);
    }
  });
  root.get().node.program.body.unshift(importDeclaration);
  return root.toSource();
}
__name(transformSetupFile, "transformSetupFile");
function transformPreviewFile(source, filePath) {
  if (!shouldPreviewFileBeTransformed(source)) {
    return source;
  }
  const previewConfig = loadConfig2(source).parse();
  previewConfig.setFieldValue(["parameters", "a11y", "test"], "todo");
  const formattedPreviewConfig = formatConfig(previewConfig);
  const lines = formattedPreviewConfig.split("\n");
  const parametersLineIndex = lines.findIndex(
    (line) => line.includes('test: "todo"') || line.includes("test: 'todo'")
  );
  if (parametersLineIndex === -1) {
    return formattedPreviewConfig;
  }
  const parametersLine = lines[parametersLineIndex];
  const indentation = parametersLine?.match(/^\s*/)?.[0];
  const comment = `${indentation}// 'todo' - show a11y violations in the test UI only
${indentation}// 'error' - fail CI on a11y violations
${indentation}// 'off' - skip a11y checks entirely`;
  lines.splice(parametersLineIndex, 0, comment);
  return formatFileContent3(filePath, lines.join("\n"));
}
__name(transformPreviewFile, "transformPreviewFile");
function shouldPreviewFileBeTransformed(source) {
  const previewConfig = loadConfig2(source).parse();
  const parametersA11yTest = previewConfig.getFieldNode(["parameters", "a11y", "test"]);
  if (parametersA11yTest) {
    return false;
  }
  return true;
}
__name(shouldPreviewFileBeTransformed, "shouldPreviewFileBeTransformed");

// src/automigrate/fixes/addon-a11y-parameters.ts
var import_picocolors9 = __toESM(require_picocolors(), 1);
import { readFile } from "node:fs/promises";
import { writeConfig as writeConfig2, writeCsf } from "storybook/internal/csf-tools";
import { logger as logger7 } from "storybook/internal/node-logger";
import { dedent as dedent5 } from "ts-dedent";

// src/automigrate/helpers/addon-a11y-parameters.ts
import { types as t6 } from "storybook/internal/babel";
import { loadConfig as loadConfig3, loadCsf as loadCsf2 } from "storybook/internal/csf-tools";

// src/automigrate/helpers/ast-utils.ts
import { types as t5 } from "storybook/internal/babel";
function getObjectProperty(obj, propertyName) {
  if (!obj || !obj.properties) {
    return void 0;
  }
  const property = obj.properties.find(
    (prop) => t5.isObjectProperty(prop) && (t5.isIdentifier(prop.key) && prop.key.name === propertyName || t5.isStringLiteral(prop.key) && prop.key.value === propertyName)
  );
  return property?.value;
}
__name(getObjectProperty, "getObjectProperty");
function removeProperty(obj, propertyName) {
  if (!obj || !obj.properties) {
    return;
  }
  const index = obj.properties.findIndex(
    (prop) => t5.isObjectProperty(prop) && (t5.isIdentifier(prop.key) && prop.key.name === propertyName || t5.isStringLiteral(prop.key) && prop.key.value === propertyName)
  );
  if (index !== -1) {
    obj.properties.splice(index, 1);
  }
}
__name(removeProperty, "removeProperty");
function addProperty(obj, propertyName, value) {
  if (!obj || !obj.properties) {
    return;
  }
  obj.properties.push(t5.objectProperty(t5.identifier(propertyName), value));
}
__name(addProperty, "addProperty");
function getStoryObject(declaration) {
  if (t5.isVariableDeclarator(declaration)) {
    let init = declaration.init;
    if (t5.isTSSatisfiesExpression(init) || t5.isTSAsExpression(init)) {
      init = init.expression;
    }
    if (t5.isObjectExpression(init)) {
      return init;
    }
  } else if (t5.isExportDefaultDeclaration(declaration)) {
    let init = declaration.declaration;
    if (t5.isTSSatisfiesExpression(init) || t5.isTSAsExpression(init)) {
      init = init.expression;
    }
    if (t5.isObjectExpression(init)) {
      return init;
    }
  }
  return void 0;
}
__name(getStoryObject, "getStoryObject");
function transformValuesToOptions(valuesArray) {
  const optionsObject = t5.objectExpression([]);
  if (valuesArray && t5.isArrayExpression(valuesArray) && valuesArray.elements) {
    valuesArray.elements.forEach((element) => {
      if (t5.isObjectExpression(element)) {
        const nameProperty = getObjectProperty(element, "name");
        if (t5.isStringLiteral(nameProperty)) {
          const key = nameProperty.value.toLowerCase().replace(/\s+/g, "_");
          const keyNode = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? t5.identifier(key) : t5.stringLiteral(nameProperty.value);
          optionsObject.properties.push(t5.objectProperty(keyNode, element));
        }
      }
    });
  }
  return optionsObject;
}
__name(transformValuesToOptions, "transformValuesToOptions");
function getKeyFromName(valuesArray, name) {
  if (valuesArray && t5.isArrayExpression(valuesArray) && valuesArray.elements) {
    for (const element of valuesArray.elements) {
      if (t5.isObjectExpression(element)) {
        const nameProperty = getObjectProperty(element, "name");
        if (t5.isStringLiteral(nameProperty) && nameProperty.value === name) {
          return name.toLowerCase().replace(/\s+/g, "_");
        }
      }
    }
  }
  return name.toLowerCase().replace(/\s+/g, "_");
}
__name(getKeyFromName, "getKeyFromName");
function transformStories(csf, transformCallback, options = { includeMeta: true, includeStories: true }) {
  let hasChanges = false;
  if (options.includeStories) {
    Object.entries(csf._storyExports).forEach(([storyName, declaration]) => {
      const storyObject = getStoryObject(declaration);
      if (storyObject) {
        if (transformCallback(storyObject, storyName, csf)) {
          hasChanges = true;
        }
      }
    });
  }
  if (options.includeMeta && csf._metaPath) {
    const storyObject = getStoryObject(csf._metaPath.node);
    if (storyObject) {
      if (transformCallback(storyObject, "meta", csf)) {
        hasChanges = true;
      }
    }
  }
  return hasChanges;
}
__name(transformStories, "transformStories");
function transformStoryParameters(csf, transformParameters, options = { includeMeta: true, includeStories: true }) {
  return transformStories(
    csf,
    (storyObject, storyName, csf2) => {
      const parameters = getObjectProperty(storyObject, "parameters");
      if (parameters) {
        return transformParameters(parameters, storyObject, storyName, csf2);
      }
      return false;
    },
    options
  );
}
__name(transformStoryParameters, "transformStoryParameters");

// src/automigrate/helpers/addon-a11y-parameters.ts
var isStoryAnnotation = /* @__PURE__ */ __name((stmt, objectExports) => t6.isExpressionStatement(stmt) && t6.isAssignmentExpression(stmt.expression) && t6.isMemberExpression(stmt.expression.left) && t6.isIdentifier(stmt.expression.left.object) && objectExports[stmt.expression.left.object.name], "isStoryAnnotation");
function migrateA11yParameters(obj) {
  const parametersValue = getObjectProperty(obj, "parameters");
  if (parametersValue) {
    const a11yValue = getObjectProperty(parametersValue, "a11y");
    if (a11yValue) {
      const elementProp = a11yValue.properties.find(
        (prop) => t6.isObjectProperty(prop) && t6.isIdentifier(prop.key) && prop.key.name === "element"
      );
      if (elementProp && t6.isObjectProperty(elementProp)) {
        elementProp.key = t6.identifier("context");
        return true;
      }
    }
  }
  return false;
}
__name(migrateA11yParameters, "migrateA11yParameters");
function transformStoryA11yParameters(code) {
  const parsed = loadCsf2(code, { makeTitle: /* @__PURE__ */ __name((title) => title || "default", "makeTitle") }).parse();
  let hasChanges = transformStories(parsed, (storyObject, storyName, csf) => {
    return migrateA11yParameters(storyObject);
  });
  parsed._ast.program.body.forEach((stmt) => {
    const statement = stmt;
    if (isStoryAnnotation(statement, parsed._storyExports) && t6.isExpressionStatement(statement) && t6.isAssignmentExpression(statement.expression) && t6.isObjectExpression(statement.expression.right)) {
      const parameters = statement.expression.right.properties;
      parameters.forEach((param) => {
        if (t6.isObjectProperty(param) && t6.isIdentifier(param.key) && param.key.name === "a11y") {
          const a11yValue = param.value;
          const elementProp = a11yValue.properties.find(
            (prop) => t6.isObjectProperty(prop) && t6.isIdentifier(prop.key) && prop.key.name === "element"
          );
          if (elementProp && t6.isObjectProperty(elementProp)) {
            elementProp.key = t6.identifier("context");
            hasChanges = true;
          }
        }
      });
    }
  });
  return hasChanges ? parsed : null;
}
__name(transformStoryA11yParameters, "transformStoryA11yParameters");
function transformPreviewA11yParameters(code) {
  const parsed = loadConfig3(code).parse();
  if (parsed._exportsObject && t6.isObjectExpression(parsed._exportsObject)) {
    if (migrateA11yParameters(parsed._exportsObject)) {
      return parsed;
    }
  }
  return null;
}
__name(transformPreviewA11yParameters, "transformPreviewA11yParameters");

// src/automigrate/fixes/addon-a11y-parameters.ts
var addonA11yParameters = {
  id: "addon-a11y-parameters",
  link: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#a11y-addon-replace-element-parameter-with-context-parameter",
  check: /* @__PURE__ */ __name(async ({ mainConfig, previewConfigPath, storiesPaths }) => {
    const hasA11yAddon = mainConfig.addons?.some(
      (addon) => typeof addon === "string" ? addon === "@storybook/addon-a11y" : addon.name === "@storybook/addon-a11y"
    );
    if (!hasA11yAddon) {
      return null;
    }
    const maybeHasA11yParameter = /* @__PURE__ */ __name((content) => content.includes("a11y:") && content.includes("element:"), "maybeHasA11yParameter");
    const storyFilesWithA11y = (await Promise.all(
      storiesPaths.map(async (file) => {
        const content = await readFile(file, "utf-8");
        return maybeHasA11yParameter(content) ? file : null;
      })
    )).filter((file) => file !== null);
    let hasA11yConfigInPreview = false;
    if (previewConfigPath) {
      const content = await readFile(previewConfigPath, "utf-8");
      hasA11yConfigInPreview = maybeHasA11yParameter(content);
    }
    if (storyFilesWithA11y.length === 0 && !hasA11yConfigInPreview) {
      return null;
    }
    return {
      storyFilesToUpdate: storyFilesWithA11y,
      previewFileToUpdate: hasA11yConfigInPreview ? previewConfigPath : void 0
    };
  }, "check"),
  prompt: /* @__PURE__ */ __name(() => {
    return dedent5`
      The a11y addon has replaced ${import_picocolors9.default.yellow("parameters.a11y.element")} with ${import_picocolors9.default.yellow("parameters.a11y.context")} for more flexible accessibility check scoping.
    `;
  }, "prompt"),
  run: /* @__PURE__ */ __name(async (options) => {
    const { result, dryRun = false } = options;
    const { storyFilesToUpdate, previewFileToUpdate } = result;
    const errors = [];
    if (previewFileToUpdate) {
      const content = await readFile(previewFileToUpdate, "utf-8");
      const code = transformPreviewA11yParameters(content);
      if (code) {
        if (!dryRun) {
          try {
            await writeConfig2(code, previewFileToUpdate);
          } catch (error) {
            errors.push({ file: previewFileToUpdate, error });
          }
        } else {
          logger7.log(`Would have updated ${code.fileName}`);
        }
      }
    }
    const { default: pLimit } = await import("./p-limit-OEC3Z6OA.js");
    const limit = pLimit(10);
    await Promise.all(
      storyFilesToUpdate.map(
        (file) => limit(async () => {
          try {
            const content = await readFile(file, "utf-8");
            const code = transformStoryA11yParameters(content);
            if (code) {
              if (!dryRun) {
                await writeCsf(code, file);
              } else {
                logger7.log(`Would have updated ${file}`);
              }
            }
          } catch (error) {
            errors.push({ file, error });
          }
        })
      )
    );
    if (errors.length > 0) {
      throw new Error(
        `Failed to process ${errors.length} files:
${errors.map(({ file, error }) => `- ${file}: ${error.message}`).join("\n")}`
      );
    }
  }, "run")
};

// src/automigrate/fixes/addon-experimental-test.ts
import { readFileSync as readFileSync2, writeFileSync as writeFileSync2 } from "fs";
var addonExperimentalTest = {
  id: "addon-experimental-test",
  link: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#experimental-test-addon-stabilized-and-renamed",
  promptType: "auto",
  async check({ packageManager }) {
    const isExperimentalAddonTestInstalled = await packageManager.isPackageInstalled(
      "@storybook/experimental-addon-test"
    );
    if (!isExperimentalAddonTestInstalled) {
      return null;
    }
    const matchingFiles = findFilesUp(
      [".storybook/**/*.*", "vitest.*.{js,ts,mjs,cjs}", "vite.config.{js,ts,mjs,cjs}"],
      packageManager.instanceDir
    );
    const filesWithExperimentalAddon = [];
    for (const file of matchingFiles) {
      try {
        const content = readFileSync2(file, "utf-8");
        if (content.includes("@storybook/experimental-addon-test")) {
          filesWithExperimentalAddon.push(file);
        }
      } catch (e) {
      }
    }
    return {
      matchingFiles: filesWithExperimentalAddon
    };
  },
  prompt() {
    return "We'll migrate @storybook/experimental-addon-test to @storybook/addon-vitest";
  },
  async run({ result: { matchingFiles }, packageManager, dryRun, storybookVersion }) {
    for (const file of matchingFiles) {
      const content = readFileSync2(file, "utf-8");
      let updatedContent = content.replace(
        /@storybook\/experimental-addon-test/g,
        "@storybook/addon-vitest"
      );
      if (file.includes("vitest.setup")) {
        updatedContent = updatedContent.replace(/^\s*beforeAll.*\n?/gm, "");
      }
      if (!dryRun) {
        writeFileSync2(file, updatedContent, "utf-8");
      }
    }
    if (!dryRun) {
      await packageManager.removeDependencies(["@storybook/experimental-addon-test"]);
      await packageManager.addDependencies({ type: "devDependencies", skipInstall: true }, [
        `@storybook/addon-vitest@${storybookVersion}`
      ]);
    }
  }
};

// src/automigrate/fixes/addon-globals-api.ts
import { readFile as readFile2, writeFile } from "node:fs/promises";
import { types as t7 } from "storybook/internal/babel";
import { formatConfig as formatConfig2, loadConfig as loadConfig4, loadCsf as loadCsf3, writeCsf as writeCsf2 } from "storybook/internal/csf-tools";
var addonGlobalsApi = {
  id: "addon-globals-api",
  link: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#viewportbackgrounds-addon-synchronized-configuration-and-globals-usage",
  async check({ previewConfigPath }) {
    if (!previewConfigPath) {
      return null;
    }
    const previewConfig = loadConfig4((await readFile2(previewConfigPath)).toString()).parse();
    const getFieldNode = previewConfig.getFieldNode.bind(previewConfig);
    const getFieldValue = previewConfig.getFieldValue.bind(previewConfig);
    const checkAddonMigration = /* @__PURE__ */ __name((addonName) => {
      const paramPath = ["parameters", addonName];
      const addonParams = getFieldNode(paramPath);
      if (!addonParams) {
        return { needsMigration: false };
      }
      const hasOptions = getFieldNode([...paramPath, "options"]) !== void 0;
      const fieldsToCheck = addonName === "viewport" ? ["viewports", "defaultViewport"] : ["values", "default", "disable"];
      const hasOldFormat = fieldsToCheck.some(
        (field) => getFieldNode([...paramPath, field]) !== void 0
      );
      const needsMigration = hasOldFormat && !hasOptions;
      const options = {};
      if (needsMigration) {
        fieldsToCheck.forEach((field) => {
          const value = addonName === "viewport" && field === "viewports" || addonName === "backgrounds" && field === "values" ? getFieldNode([...paramPath, field]) : getFieldValue([...paramPath, field]);
          if (value !== void 0) {
            const optionKey = addonName === "viewport" ? field : field;
            options[optionKey] = value;
          }
        });
      }
      return { needsMigration, options };
    }, "checkAddonMigration");
    const viewportMigration = checkAddonMigration("viewport");
    const backgroundsMigration = checkAddonMigration("backgrounds");
    if (!viewportMigration.needsMigration && !backgroundsMigration.needsMigration) {
      return null;
    }
    return {
      previewConfig,
      previewConfigPath,
      needsViewportMigration: viewportMigration.needsMigration,
      needsBackgroundsMigration: backgroundsMigration.needsMigration,
      viewportsOptions: viewportMigration.options,
      backgroundsOptions: backgroundsMigration.options
    };
  },
  prompt() {
    return "You're using a deprecated config API for viewport/backgrounds. The globals API will be used instead.";
  },
  async run({ dryRun = false, result, storiesPaths }) {
    const {
      previewConfig,
      needsViewportMigration,
      needsBackgroundsMigration,
      viewportsOptions,
      backgroundsOptions
    } = result;
    const getFieldNode = previewConfig.getFieldNode.bind(previewConfig);
    if (needsViewportMigration) {
      const viewports = getFieldNode(["parameters", "viewport", "viewports"]);
      if (viewportsOptions?.viewports) {
        previewConfig.removeField(["parameters", "viewport", "viewports"]);
        addProperty(
          getFieldNode(["parameters", "viewport"]),
          "options",
          viewports
        );
      }
      if (viewportsOptions?.defaultViewport) {
        const viewportNode = getFieldNode(["parameters", "viewport"]);
        removeProperty(viewportNode, "defaultViewport");
        previewConfig.setFieldValue(
          ["initialGlobals", "viewport", "value"],
          viewportsOptions.defaultViewport
        );
        previewConfig.setFieldValue(["initialGlobals", "viewport", "isRotated"], false);
      }
    }
    if (needsBackgroundsMigration) {
      if (backgroundsOptions?.values) {
        const optionsObject = transformValuesToOptions(
          backgroundsOptions.values
        );
        previewConfig.removeField(["parameters", "backgrounds", "values"]);
        addProperty(
          getFieldNode(["parameters", "backgrounds"]),
          "options",
          optionsObject
        );
      }
      if (backgroundsOptions?.default) {
        removeProperty(getFieldNode(["parameters", "backgrounds"]), "default");
        previewConfig.setFieldValue(
          ["initialGlobals", "backgrounds", "value"],
          getKeyFromName(backgroundsOptions.values, backgroundsOptions.default)
        );
      }
      if (backgroundsOptions?.disable === true) {
        removeProperty(getFieldNode(["parameters", "backgrounds"]), "disable");
        addProperty(
          getFieldNode(["parameters", "backgrounds"]),
          "disabled",
          t7.booleanLiteral(true)
        );
      }
    }
    if (!dryRun) {
      await writeFile(result.previewConfigPath, formatConfig2(previewConfig));
    }
    if (needsViewportMigration || needsBackgroundsMigration) {
      await transformStoryFiles(
        storiesPaths,
        {
          needsViewportMigration,
          needsBackgroundsMigration,
          viewportsOptions,
          backgroundsOptions
        },
        dryRun
      );
    }
  }
};
async function transformStoryFiles(files, options, dryRun) {
  const errors = [];
  const { default: pLimit } = await import("./p-limit-OEC3Z6OA.js");
  const limit = pLimit(10);
  await Promise.all(
    files.map(
      (file) => limit(async () => {
        try {
          const content = await readFile2(file, "utf-8");
          const transformed = transformStoryFile(content, options);
          if (transformed && !dryRun) {
            await writeCsf2(transformed, file);
          }
        } catch (error) {
          errors.push({ file, error });
        }
      })
    )
  );
  return errors;
}
__name(transformStoryFiles, "transformStoryFiles");
function transformStoryFile(source, options) {
  const { needsViewportMigration, needsBackgroundsMigration, backgroundsOptions } = options;
  const storyConfig = loadCsf3(source, {
    makeTitle: /* @__PURE__ */ __name((title) => title || "default", "makeTitle")
  }).parse();
  const hasChanges = transformStoryParameters(storyConfig, (parameters, storyObject) => {
    let newGlobals;
    let viewportParams;
    let backgroundsParams;
    let storyHasChanges = false;
    if (needsViewportMigration) {
      viewportParams = getObjectProperty(parameters, "viewport");
      if (viewportParams) {
        const defaultViewport = getObjectProperty(viewportParams, "defaultViewport");
        const defaultOrientation = getObjectProperty(viewportParams, "defaultOrientation");
        const disableViewport = getObjectProperty(viewportParams, "disable");
        let viewportValue = null;
        if (defaultViewport) {
          if (t7.isStringLiteral(defaultViewport)) {
            viewportValue = defaultViewport;
          } else if (t7.isMemberExpression(defaultViewport)) {
            viewportValue = defaultViewport;
          }
        }
        if (viewportValue) {
          if (!newGlobals) {
            newGlobals = t7.objectExpression([]);
          }
          let isRotated = false;
          if (defaultOrientation && t7.isStringLiteral(defaultOrientation)) {
            isRotated = defaultOrientation.value === "portrait";
          }
          newGlobals.properties.push(
            t7.objectProperty(
              t7.identifier("viewport"),
              t7.objectExpression([
                t7.objectProperty(t7.identifier("value"), viewportValue),
                t7.objectProperty(t7.identifier("isRotated"), t7.booleanLiteral(isRotated))
              ])
            )
          );
          removeProperty(viewportParams, "defaultViewport");
          storyHasChanges = true;
        }
        if (defaultOrientation) {
          removeProperty(viewportParams, "defaultOrientation");
          storyHasChanges = true;
        }
        if (disableViewport && t7.isBooleanLiteral(disableViewport)) {
          removeProperty(viewportParams, "disable");
          addProperty(viewportParams, "disabled", disableViewport);
          storyHasChanges = true;
        }
      }
    }
    if (needsBackgroundsMigration) {
      backgroundsParams = getObjectProperty(parameters, "backgrounds");
      if (backgroundsParams) {
        const defaultBackground = getObjectProperty(backgroundsParams, "default");
        const disableBackground = getObjectProperty(backgroundsParams, "disable");
        const valuesBackground = getObjectProperty(backgroundsParams, "values");
        if (valuesBackground && t7.isArrayExpression(valuesBackground)) {
          const optionsObject = transformValuesToOptions(valuesBackground);
          removeProperty(backgroundsParams, "values");
          addProperty(backgroundsParams, "options", optionsObject);
          storyHasChanges = true;
        }
        if (defaultBackground && t7.isStringLiteral(defaultBackground)) {
          if (!newGlobals) {
            newGlobals = t7.objectExpression([]);
          }
          const backgroundKey = getKeyFromName(
            backgroundsOptions?.values,
            defaultBackground.value
          );
          newGlobals.properties.push(
            t7.objectProperty(
              t7.identifier("backgrounds"),
              t7.objectExpression([
                t7.objectProperty(t7.identifier("value"), t7.stringLiteral(backgroundKey))
              ])
            )
          );
          removeProperty(backgroundsParams, "default");
          storyHasChanges = true;
        }
        if (disableBackground && t7.isBooleanLiteral(disableBackground)) {
          removeProperty(backgroundsParams, "disable");
          addProperty(backgroundsParams, "disabled", disableBackground);
          storyHasChanges = true;
        }
      }
    }
    if (newGlobals && newGlobals.properties.length > 0) {
      const existingGlobals = getObjectProperty(storyObject, "globals");
      if (existingGlobals) {
        newGlobals.properties.forEach((newGlobal) => {
          if (t7.isObjectProperty(newGlobal) && t7.isIdentifier(newGlobal.key)) {
            const globalName = newGlobal.key.name;
            const existingGlobal = getObjectProperty(existingGlobals, globalName);
            if (existingGlobal) {
              if (t7.isObjectExpression(newGlobal.value) && t7.isObjectExpression(existingGlobal)) {
                newGlobal.value.properties.forEach((newProp) => {
                  if (t7.isObjectProperty(newProp) && t7.isIdentifier(newProp.key)) {
                    const propName = newProp.key.name;
                    const existingProp = getObjectProperty(existingGlobal, propName);
                    if (!existingProp) {
                      existingGlobal.properties.push(newProp);
                    }
                  }
                });
              }
            } else {
              existingGlobals.properties.push(newGlobal);
            }
          }
        });
      } else {
        storyObject.properties.push(t7.objectProperty(t7.identifier("globals"), newGlobals));
      }
      storyHasChanges = true;
    }
    if (viewportParams && viewportParams.properties.length === 0) {
      removeProperty(parameters, "viewport");
      storyHasChanges = true;
    }
    if (backgroundsParams && backgroundsParams.properties.length === 0) {
      removeProperty(parameters, "backgrounds");
      storyHasChanges = true;
    }
    if (parameters.properties.length === 0) {
      removeProperty(storyObject, "parameters");
      storyHasChanges = true;
    }
    return storyHasChanges;
  });
  return hasChanges ? storyConfig : null;
}
__name(transformStoryFile, "transformStoryFile");

// src/automigrate/fixes/addon-mdx-gfm-remove.ts
import { getAddonNames as getAddonNames2, removeAddon } from "storybook/internal/common";
var addonMdxGfmRemove = {
  id: "addon-mdx-gfm-remove",
  link: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mdx-gfm-addon-removed",
  async check({ mainConfigPath, mainConfig, packageManager }) {
    if (!mainConfigPath) {
      return null;
    }
    try {
      const addonName = "@storybook/addon-mdx-gfm";
      const addonNames = getAddonNames2(mainConfig);
      const hasMdxGfm = addonNames.includes(addonName);
      const hasMdxGfmInDeps = packageManager.isDependencyInstalled(addonName);
      if (!hasMdxGfm && !hasMdxGfmInDeps) {
        return null;
      }
      return true;
    } catch (err) {
      return null;
    }
  },
  prompt() {
    return `We'll remove @storybook/addon-mdx-gfm as it's no longer needed in Storybook 9.0.`;
  },
  async run({ packageManager, configDir }) {
    await removeAddon("@storybook/addon-mdx-gfm", {
      configDir,
      skipInstall: true,
      packageManager
    });
  }
};

// src/automigrate/fixes/addon-storysource-code-panel.ts
import { getAddonNames as getAddonNames3, removeAddon as removeAddon2 } from "storybook/internal/common";
import { logger as logger8 } from "storybook/internal/node-logger";
import { dedent as dedent6 } from "ts-dedent";
var addonStorysourceCodePanel = {
  id: "addon-storysource-code-panel",
  link: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#storysource-addon-removed",
  async check({ mainConfigPath, mainConfig }) {
    if (!mainConfigPath) {
      return null;
    }
    const addonNames = getAddonNames3(mainConfig);
    const hasStorysource = addonNames.includes("@storybook/addon-storysource");
    const hasDocs = addonNames.includes("@storybook/addon-docs");
    if (!hasStorysource) {
      return null;
    }
    return {
      hasStorysource,
      hasDocs
    };
  },
  prompt: /* @__PURE__ */ __name(() => {
    return dedent6`
      We'll remove @storybook/addon-storysource and enable the Code Panel instead.
    `;
  }, "prompt"),
  run: /* @__PURE__ */ __name(async (options) => {
    const { result, dryRun = false, packageManager, configDir, previewConfigPath } = options;
    const { hasStorysource, hasDocs } = result;
    const errors = [];
    if (!hasStorysource) {
      return;
    }
    if (!dryRun) {
      logger8.debug("Removing @storybook/addon-storysource...");
      await removeAddon2("@storybook/addon-storysource", {
        configDir,
        skipInstall: true,
        packageManager
      });
      if (!hasDocs) {
        logger8.log("Installing @storybook/addon-docs...");
        await add(`@storybook/addon-docs`, {
          configDir,
          packageManager: packageManager.type,
          skipInstall: true,
          skipPostinstall: true,
          yes: true
        });
      }
      if (previewConfigPath) {
        try {
          await updateMainConfig({ mainConfigPath: previewConfigPath, dryRun }, (previewConfig) => {
            previewConfig.setFieldValue(["parameters", "docs", "codePanel"], true);
          });
        } catch (error) {
          console.log(error);
          errors.push({ file: previewConfigPath, error });
        }
      } else {
        logger8.log("No preview config file found. Please manually add code panel parameters.");
        logger8.log(dedent6`
          Add this to your .storybook/preview.js:
          export const parameters = {
            docs: {
              codePanel: true,
            },
          };`);
      }
    }
    if (errors.length > 0) {
      throw new Error(
        `Failed to process ${errors.length} files:
${errors.map(({ file, error }) => `- ${file}: ${error.message}`).join("\n")}`
      );
    }
  }, "run")
};

// src/automigrate/fixes/consolidated-imports.ts
import { readFile as readFile3, writeFile as writeFile2 } from "node:fs/promises";
import { transformImportFiles, versions as versions2 } from "storybook/internal/common";
function transformPackageJson(content) {
  const packageJson = JSON.parse(content);
  let hasChanges = false;
  const packagesToAdd = /* @__PURE__ */ new Set();
  const depTypes = ["dependencies", "devDependencies", "peerDependencies"];
  let storybookVersion = null;
  let storybookDepType = null;
  for (const depType of depTypes) {
    if (packageJson[depType]?.storybook) {
      storybookVersion = packageJson[depType].storybook;
      storybookDepType = depType;
      break;
    }
  }
  for (const depType of depTypes) {
    if (packageJson[depType]) {
      for (const [dep] of Object.entries(packageJson[depType])) {
        if (dep in consolidatedPackages) {
          const newPackage = consolidatedPackages[dep];
          if (!newPackage.startsWith("storybook/") && !newPackage.match(/(?:.*\/){2,}/)) {
            packagesToAdd.add(newPackage);
          }
          delete packageJson[depType][dep];
          hasChanges = true;
        }
      }
    }
  }
  if (packagesToAdd.size > 0) {
    const version2 = storybookVersion ?? versions2["@storybook/nextjs-vite"];
    const depType = storybookDepType ?? "devDependencies";
    packageJson[depType] = packageJson[depType] || {};
    for (const pkg of packagesToAdd) {
      packageJson[depType][pkg] = version2;
    }
    hasChanges = true;
  }
  return hasChanges ? JSON.stringify(packageJson, null, 2) : null;
}
__name(transformPackageJson, "transformPackageJson");
var transformPackageJsonFiles = /* @__PURE__ */ __name(async (files, dryRun) => {
  const errors = [];
  const { default: pLimit } = await import("./p-limit-OEC3Z6OA.js");
  const limit = pLimit(10);
  await Promise.all(
    files.map(
      (file) => limit(async () => {
        try {
          const contents = await readFile3(file, "utf-8");
          const transformed = transformPackageJson(contents);
          if (!dryRun && transformed) {
            await writeFile2(file, transformed);
          }
        } catch (error) {
          errors.push({ file, error });
        }
      })
    )
  );
  return errors;
}, "transformPackageJsonFiles");
var consolidatedImports = {
  id: "consolidated-imports",
  link: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#dropped-support-for-legacy-packages",
  check: /* @__PURE__ */ __name(async ({ packageManager }) => {
    const consolidatedDeps = /* @__PURE__ */ new Set();
    const affectedPackageJSONFiles = /* @__PURE__ */ new Set();
    await Promise.all(
      packageManager.packageJsonPaths.map(async (packageJsonPath) => {
        const contents = await readFile3(packageJsonPath, "utf-8");
        const packageJson = JSON.parse(contents);
        const allDeps = {
          ...packageJson.dependencies || {},
          ...packageJson.devDependencies || {}
        };
        let hasConsolidatedDeps = false;
        Object.keys(allDeps).forEach((dep) => {
          if (dep in consolidatedPackages) {
            consolidatedDeps.add(dep);
            hasConsolidatedDeps = true;
          }
        });
        if (hasConsolidatedDeps) {
          affectedPackageJSONFiles.add(packageJsonPath);
        }
      })
    );
    if (consolidatedDeps.size === 0) {
      return null;
    }
    return {
      consolidatedDeps
    };
  }, "check"),
  prompt: /* @__PURE__ */ __name(() => {
    return "We've detected Storybook packages that have been renamed or consolidated. We'll update these packages by scanning your codebase and updating any imports from these packages.";
  }, "prompt"),
  run: /* @__PURE__ */ __name(async ({ dryRun = false, packageManager, storiesPaths, configDir }) => {
    const errors = [];
    const packageJsonErrors = await transformPackageJsonFiles(
      packageManager.packageJsonPaths,
      dryRun
    );
    errors.push(...packageJsonErrors);
    const { globby } = await import("./globby-J3T2ZND4.js");
    const configFiles = await globby([`${configDir}/**/*`]);
    const importErrors = await transformImportFiles(
      [...storiesPaths, ...configFiles].filter(Boolean),
      {
        ...consolidatedPackages,
        "storybook/internal/manager-api": "storybook/manager-api",
        "storybook/internal/preview-api": "storybook/preview-api",
        "storybook/internal/theming": "storybook/theming",
        "storybook/internal/theming/create": "storybook/theming/create",
        "storybook/internal/test": "storybook/test",
        "storybook/internal/actions": "storybook/internal/actions",
        "storybook/internal/actions/decorator": "storybook/internal/actions/decorator",
        "storybook/internal/highlight": "storybook/internal/highlight",
        "storybook/internal/viewport": "storybook/internal/viewport"
      },
      !!dryRun
    );
    errors.push(...importErrors);
    if (errors.length > 0) {
      throw new Error(
        `Failed to process ${errors.length} files:
${errors.map(({ file, error }) => `- ${file}: ${error.message}`).join("\n")}`
      );
    }
  }, "run")
};

// src/automigrate/fixes/eslint-plugin.ts
import {
  SUPPORTED_ESLINT_EXTENSIONS,
  configureEslintPlugin,
  extractEslintInfo
} from "storybook/internal/cli";
import { logger as logger9 } from "storybook/internal/node-logger";
import { dedent as dedent7 } from "ts-dedent";
var eslintPlugin = {
  id: "eslintPlugin",
  link: "https://storybook.js.org/docs/9/configure/integration/eslint-plugin",
  async check({ packageManager }) {
    const {
      hasEslint,
      eslintConfigFile,
      isStorybookPluginInstalled,
      unsupportedExtension,
      isFlatConfig
    } = await extractEslintInfo(packageManager);
    if (isStorybookPluginInstalled || !hasEslint) {
      return null;
    }
    if (!eslintConfigFile) {
      logger9.warn("Unable to find eslint config file, skipping");
      return null;
    }
    return { eslintConfigFile, unsupportedExtension, isFlatConfig };
  },
  prompt() {
    return `We'll install and configure the Storybook ESLint plugin for you.`;
  },
  async run({
    result: { eslintConfigFile, unsupportedExtension, isFlatConfig },
    packageManager,
    dryRun,
    storybookVersion
  }) {
    const deps = [`eslint-plugin-storybook@${storybookVersion}`];
    logger9.debug(`Adding dependencies: ${deps}`);
    if (!dryRun) {
      await packageManager.addDependencies({ type: "devDependencies", skipInstall: true }, deps);
    }
    if (!dryRun && unsupportedExtension) {
      logger9.warn(dedent7`
          The plugin was successfully installed but failed to be configured.
          
          Found an eslint config file with an unsupported automigration format: .eslintrc.${unsupportedExtension}.
          The supported formats for this automigration are: ${SUPPORTED_ESLINT_EXTENSIONS.join(
        ", "
      )}.

          Please refer to https://storybook.js.org/docs/configure/integration/eslint-plugin#configuration-eslintrc to finish setting up the plugin manually.
      `);
      return;
    }
    if (!dryRun) {
      await configureEslintPlugin({ eslintConfigFile, packageManager, isFlatConfig });
    }
  }
};

// src/automigrate/fixes/fix-faux-esm-require.ts
import { readFile as readFile4, writeFile as writeFile3 } from "node:fs/promises";
import { types as t8 } from "storybook/internal/babel";
import { dedent as dedent8 } from "ts-dedent";
function hasExistingDeclaration(program2, identifierName) {
  return program2.body.some((node) => {
    if (t8.isVariableDeclaration(node)) {
      return node.declarations.some((decl) => {
        if (t8.isVariableDeclarator(decl) && t8.isIdentifier(decl.id)) {
          return decl.id.name === identifierName;
        }
        return false;
      });
    }
    if (t8.isExportNamedDeclaration(node) && node.declaration && t8.isVariableDeclaration(node.declaration)) {
      return node.declaration.declarations.some((decl) => {
        if (t8.isVariableDeclarator(decl) && t8.isIdentifier(decl.id)) {
          return decl.id.name === identifierName;
        }
        return false;
      });
    }
    if (t8.isFunctionDeclaration(node) && t8.isIdentifier(node.id)) {
      return node.id.name === identifierName;
    }
    if (t8.isExportNamedDeclaration(node) && node.declaration && t8.isFunctionDeclaration(node.declaration)) {
      return t8.isIdentifier(node.declaration.id) && node.declaration.id.name === identifierName;
    }
    return false;
  });
}
__name(hasExistingDeclaration, "hasExistingDeclaration");
var fixFauxEsmRequire = {
  id: "fix-faux-esm-require",
  link: "https://storybook.js.org/docs/faq#how-do-i-fix-module-resolution-in-special-environments",
  async check({ mainConfigPath }) {
    if (!mainConfigPath) {
      return null;
    }
    const content = await readFile4(mainConfigPath, "utf-8");
    const isESM = containsESMUsage(content);
    const isWithBanner = hasRequireBanner(content);
    if (!isESM) {
      return null;
    }
    if (isWithBanner) {
      return null;
    }
    const hasRequireUsage = containsRequireUsage(content);
    const hasUnderscoreFilename = containsFilenameUsage(content);
    const hasUnderscoreDirname = containsDirnameUsage(content);
    if (hasRequireUsage || hasUnderscoreFilename || hasUnderscoreDirname) {
      return {
        hasRequireUsage,
        hasUnderscoreDirname,
        hasUnderscoreFilename
      };
    }
    return null;
  },
  prompt() {
    return dedent8`Main config is ESM but uses 'require' or '__dirname'. This will break in Storybook 10; Adding compatibility banner`;
  },
  async run({ dryRun, mainConfigPath, result }) {
    if (dryRun) {
      return;
    }
    const { hasRequireUsage, hasUnderscoreDirname, hasUnderscoreFilename } = result;
    await updateMainConfig({ mainConfigPath, dryRun: !!dryRun }, (mainConfig) => {
      if (hasRequireUsage) {
        mainConfig.setImport(["createRequire"], "node:module");
      }
      if (hasUnderscoreDirname) {
        mainConfig.setImport(["dirname"], "node:path");
      }
      if (hasUnderscoreFilename || hasUnderscoreDirname) {
        mainConfig.setImport(["fileURLToPath"], "node:url");
      }
      const body = mainConfig._ast.program.body;
      let lastImportIndex = -1;
      for (let i = 0; i < body.length; i++) {
        if (t8.isImportDeclaration(body[i])) {
          lastImportIndex = i;
        }
      }
      const insertIndex = lastImportIndex + 1;
      const hasExistingFilename = hasExistingDeclaration(mainConfig._ast.program, "__filename");
      const hasExistingDirname = hasExistingDeclaration(mainConfig._ast.program, "__dirname");
      const hasExistingRequire = hasExistingDeclaration(mainConfig._ast.program, "require");
      if (hasUnderscoreFilename || hasUnderscoreDirname) {
        const declarationsToInsert = [];
        let insertOffset = 0;
        if ((hasUnderscoreFilename || hasUnderscoreDirname) && !hasExistingFilename) {
          const filenameDeclaration = t8.variableDeclaration("const", [
            t8.variableDeclarator(
              t8.identifier("__filename"),
              t8.callExpression(t8.identifier("fileURLToPath"), [
                t8.memberExpression(
                  t8.metaProperty(t8.identifier("import"), t8.identifier("meta")),
                  t8.identifier("url")
                )
              ])
            )
          ]);
          declarationsToInsert.push(filenameDeclaration);
          insertOffset++;
        }
        if (hasUnderscoreDirname && !hasExistingDirname) {
          const dirnameDeclaration = t8.variableDeclaration("const", [
            t8.variableDeclarator(
              t8.identifier("__dirname"),
              t8.callExpression(t8.identifier("dirname"), [t8.identifier("__filename")])
            )
          ]);
          declarationsToInsert.push(dirnameDeclaration);
          insertOffset++;
        }
        declarationsToInsert.forEach((declaration, index) => {
          body.splice(insertIndex + index, 0, declaration);
        });
      }
      if (hasRequireUsage && !hasExistingRequire) {
        const requireDeclaration = t8.variableDeclaration("const", [
          t8.variableDeclarator(
            t8.identifier("require"),
            t8.callExpression(t8.identifier("createRequire"), [
              t8.memberExpression(
                t8.metaProperty(t8.identifier("import"), t8.identifier("meta")),
                t8.identifier("url")
              )
            ])
          )
        ]);
        const filenameAdded = (hasUnderscoreFilename || hasUnderscoreDirname) && !hasExistingFilename;
        const dirnameAdded = hasUnderscoreDirname && !hasExistingDirname;
        const declarationsAdded = (filenameAdded ? 1 : 0) + (dirnameAdded ? 1 : 0);
        const currentInsertIndex = insertIndex + declarationsAdded;
        body.splice(currentInsertIndex, 0, requireDeclaration);
      }
    });
    const content = await readFile4(mainConfigPath, "utf-8");
    const newContent = [bannerComment, content].join("\n");
    await writeFile3(mainConfigPath, newContent);
  }
};

// src/automigrate/fixes/initial-globals.ts
var import_picocolors10 = __toESM(require_picocolors(), 1);
import { readFile as readFile5, writeFile as writeFile4 } from "node:fs/promises";
import { formatConfig as formatConfig3, loadConfig as loadConfig5 } from "storybook/internal/csf-tools";
var initialGlobals = {
  id: "initial-globals",
  link: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#previewjs-globals-renamed-to-initialglobals",
  async check({ previewConfigPath }) {
    if (!previewConfigPath) {
      return null;
    }
    const previewConfig = loadConfig5((await readFile5(previewConfigPath)).toString()).parse();
    const globals = previewConfig.getFieldNode(["globals"]);
    if (!globals) {
      return null;
    }
    return { globals, previewConfig, previewConfigPath };
  },
  prompt() {
    return `Rename ${import_picocolors10.default.cyan("globals")} to ${import_picocolors10.default.cyan("initialGlobals")} in preview.js?`;
  },
  async run({ dryRun, result }) {
    result.previewConfig.removeField(["globals"]);
    result.previewConfig.setFieldNode(["initialGlobals"], result.globals);
    if (!dryRun) {
      await writeFile4(result.previewConfigPath, formatConfig3(result.previewConfig));
    }
  }
};

// src/automigrate/fixes/migrate-addon-console.ts
import { readFileSync as readFileSync3, writeFileSync as writeFileSync3 } from "node:fs";
import { types as t9 } from "storybook/internal/babel";
import { formatFileContent as formatFileContent4, getAddonNames as getAddonNames4, removeAddon as removeAddon3 } from "storybook/internal/common";
import { formatConfig as formatConfig4, loadConfig as loadConfig6 } from "storybook/internal/csf-tools";
import { logger as logger10 } from "storybook/internal/node-logger";
var migrateAddonConsole = {
  id: "migrate-addon-console",
  link: "https://github.com/storybookjs/storybook/discussions/31657",
  async check({ mainConfig, packageManager, previewConfigPath }) {
    const addons = getAddonNames4(mainConfig);
    const consoleAddon = "@storybook/addon-console";
    const hasConsoleAddon = addons.some((addon) => addon.includes(consoleAddon));
    const hasConsoleAddonInDeps = packageManager.isDependencyInstalled(consoleAddon);
    if (!hasConsoleAddon && !hasConsoleAddonInDeps) {
      return null;
    }
    const transformedPreviewCode = previewConfigPath ? await transformPreviewFile2(readFileSync3(previewConfigPath, "utf8"), previewConfigPath) : void 0;
    return {
      transformedPreviewCode
    };
  },
  prompt() {
    return "@storybook/addon-console can now be implemented with spies on the console object.";
  },
  async run({ packageManager, dryRun, configDir, previewConfigPath, result }) {
    const { transformedPreviewCode } = result;
    if (!dryRun) {
      if (!previewConfigPath) {
        logger10.debug(
          "addon-console was installed but no preview file was found. Creating a preview file."
        );
      }
      const finalPreviewPath = previewConfigPath || `${configDir}/preview.ts`;
      const finalTransformedCode = transformedPreviewCode || await transformPreviewFile2("", finalPreviewPath);
      logger10.debug("Updating preview file to replace addon-console logic with spies.");
      writeFileSync3(finalPreviewPath, finalTransformedCode, "utf8");
      logger10.debug("Removing @storybook/addon-console addon.");
      await removeAddon3("@storybook/addon-console", {
        configDir,
        skipInstall: true,
        packageManager
      });
    }
  }
};
async function transformPreviewFile2(source, filePath) {
  const previewConfig = loadConfig6(source).parse();
  previewConfig.setImport(["spyOn"], "storybook/test");
  previewConfig.removeImport(null, "@storybook/addon-console");
  const callsToInject = [];
  for (const method of [
    "log",
    "warn",
    "error",
    "info",
    "debug",
    "trace",
    "count",
    "dir",
    "assert"
  ]) {
    callsToInject.push(
      t9.callExpression(
        t9.memberExpression(
          t9.callExpression(t9.identifier("spyOn"), [
            t9.identifier("console"),
            t9.stringLiteral(method)
          ]),
          t9.identifier("mockName")
        ),
        [t9.stringLiteral(`console.${method}`)]
      )
    );
  }
  const defaultExport = previewConfig.hasDefaultExport ? previewConfig._ast.program.body.find((node) => t9.isExportDefaultDeclaration(node)) : void 0;
  let beforeEach = previewConfig.getFieldNode(["beforeEach"]);
  if (!beforeEach) {
    const beforeEachExport = previewConfig._ast.program.body.find(
      (node) => t9.isExportNamedDeclaration(node) && t9.isFunctionDeclaration(node.declaration) && node.declaration.id?.name === "beforeEach"
    );
    if (beforeEachExport) {
      beforeEach = beforeEachExport.declaration;
    }
  }
  if (!beforeEach && defaultExport) {
    if (t9.isIdentifier(defaultExport.declaration)) {
      const identifierName = defaultExport.declaration.name;
      const variableDeclarations = previewConfig._ast.program.body.filter(
        (node) => t9.isVariableDeclaration(node)
      );
      for (const declaration of variableDeclarations) {
        for (const declarator of declaration.declarations) {
          if (t9.isVariableDeclarator(declarator) && t9.isIdentifier(declarator.id, { name: identifierName })) {
            if (t9.isObjectExpression(declarator.init)) {
              beforeEach = declarator.init.properties.find(
                (prop) => t9.isObjectMethod(prop) && t9.isIdentifier(prop.key, { name: "beforeEach" })
              );
              if (!beforeEach) {
                const beforeEachProperty = declarator.init.properties.find(
                  (prop) => t9.isObjectProperty(prop) && t9.isIdentifier(prop.key, { name: "beforeEach" })
                );
                if (beforeEachProperty && t9.isFunctionExpression(beforeEachProperty.value)) {
                  beforeEach = beforeEachProperty.value;
                }
                if (beforeEachProperty && t9.isIdentifier(beforeEachProperty.value)) {
                  const identifierName2 = beforeEachProperty.value.name;
                  beforeEach = previewConfig._ast.program.body.find(
                    (node) => t9.isFunctionDeclaration(node) && node.id?.name === identifierName2 || t9.isVariableDeclaration(node) && node.declarations.some(
                      (decl) => t9.isVariableDeclarator(decl) && t9.isIdentifier(decl.id, { name: identifierName2 }) && (t9.isFunctionExpression(decl.init) || t9.isArrowFunctionExpression(decl.init))
                    )
                  );
                }
              }
            }
          }
        }
      }
    }
    if (t9.isObjectExpression(defaultExport.declaration)) {
      beforeEach = previewConfig.getFieldNode(["default", "beforeEach"]);
    }
  }
  if (!beforeEach) {
    beforeEach = t9.functionExpression(t9.identifier("beforeEach"), [], t9.blockStatement([]));
    if (defaultExport && t9.isObjectExpression(defaultExport.declaration)) {
      defaultExport.declaration.properties.push(
        t9.objectProperty(t9.identifier("beforeEach"), beforeEach)
      );
    } else {
      previewConfig._ast.program.body.push(
        t9.exportNamedDeclaration(
          t9.variableDeclaration("const", [
            t9.variableDeclarator(t9.identifier("beforeEach"), beforeEach)
          ])
        )
      );
    }
  }
  if (t9.isFunctionDeclaration(beforeEach) || t9.isFunctionExpression(beforeEach) || t9.isArrowFunctionExpression(beforeEach) || t9.isObjectMethod(beforeEach)) {
    const functionBody = beforeEach.body;
    if (t9.isBlockStatement(functionBody)) {
      functionBody.body.push(...callsToInject.map((call) => t9.expressionStatement(call)));
    } else {
      beforeEach.body = t9.blockStatement([
        ...callsToInject.map((call) => t9.expressionStatement(call)),
        t9.returnStatement(functionBody)
      ]);
    }
  }
  return formatFileContent4(filePath, formatConfig4(previewConfig));
}
__name(transformPreviewFile2, "transformPreviewFile");

// src/automigrate/fixes/remove-addon-interactions.ts
import { getAddonNames as getAddonNames5, removeAddon as removeAddon4 } from "storybook/internal/common";
var removeAddonInteractions = {
  id: "remove-addon-interactions",
  link: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#essentials-addon-viewport-controls-interactions-and-actions-moved-to-core",
  async check({ mainConfig, packageManager }) {
    const addons = getAddonNames5(mainConfig);
    const interactionsAddon = "@storybook/addon-interactions";
    const hasInteractionsAddon = addons.some((addon) => addon.includes(interactionsAddon));
    const hasInteractionsAddonInDeps = packageManager.isDependencyInstalled(interactionsAddon);
    if (!hasInteractionsAddon && !hasInteractionsAddonInDeps) {
      return null;
    }
    return true;
  },
  prompt() {
    return "@storybook/addon-interactions has been moved to Storybook core and will be removed from your configuration.";
  },
  async run({ packageManager, dryRun, configDir }) {
    if (!dryRun) {
      await removeAddon4("@storybook/addon-interactions", {
        configDir,
        skipInstall: true,
        packageManager
      });
    }
  }
};

// src/automigrate/fixes/remove-docs-autodocs.ts
var import_picocolors11 = __toESM(require_picocolors(), 1);
import { readConfig as readConfig2 } from "storybook/internal/csf-tools";
var logger11 = {
  log: /* @__PURE__ */ __name((message) => {
    if (process.env.NODE_ENV !== "test") {
      console.log(message);
    }
  }, "log")
};
var removeDocsAutodocs = {
  id: "remove-docs-autodocs",
  link: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#mainjs-docsautodocs-is-deprecated",
  async check({ mainConfigPath }) {
    if (!mainConfigPath) {
      return null;
    }
    try {
      const config = await readConfig2(mainConfigPath);
      const autodocs = config.getSafeFieldValue(["docs", "autodocs"]);
      if (autodocs === void 0) {
        return null;
      }
      return {
        autodocs
      };
    } catch (err) {
      return null;
    }
  },
  prompt: /* @__PURE__ */ __name(() => {
    return `${import_picocolors11.default.cyan("docs.autodocs")} has been removed in Storybook 9 and will be removed from your configuration.`;
  }, "prompt"),
  async run({ result, dryRun, mainConfigPath, previewConfigPath }) {
    const { autodocs } = result;
    logger11.log(`\u{1F504} Updating ${import_picocolors11.default.cyan("docs")} parameter in main config file...`);
    await updateMainConfig({ mainConfigPath, dryRun: !!dryRun }, async (main) => {
      const docs = main.getFieldValue(["docs"]) || {};
      if (!dryRun) {
        delete docs.autodocs;
        if (Object.keys(docs).length === 0) {
          main.removeField(["docs"]);
        } else {
          main.setFieldValue(["docs"], docs);
        }
      }
    });
    if (autodocs === true && previewConfigPath) {
      logger11.log(`\u{1F504} Updating ${import_picocolors11.default.cyan("tags")} parameter in preview config file...`);
      await updateMainConfig(
        { mainConfigPath: previewConfigPath, dryRun: !!dryRun },
        async (preview) => {
          const tags = preview.getFieldValue(["tags"]) || [];
          if (!tags.includes("autodocs") && !dryRun) {
            preview.setFieldValue(["tags"], [...tags, "autodocs"]);
          }
        }
      );
    }
  }
};

// src/automigrate/fixes/remove-essentials.ts
import { getAddonNames as getAddonNames6, removeAddon as removeAddon5, transformImportFiles as transformImportFiles2 } from "storybook/internal/common";

// src/automigrate/fixes/remove-essentials.utils.ts
function moveEssentialOptions(dryRun, essentialsOptions) {
  return async (main) => {
    const features = main.getFieldValue(["features"]) || {};
    if (!dryRun) {
      main.setFieldValue(["features"], {
        ...features,
        ...essentialsOptions
      });
    }
  };
}
__name(moveEssentialOptions, "moveEssentialOptions");

// src/automigrate/fixes/remove-essentials.ts
var consolidatedAddons = {
  "@storybook/addon-actions": "storybook/actions",
  "@storybook/addon-controls": "storybook/internal/controls",
  "@storybook/addon-toolbars": "storybook/internal/toolbars",
  "@storybook/addon-highlight": "storybook/highlight",
  "@storybook/addon-measure": "storybook/measure",
  "@storybook/addon-outline": "storybook/outline",
  "@storybook/addon-backgrounds": "storybook/backgrounds",
  "@storybook/addon-viewport": "storybook/viewport"
};
var removeEssentials = {
  id: "remove-essential-addons",
  link: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#essentials-addon-viewport-controls-interactions-and-actions-moved-to-core",
  async check({ mainConfigPath, mainConfig, packageManager }) {
    if (!mainConfigPath) {
      return null;
    }
    try {
      let hasEssentialsAddon = false;
      let hasDocsAddon = false;
      let hasDocsDisabled = false;
      let essentialsOptions = void 0;
      const additionalAddonsToRemove = [];
      const CORE_ADDONS = [
        "@storybook/addon-actions",
        "@storybook/addon-backgrounds",
        "@storybook/addon-controls",
        "@storybook/addon-highlight",
        "@storybook/addon-measure",
        "@storybook/addon-outline",
        "@storybook/addon-toolbars",
        "@storybook/addon-viewport"
      ];
      const addonNames = getAddonNames6(mainConfig);
      hasEssentialsAddon = addonNames.includes("@storybook/addon-essentials");
      hasDocsAddon = addonNames.includes("@storybook/addon-docs");
      const allDeps = packageManager.getAllDependencies();
      const installedAddons = Object.keys(allDeps);
      for (const addon of CORE_ADDONS) {
        if (addonNames.includes(addon) || installedAddons.includes(addon)) {
          additionalAddonsToRemove.push(addon);
        }
      }
      if (hasEssentialsAddon) {
        const essentialsEntry = mainConfig.addons?.find((addon) => {
          if (typeof addon === "string") {
            return addon.includes("@storybook/addon-essentials");
          }
          return addon.name.includes("@storybook/addon-essentials");
        });
        if (typeof essentialsEntry === "object") {
          const options = essentialsEntry.options || {};
          hasDocsDisabled = options.docs === false;
          const optionsExceptDocs = Object.fromEntries(
            Object.entries(options).filter(([key]) => key !== "docs")
          );
          if (Object.keys(optionsExceptDocs).length > 0) {
            essentialsOptions = optionsExceptDocs;
          }
        }
      }
      if (!hasEssentialsAddon && additionalAddonsToRemove.length === 0) {
        return null;
      }
      const result = {
        hasEssentials: hasEssentialsAddon,
        hasDocsDisabled,
        hasDocsAddon,
        additionalAddonsToRemove,
        allDeps
      };
      if (essentialsOptions) {
        result.essentialsOptions = essentialsOptions;
      }
      return result;
    } catch (err) {
      return null;
    }
  },
  prompt() {
    return "In Storybook 9.0, several addons have been moved into Storybook's core and are no longer needed as separate packages. We'll remove the unnecessary addons from your configuration and dependencies, and update your code to use the new core features.";
  },
  async run({
    result,
    dryRun,
    packageManager,
    configDir,
    storybookVersion,
    storiesPaths,
    mainConfigPath,
    previewConfigPath
  }) {
    const {
      hasEssentials,
      hasDocsDisabled,
      hasDocsAddon,
      additionalAddonsToRemove,
      essentialsOptions
    } = result;
    if (!hasEssentials && additionalAddonsToRemove.length === 0) {
      return;
    }
    if (!dryRun) {
      if (hasEssentials) {
        await removeAddon5("@storybook/addon-essentials", {
          configDir,
          packageManager,
          skipInstall: true
        });
      }
      for (const addon of additionalAddonsToRemove) {
        await removeAddon5(addon, {
          configDir,
          packageManager,
          skipInstall: true
        });
      }
      const errors = await transformImportFiles2(
        [...storiesPaths, mainConfigPath, previewConfigPath].filter(Boolean),
        consolidatedAddons,
        dryRun
      );
      if (errors.length > 0) {
        throw new Error(
          `Failed to process ${errors.length} files:
${errors.map(({ file, error }) => `- ${file}: ${error.message}`).join("\n")}`
        );
      }
      if (essentialsOptions) {
        await updateMainConfig(
          { mainConfigPath, dryRun: !!dryRun },
          moveEssentialOptions(dryRun, essentialsOptions)
        );
      }
      if (!hasDocsDisabled && hasEssentials) {
        await add("@storybook/addon-docs", {
          configDir,
          packageManager: packageManager.type,
          skipInstall: true,
          skipPostinstall: true,
          yes: true
        });
      }
    }
  }
};

// src/automigrate/fixes/renderer-to-framework.ts
import { readFile as readFile6, writeFile as writeFile5 } from "node:fs/promises";
import {
  frameworkPackages as frameworkPackages3,
  frameworkToRenderer,
  rendererPackages as rendererPackages2
} from "storybook/internal/common";
import { logger as logger12 } from "storybook/internal/node-logger";
var getAllDependencies = /* @__PURE__ */ __name((packageJson) => Object.keys({
  ...packageJson.dependencies || {},
  ...packageJson.devDependencies || {}
}), "getAllDependencies");
var detectFrameworks = /* @__PURE__ */ __name((dependencies) => {
  return Object.keys(frameworkPackages3).filter((pkg) => dependencies.includes(pkg));
}, "detectFrameworks");
var detectRenderers = /* @__PURE__ */ __name((dependencies) => {
  return Object.keys(rendererPackages2).filter((pkg) => dependencies.includes(pkg)).filter((pkg) => !Object.keys(frameworkPackages3).includes(pkg));
}, "detectRenderers");
var replaceImports = /* @__PURE__ */ __name((source, renderer, framework) => {
  const regex = new RegExp(`(['"])${renderer}(['"])`, "g");
  return regex.test(source) ? source.replace(regex, `$1${framework}$2`) : null;
}, "replaceImports");
var transformSourceFiles = /* @__PURE__ */ __name(async (files, renderer, framework, dryRun) => {
  const errors = [];
  const { default: pLimit } = await import("./p-limit-OEC3Z6OA.js");
  const limit = pLimit(10);
  await Promise.all(
    files.map(
      (file) => limit(async () => {
        try {
          const contents = await readFile6(file, "utf-8");
          const transformed = replaceImports(contents, renderer, framework);
          if (!dryRun && transformed) {
            await writeFile5(file, transformed);
          }
        } catch (error) {
          errors.push({ file, error });
        }
      })
    )
  );
  return errors;
}, "transformSourceFiles");
var removeRendererInPackageJson = /* @__PURE__ */ __name(async (packageJsonPath, renderer, dryRun) => {
  try {
    const content = await readFile6(packageJsonPath, "utf-8");
    const packageJson = JSON.parse(content);
    let hasChanges = false;
    if (packageJson.dependencies?.[renderer]) {
      delete packageJson.dependencies[renderer];
      hasChanges = true;
    }
    if (packageJson.devDependencies?.[renderer]) {
      delete packageJson.devDependencies[renderer];
      hasChanges = true;
    }
    if (!dryRun && hasChanges) {
      await writeFile5(packageJsonPath, JSON.stringify(packageJson, null, 2));
    }
    return hasChanges;
  } catch (error) {
    throw new Error(`Failed to update package.json: ${error}`);
  }
}, "removeRendererInPackageJson");
var checkPackageJson = /* @__PURE__ */ __name(async (packageJsonPath) => {
  const content = await readFile6(packageJsonPath, "utf-8");
  const packageJson = JSON.parse(content);
  const dependencies = getAllDependencies(packageJson);
  const frameworks = detectFrameworks(dependencies);
  if (frameworks.length === 0) {
    return null;
  }
  const renderers = detectRenderers(dependencies);
  if (renderers.length === 0) {
    return null;
  }
  return { frameworks, renderers };
}, "checkPackageJson");
var rendererToFramework = {
  id: "renderer-to-framework",
  promptType: "auto",
  link: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#moving-from-renderer-based-to-framework-based-configuration",
  async check({ packageManager }) {
    const results = await Promise.all(
      packageManager.packageJsonPaths.map(async (file) => {
        try {
          return await checkPackageJson(file);
        } catch (error) {
          return null;
        }
      })
    );
    const validResults = results.filter(
      (r) => r !== null && r.renderers.length > 0
    );
    if (validResults.length === 0) {
      return null;
    }
    return {
      frameworks: [...new Set(validResults.flatMap((r) => r.frameworks))],
      renderers: [...new Set(validResults.flatMap((r) => r.renderers))],
      packageJsonFiles: packageManager.packageJsonPaths.filter((_, i) => validResults[i] !== null)
    };
  },
  prompt() {
    return `We're moving from renderer-based to framework-based configuration and update your imports and dependencies accordingly.`;
  },
  async run(options) {
    const { result, dryRun = false, storiesPaths, configDir } = options;
    for (const selectedFramework of result.frameworks) {
      const frameworkName = frameworkPackages3[selectedFramework];
      if (!frameworkName) {
        logger12.warn(`Framework name not found for ${selectedFramework}, skipping.`);
        continue;
      }
      const rendererName = frameworkToRenderer[frameworkPackages3[selectedFramework]];
      const [rendererPackage] = Object.entries(rendererPackages2).find(([, renderer]) => renderer === rendererName) ?? [];
      if (!rendererPackage) {
        logger12.warn(`Renderer package not found for ${selectedFramework}, skipping.`);
        continue;
      }
      if (rendererPackage === selectedFramework) {
        continue;
      }
      logger12.debug(`
Migrating ${rendererPackage} to ${selectedFramework}`);
      const { globby } = await import("./globby-J3T2ZND4.js");
      const configFiles = await globby([`${configDir}/**/*`]);
      await transformSourceFiles(
        [...storiesPaths, ...configFiles].filter(Boolean),
        rendererPackage,
        selectedFramework,
        dryRun
      );
      logger12.debug("Updating package.json files...");
      await Promise.all(
        result.packageJsonFiles.map(
          (file) => removeRendererInPackageJson(file, rendererPackage, dryRun)
        )
      );
    }
  }
};

// src/automigrate/fixes/rnstorybook-config.ts
import { existsSync as existsSync2 } from "node:fs";
import { readFile as readFile7, rename, writeFile as writeFile6 } from "node:fs/promises";
import { join as join2 } from "node:path";
import { dedent as dedent9 } from "ts-dedent";
async function renameInFile(filePath, oldText, newText) {
  try {
    const content = await readFile7(filePath, "utf8");
    const updatedContent = content.replaceAll(oldText, newText);
    await writeFile6(filePath, updatedContent, "utf8");
  } catch (error) {
    console.error(`Error updating references in ${filePath}:`, error);
  }
}
__name(renameInFile, "renameInFile");
var getDotStorybookReferences = /* @__PURE__ */ __name(async (searchDir) => {
  try {
    const { globby } = await import("./globby-J3T2ZND4.js");
    const { readFile: readFile9 } = await import("node:fs/promises");
    const files = await globby(`${searchDir}/**/*`, {
      onlyFiles: true,
      gitignore: true
    });
    const referencedFiles = [];
    await Promise.all(
      files.map(async (file) => {
        try {
          const content = await readFile9(file, "utf8");
          if (content.includes(".storybook")) {
            referencedFiles.push(file);
          }
        } catch (readError) {
        }
      })
    );
    return referencedFiles;
  } catch (fsError) {
    console.warn("Unable to search for .storybook references:", fsError);
    return [];
  }
}, "getDotStorybookReferences");
var rnstorybookConfig = {
  id: "rnstorybook-config",
  link: "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#react-native-config-dir-renamed",
  async check({ packageManager, mainConfigPath }) {
    const allDependencies = packageManager.getAllDependencies();
    if (!allDependencies["@storybook/react-native"]) {
      return null;
    }
    const projectDir = mainConfigPath ? join2(mainConfigPath, "..", "..") : process.cwd();
    const storybookDir = join2(projectDir, ".storybook");
    const rnStorybookDir = join2(projectDir, ".rnstorybook");
    const { globby } = await import("./globby-J3T2ZND4.js");
    const requiresFiles = await globby(join2(storybookDir, "storybook.requires.*"));
    if (existsSync2(storybookDir) && requiresFiles.length > 0 && !existsSync2(rnStorybookDir)) {
      return { storybookDir, rnStorybookDir };
    }
    return null;
  },
  prompt() {
    return dedent9`We'll rename your .storybook directory to .rnstorybook and update all references to it.`;
  },
  async run({ result: { storybookDir, rnStorybookDir }, dryRun, packageManager }) {
    const instanceDir = packageManager.instanceDir;
    const dotStorybookReferences = await getDotStorybookReferences(instanceDir);
    if (!dryRun) {
      await Promise.all(
        dotStorybookReferences.map(async (ref) => {
          await renameInFile(ref, ".storybook", ".rnstorybook");
        })
      );
      await rename(storybookDir, rnStorybookDir);
    }
  }
};

// src/automigrate/fixes/upgrade-storybook-related-dependencies.ts
var import_semver5 = __toESM(require_semver(), 1);
import { readFileSync as readFileSync4 } from "node:fs";
import { dirname as dirname2 } from "node:path";
import { isCorePackage, isSatelliteAddon } from "storybook/internal/common";
import { logger as logger13 } from "storybook/internal/node-logger";
import { dedent as dedent10 } from "ts-dedent";
async function getLatestVersions(packageManager, packages) {
  return Promise.all(
    packages.map(async ([packageName]) => ({
      packageName,
      beforeVersion: await packageManager.getInstalledVersion(packageName),
      afterVersion: await packageManager.latestVersion(packageName)
    }))
  );
}
__name(getLatestVersions, "getLatestVersions");
function isValidVersionType(packageName, specifier) {
  if (specifier.startsWith("patch:") || specifier.startsWith("file:") || specifier.startsWith("link:") || specifier.startsWith("portal:") || specifier.startsWith("git:") || specifier.startsWith("git+") || specifier.startsWith("http:") || specifier.startsWith("https:") || specifier.startsWith("workspace:")) {
    logger13.debug(`Skipping ${packageName} as it does not have a valid version type: ${specifier}`);
    return false;
  }
  return true;
}
__name(isValidVersionType, "isValidVersionType");
var upgradeStorybookRelatedDependencies = {
  id: "upgrade-storybook-related-dependencies",
  promptType: "auto",
  defaultSelected: false,
  async check({ packageManager, storybookVersion }) {
    logger13.debug("Checking for incompatible storybook packages...");
    const analyzedPackages = await getIncompatibleStorybookPackages({
      currentStorybookVersion: storybookVersion,
      packageManager,
      skipErrors: true
    });
    const allDependencies = packageManager.getAllDependencies();
    const storybookDependencies = Object.keys(allDependencies).filter((dep) => dep.includes("storybook")).filter((dep) => !isCorePackage(dep) && !isSatelliteAddon(dep));
    const incompatibleDependencies = analyzedPackages.filter((pkg) => pkg.hasIncompatibleDependencies).map((pkg) => pkg.packageName);
    const uniquePackages = Array.from(
      new Set(
        [...storybookDependencies, ...incompatibleDependencies].filter(
          (dep) => isValidVersionType(dep, allDependencies[dep])
        )
      )
    ).map((packageName) => [packageName, allDependencies[packageName]]);
    const packageVersions = await getLatestVersions(packageManager, uniquePackages);
    const upgradablePackages = packageVersions.filter(
      ({ afterVersion, beforeVersion, packageName }) => {
        if (beforeVersion === null || afterVersion === null || allDependencies[packageName] === null) {
          return false;
        }
        return (0, import_semver5.gt)(afterVersion, beforeVersion);
      }
    );
    return upgradablePackages.length > 0 ? { upgradable: upgradablePackages } : null;
  },
  prompt() {
    return "We'll upgrade the community packages that are compatible.";
  },
  async run({ result: { upgradable }, packageManager, dryRun }) {
    if (dryRun) {
      logger13.log(dedent10`
        The following would have been upgraded:
        ${upgradable.map(
        ({ packageName, afterVersion, beforeVersion }) => `${packageName}: ${beforeVersion} => ${afterVersion}`
      ).join("\n")}
      `);
      return;
    }
    if (upgradable.length > 0) {
      packageManager.packageJsonPaths.forEach((packageJsonPath) => {
        const packageJson = JSON.parse(readFileSync4(packageJsonPath, "utf-8"));
        upgradable.forEach((item) => {
          if (!item) {
            return;
          }
          const { packageName, afterVersion: version2 } = item;
          const prefixed = `^${version2}`;
          if (packageJson.dependencies?.[packageName]) {
            packageJson.dependencies[packageName] = prefixed;
          }
          if (packageJson.devDependencies?.[packageName]) {
            packageJson.devDependencies[packageName] = prefixed;
          }
          if (packageJson.peerDependencies?.[packageName]) {
            packageJson.peerDependencies[packageName] = prefixed;
          }
        });
        packageManager.writePackageJson(packageJson, dirname2(packageJsonPath));
      });
    }
  }
};

// src/automigrate/fixes/wrap-getAbsolutePath.ts
import { detectPnp } from "storybook/internal/cli";
import { readConfig as readConfig3 } from "storybook/internal/csf-tools";
import { CommonJsConfigNotSupportedError } from "storybook/internal/server-errors";
import { dedent as dedent11 } from "ts-dedent";
var wrapGetAbsolutePath = {
  id: "wrap-getAbsolutePath",
  link: "https://storybook.js.org/docs/faq#how-do-i-fix-module-resolution-in-special-environments",
  async check({ packageManager, storybookVersion, mainConfigPath }) {
    const isStorybookInMonorepo = packageManager.isStorybookInMonorepo();
    const isPnp = await detectPnp();
    if (!mainConfigPath) {
      return null;
    }
    const config = await readConfig3(mainConfigPath);
    if (!isStorybookInMonorepo && !isPnp) {
      return null;
    }
    if (!getFieldsForGetAbsolutePathWrapper(config).some(
      (node) => isGetAbsolutePathWrapperNecessary(node)
    )) {
      return null;
    }
    const isConfigTypescript = mainConfigPath.endsWith(".ts") || mainConfigPath.endsWith(".tsx");
    return { storybookVersion, isStorybookInMonorepo, isPnp, isConfigTypescript };
  },
  prompt() {
    return dedent11`We have detected that you're using Storybook in a monorepo or PnP project. Some fields in your main config must be updated.`;
  },
  async run({ dryRun, mainConfigPath, result }) {
    await updateMainConfig({ dryRun: !!dryRun, mainConfigPath }, (mainConfig) => {
      getFieldsForGetAbsolutePathWrapper(mainConfig).forEach((node) => {
        wrapValueWithGetAbsolutePathWrapper(mainConfig, node);
      });
      if (getAbsolutePathWrapperName(mainConfig) === null) {
        if (mainConfig?.fileName?.endsWith(".cjs") || mainConfig?.fileName?.endsWith(".cts") || mainConfig?.fileName?.endsWith(".cjsx") || mainConfig?.fileName?.endsWith(".ctsx") || mainConfig._code.includes("module.exports")) {
          throw new CommonJsConfigNotSupportedError();
        } else {
          mainConfig.setImport(["dirname"], "node:path");
          mainConfig.setImport(["fileURLToPath"], "node:url");
        }
        mainConfig.setBodyDeclaration(
          getAbsolutePathWrapperAsCallExpression(result.isConfigTypescript)
        );
      }
    });
  }
};

// src/automigrate/fixes/index.ts
var allFixes = [
  eslintPlugin,
  addonMdxGfmRemove,
  addonStorysourceCodePanel,
  upgradeStorybookRelatedDependencies,
  initialGlobals,
  addonGlobalsApi,
  addonA11yAddonTest,
  consolidatedImports,
  addonExperimentalTest,
  rnstorybookConfig,
  migrateAddonConsole,
  removeAddonInteractions,
  rendererToFramework,
  removeEssentials,
  addonA11yParameters,
  removeDocsAutodocs,
  wrapGetAbsolutePath,
  fixFauxEsmRequire
];
var commandFixes = [csfFactories];

// src/automigrate/helpers/logMigrationSummary.ts
var import_picocolors12 = __toESM(require_picocolors(), 1);
import { logger as logger14 } from "storybook/internal/node-logger";
import { dedent as dedent12 } from "ts-dedent";
var messageDivider2 = "\n\n";
var segmentDivider = "\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n";
function getGlossaryMessages(fixSummary, fixResults) {
  const messages2 = [];
  if (fixSummary.succeeded.length > 0) {
    messages2.push(import_picocolors12.default.bold("Successful migrations:"));
    messages2.push(fixSummary.succeeded.map((m) => import_picocolors12.default.green(m)).join(", "));
  }
  if (Object.keys(fixSummary.failed).length > 0) {
    messages2.push(import_picocolors12.default.bold("Failed migrations:"));
    messages2.push(
      Object.entries(fixSummary.failed).map(([id, error]) => {
        return `${import_picocolors12.default.bold(import_picocolors12.default.red(id))}:
${error}`;
      }).join("\n")
    );
  }
  if (fixSummary.manual.length > 0) {
    messages2.push(import_picocolors12.default.bold("Manual migrations:"));
    messages2.push(
      fixSummary.manual.map(
        (m) => fixResults[m] === "manual_succeeded" /* MANUAL_SUCCEEDED */ ? import_picocolors12.default.green(m) : import_picocolors12.default.blue(m)
      ).join(", ")
    );
  }
  if (fixSummary.skipped.length > 0) {
    messages2.push(import_picocolors12.default.bold("Skipped migrations:"));
    messages2.push(fixSummary.skipped.map((m) => import_picocolors12.default.cyan(m)).join(", "));
  }
  return messages2;
}
__name(getGlossaryMessages, "getGlossaryMessages");
function logMigrationSummary({
  fixResults,
  fixSummary
}) {
  const messages2 = [];
  messages2.push(getGlossaryMessages(fixSummary, fixResults).join(messageDivider2));
  messages2.push(dedent12`If you'd like to run the migrations again, you can do so by running '${import_picocolors12.default.cyan(
    "npx storybook automigrate"
  )}'
    
    The automigrations try to migrate common patterns in your project, but might not contain everything needed to migrate to the latest version of Storybook.
    
    Please check the changelog and migration guide for manual migrations and more information: ${import_picocolors12.default.yellow(
    "https://storybook.js.org/docs/releases/migration-guide?ref=upgrade"
  )}
    And reach out on Discord if you need help: ${import_picocolors12.default.yellow("https://discord.gg/storybook")}
  `);
  const hasNoFixes = Object.values(fixResults).every((r) => r === "unnecessary" /* UNNECESSARY */);
  const hasFailures2 = Object.values(fixResults).some(
    (r) => r === "failed" /* FAILED */ || r === "check_failed" /* CHECK_FAILED */
  );
  const title = hasNoFixes ? "No migrations were applicable to your project" : hasFailures2 ? "Migration check ran with failures" : "Migration check ran successfully";
  return logger14.logBox(messages2.filter(Boolean).join(segmentDivider), {
    title,
    borderColor: hasFailures2 ? "red" : "green"
  });
}
__name(logMigrationSummary, "logMigrationSummary");

// src/automigrate/index.ts
var logAvailableMigrations = /* @__PURE__ */ __name(() => {
  const availableFixes = [...allFixes, ...commandFixes].map((f) => import_picocolors13.default.yellow(f.id)).map((x) => `- ${x}`).join("\n");
  logger15.log(dedent13`
    The following migrations are available:
    ${availableFixes}
  `);
}, "logAvailableMigrations");
var hasFailures = /* @__PURE__ */ __name((fixResults) => {
  return Object.values(fixResults || {}).some(
    (r) => r === "failed" /* FAILED */ || r === "check_failed" /* CHECK_FAILED */
  );
}, "hasFailures");
var doAutomigrate = /* @__PURE__ */ __name(async (options) => {
  logger15.debug("Extracting storybook data...");
  const {
    mainConfig,
    mainConfigPath,
    previewConfigPath,
    storybookVersion,
    configDir,
    packageManager,
    storiesPaths
  } = await getStorybookData({
    configDir: options.configDir,
    packageManagerName: options.packageManager
  });
  if (!storybookVersion) {
    throw new Error("Could not determine Storybook version");
  }
  if (!mainConfigPath) {
    throw new Error("Could not determine main config path");
  }
  const outcome = await automigrate({
    ...options,
    packageManager,
    storybookVersion,
    beforeVersion: storybookVersion,
    mainConfigPath,
    mainConfig,
    previewConfigPath,
    configDir,
    isUpgrade: false,
    isLatest: false,
    storiesPaths
  });
  const hasAppliedFixes = Object.values(outcome?.fixResults ?? {}).some(
    (r) => r === "succeeded" /* SUCCEEDED */ || r === "manual_succeeded" /* MANUAL_SUCCEEDED */
  );
  if (hasAppliedFixes) {
    packageManager.installDependencies();
  }
  if (outcome && !options.skipDoctor) {
    await doctor({ configDir, packageManager: options.packageManager });
  }
  if (hasFailures(outcome?.fixResults)) {
    throw new Error("Some migrations failed");
  }
}, "doAutomigrate");
var automigrate = /* @__PURE__ */ __name(async ({
  fixId,
  fixes: inputFixes,
  dryRun,
  yes,
  packageManager,
  list,
  configDir,
  mainConfig,
  mainConfigPath,
  previewConfigPath,
  storybookVersion,
  beforeVersion,
  renderer: rendererPackage,
  skipInstall,
  hideMigrationSummary = false,
  isUpgrade,
  isLatest,
  storiesPaths
}) => {
  if (list) {
    logAvailableMigrations();
    return null;
  }
  const commandFix = commandFixes.find((f) => f.id === fixId);
  if (commandFix) {
    logger15.log(`\u{1F50E} Running migration ${import_picocolors13.default.magenta(fixId)}..`);
    await commandFix.run({
      mainConfigPath,
      previewConfigPath,
      packageManager,
      configDir,
      dryRun,
      mainConfig,
      result: null,
      storybookVersion,
      storiesPaths
    });
    return null;
  }
  const selectedFixes = inputFixes || allFixes.filter((fix) => {
    if (fix.id === upgradeStorybookRelatedDependencies.id && isLatest === false && fixId !== upgradeStorybookRelatedDependencies.id) {
      return false;
    }
    return true;
  });
  const fixes = fixId ? selectedFixes.filter((f) => f.id === fixId) : selectedFixes;
  if (fixId && fixes.length === 0) {
    logger15.log(`\u{1F4ED} No migrations found for ${import_picocolors13.default.magenta(fixId)}.`);
    logAvailableMigrations();
    return null;
  }
  logger15.log("\u{1F50E} checking possible migrations..");
  const { fixResults, fixSummary, preCheckFailure } = await runFixes({
    fixes,
    packageManager,
    rendererPackage,
    skipInstall,
    configDir,
    previewConfigPath,
    mainConfig,
    mainConfigPath,
    storybookVersion,
    beforeVersion,
    isUpgrade: !!isUpgrade,
    dryRun,
    yes,
    storiesPaths
  });
  if (hasFailures(fixResults)) {
    logTracker2.enableLogWriting();
  }
  if (!hideMigrationSummary) {
    logger15.log("");
    logMigrationSummary({
      fixResults,
      fixSummary
    });
    logger15.log("");
  }
  return { fixResults, preCheckFailure };
}, "automigrate");
async function runFixes({
  fixes,
  dryRun,
  yes,
  rendererPackage,
  skipInstall,
  configDir,
  packageManager,
  mainConfig,
  mainConfigPath,
  previewConfigPath,
  storybookVersion,
  storiesPaths
}) {
  const fixResults = {};
  const fixSummary = { succeeded: [], failed: {}, manual: [], skipped: [] };
  for (let i = 0; i < fixes.length; i += 1) {
    const f = fixes[i];
    let result;
    try {
      logger15.debug(`Running ${import_picocolors13.default.cyan(f.id)} migration checks`);
      result = await f.check({
        packageManager,
        configDir,
        rendererPackage,
        mainConfig,
        storybookVersion,
        previewConfigPath,
        mainConfigPath,
        storiesPaths
      });
      logger15.debug(`End of ${import_picocolors13.default.cyan(f.id)} migration checks`);
    } catch (error) {
      logger15.warn(`\u26A0\uFE0F  failed to check fix ${import_picocolors13.default.bold(f.id)}`);
      if (error instanceof Error) {
        logger15.error(`
${error.stack}`);
        fixSummary.failed[f.id] = error.message;
      }
      fixResults[f.id] = "check_failed" /* CHECK_FAILED */;
    }
    if (result) {
      const promptType = typeof f.promptType === "function" ? await f.promptType(result) : f.promptType ?? "auto";
      logger15.log(`\u{1F50E} found a '${import_picocolors13.default.cyan(f.id)}' migration:`);
      const getTitle = /* @__PURE__ */ __name(() => {
        switch (promptType) {
          case "auto":
            return "Automigration detected";
          case "manual":
            return "Manual migration detected";
          case "notification":
            return "Migration notification";
        }
      }, "getTitle");
      const currentTaskLogger = prompt3.taskLog({
        id: `automigrate-task-${f.id}`,
        title: `${getTitle()}: ${import_picocolors13.default.cyan(f.id)}`
      });
      logger15.logBox(f.prompt());
      let runAnswer;
      try {
        if (dryRun) {
          runAnswer = { fix: false };
        } else if (yes) {
          runAnswer = { fix: true };
          if (promptType === "manual") {
            fixResults[f.id] = "manual_succeeded" /* MANUAL_SUCCEEDED */;
            fixSummary.manual.push(f.id);
          }
        } else if (promptType === "manual") {
          fixResults[f.id] = "manual_succeeded" /* MANUAL_SUCCEEDED */;
          fixSummary.manual.push(f.id);
          logger15.log("");
          const shouldContinue = await prompt3.confirm(
            {
              message: "Select continue once you have made the required changes, or quit to exit the migration process",
              initialValue: true,
              active: "continue",
              inactive: "quit"
            },
            {
              onCancel: /* @__PURE__ */ __name(() => {
                throw new Error();
              }, "onCancel")
            }
          );
          if (!shouldContinue) {
            fixResults[f.id] = "manual_skipped" /* MANUAL_SKIPPED */;
            break;
          }
        } else if (promptType === "auto") {
          const shouldRun = await prompt3.confirm(
            {
              message: `Do you want to run the '${import_picocolors13.default.cyan(f.id)}' migration on your project?`,
              initialValue: f.defaultSelected ?? true
            },
            {
              onCancel: /* @__PURE__ */ __name(() => {
                throw new Error();
              }, "onCancel")
            }
          );
          runAnswer = { fix: shouldRun };
        } else if (promptType === "notification") {
          const shouldContinue = await prompt3.confirm(
            {
              message: `Do you want to continue?`
            },
            {
              onCancel: /* @__PURE__ */ __name(() => {
                throw new Error();
              }, "onCancel")
            }
          );
          runAnswer = { fix: shouldContinue };
        }
      } catch (err) {
        break;
      }
      if (promptType === "auto") {
        invariant(runAnswer, "runAnswer must be defined if not promptOnly");
        if (runAnswer.fix) {
          try {
            invariant(typeof f.run === "function", "run method should be available in fix.");
            invariant(mainConfigPath, "Main config path should be defined to run migration.");
            await f.run({
              result,
              packageManager,
              dryRun,
              mainConfigPath,
              configDir,
              previewConfigPath,
              mainConfig,
              skipInstall,
              storybookVersion,
              storiesPaths
            });
            logger15.log(`\u2705 ran ${import_picocolors13.default.cyan(f.id)} migration`);
            fixResults[f.id] = "succeeded" /* SUCCEEDED */;
            fixSummary.succeeded.push(f.id);
            currentTaskLogger.success(`Ran ${import_picocolors13.default.cyan(f.id)} migration`);
          } catch (error) {
            fixResults[f.id] = "failed" /* FAILED */;
            const errorMessage = error instanceof Error ? error.message : "Failed to run migration";
            fixSummary.failed[f.id] = errorMessage;
            currentTaskLogger.error(`Error when running ${import_picocolors13.default.cyan(f.id)} migration`);
          }
        } else {
          fixResults[f.id] = "skipped" /* SKIPPED */;
          fixSummary.skipped.push(f.id);
          currentTaskLogger.success(`Skipped ${import_picocolors13.default.cyan(f.id)} migration`);
        }
      }
    } else {
      fixResults[f.id] = fixResults[f.id] || "unnecessary" /* UNNECESSARY */;
    }
  }
  return { fixResults, fixSummary };
}
__name(runFixes, "runFixes");

// src/link.ts
var import_cross_spawn = __toESM(require_cross_spawn(), 1);
var import_picocolors14 = __toESM(require_picocolors(), 1);
import { mkdir, readFile as readFile8, writeFile as writeFile7 } from "node:fs/promises";
import { basename as basename2, extname as extname2, join as join3 } from "node:path";
import { logger as logger16 } from "storybook/internal/node-logger";
var exec = /* @__PURE__ */ __name(async (command2, options = {}, {
  startMessage,
  errorMessage,
  dryRun
} = {}) => {
  if (startMessage) {
    logger16.info(startMessage);
  }
  if (dryRun) {
    logger16.info(`
> ${command2}
`);
    return void 0;
  }
  logger16.info(command2);
  return new Promise((resolve2, reject) => {
    const child = (0, import_cross_spawn.spawn)(command2, {
      ...options,
      shell: true,
      stdio: "pipe"
    });
    child.stderr.pipe(process.stdout);
    child.stdout.pipe(process.stdout);
    child.on("exit", (code) => {
      if (code === 0) {
        resolve2(void 0);
      } else {
        logger16.error(import_picocolors14.default.red(`An error occurred while executing: \`${command2}\``));
        if (errorMessage) {
          logger16.info(errorMessage);
        }
        reject(new Error(`command exited with code: ${code}: `));
      }
    });
  });
}, "exec");
var link = /* @__PURE__ */ __name(async ({ target, local, start }) => {
  const storybookDir = process.cwd();
  try {
    const packageJson = JSON.parse(await readFile8("package.json", { encoding: "utf8" }));
    if (packageJson.name !== "@storybook/root") {
      throw new Error();
    }
  } catch {
    throw new Error("Expected to run link from the root of the storybook monorepo");
  }
  let reproDir = target;
  let reproName = basename2(target);
  if (!local) {
    const reprosDir = join3(storybookDir, "../storybook-repros");
    logger16.info(`Ensuring directory ${reprosDir}`);
    await mkdir(reprosDir, { recursive: true });
    logger16.info(`Cloning ${target}`);
    await exec(`git clone ${target}`, { cwd: reprosDir });
    reproName = basename2(target, extname2(target));
    reproDir = join3(reprosDir, reproName);
  }
  const version2 = (0, import_cross_spawn.sync)("yarn", ["--version"], {
    cwd: reproDir,
    stdio: "pipe",
    shell: true
  }).stdout.toString();
  if (!/^[2-4]\./.test(version2)) {
    logger16.warn(`\u{1F6A8} Expected yarn 2 or higher in ${reproDir}!`);
    logger16.warn("");
    logger16.warn("Please set it up with `yarn set version berry`,");
    logger16.warn(`then link '${reproDir}' with the '--local' flag.`);
    return;
  }
  logger16.info(`Linking ${reproDir}`);
  await exec(`yarn link --all --relative "${storybookDir}"`, { cwd: reproDir });
  logger16.info(`Installing ${reproName}`);
  const reproPackageJson = JSON.parse(
    await readFile8(join3(reproDir, "package.json"), { encoding: "utf8" })
  );
  if (!reproPackageJson.devDependencies?.vite) {
    reproPackageJson.devDependencies = {
      ...reproPackageJson.devDependencies,
      "webpack-hot-middleware": "*"
    };
  }
  reproPackageJson.devDependencies = {
    ...reproPackageJson.devDependencies,
    "@types/node": "^22"
  };
  await writeFile7(join3(reproDir, "package.json"), JSON.stringify(reproPackageJson, null, 2));
  await exec(`yarn install`, { cwd: reproDir });
  if (start) {
    logger16.info(`Running ${reproName} storybook`);
    await exec(`yarn run storybook`, { cwd: reproDir });
  }
}, "link");

// src/migrate.ts
import { logger as logger17 } from "storybook/internal/node-logger";
import { listCodemods, runCodemod as runCodemod2 } from "@storybook/codemod";
async function migrate(migration, { glob, dryRun, list, rename: rename2, parser }) {
  if (list) {
    listCodemods().forEach((key) => logger17.log(key));
  } else if (migration) {
    await runCodemod2(migration, { glob, dryRun, logger: logger17, rename: rename2, parser });
  } else {
    throw new Error("Migrate: please specify a migration name or --list");
  }
}
__name(migrate, "migrate");

// src/sandbox.ts
import { existsSync as existsSync3 } from "node:fs";
import { mkdir as mkdir2, readdir, rm } from "node:fs/promises";
import { isAbsolute as isAbsolute2 } from "node:path";
import {
  JsPackageManagerFactory,
  isCI,
  optionalEnvToBoolean as optionalEnvToBoolean2,
  versions as versions3
} from "storybook/internal/common";
import { logger as logger18, prompt as prompt4 } from "storybook/internal/node-logger";
import { downloadTemplate } from "giget";
var import_picocolors15 = __toESM(require_picocolors(), 1);
var import_semver6 = __toESM(require_semver(), 1);
import { dedent as dedent14 } from "ts-dedent";

// src/sandbox-templates.ts
var baseTemplates = {
  "cra/default-js": {
    name: "Create React App Latest (Webpack | JavaScript)",
    script: `
      npx create-react-app {{beforeDir}} && cd {{beforeDir}} &&       jq '.browserslist.production[0] = ">0.9%"' package.json > tmp.json && mv tmp.json package.json
    `,
    expected: {
      // TODO: change this to @storybook/cra once that package is created
      framework: "@storybook/react-webpack5",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    },
    skipTasks: ["e2e-tests", "bench", "vitest-integration"],
    modifications: {
      useCsfFactory: true,
      extraDependencies: ["prop-types"],
      mainConfig: /* @__PURE__ */ __name((config) => {
        const stories = config.getFieldValue(["stories"]);
        return {
          features: {
            experimentalTestSyntax: true
          },
          stories: stories?.map((s) => {
            if (typeof s === "string") {
              return s.replace(/\|(tsx?|ts)\b|\b(tsx?|ts)\|/g, "");
            } else {
              return s;
            }
          })
        };
      }, "mainConfig")
    }
  },
  "cra/default-ts": {
    name: "Create React App Latest (Webpack | TypeScript)",
    script: `
      npx create-react-app {{beforeDir}} --template typescript && cd {{beforeDir}} &&       jq '.browserslist.production[0] = ">0.9%"' package.json > tmp.json && mv tmp.json package.json
    `,
    // Re-enable once https://github.com/storybookjs/storybook/issues/19351 is fixed.
    skipTasks: ["smoke-test", "bench", "vitest-integration"],
    expected: {
      // TODO: change this to @storybook/cra once that package is created
      framework: "@storybook/react-webpack5",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    },
    modifications: {
      useCsfFactory: true,
      extraDependencies: ["prop-types"],
      mainConfig: {
        features: {
          experimentalTestSyntax: true
        }
      }
    }
  },
  "nextjs/14-ts": {
    name: "Next.js v14.2 (Webpack | TypeScript)",
    script: 'yarn create next-app {{beforeDir}} -e https://github.com/vercel/next.js/tree/v14.2.17/examples/hello-world && cd {{beforeDir}} && npm pkg set "dependencies.next"="^14.2.17" && yarn && git add . && git commit --amend --no-edit && cd ..',
    expected: {
      framework: "@storybook/nextjs",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    },
    modifications: {
      useCsfFactory: true,
      mainConfig: {
        features: {
          experimentalRSC: true,
          developmentModeForBuild: true,
          experimentalTestSyntax: true
        }
      },
      extraDependencies: ["server-only", "prop-types"]
    },
    skipTasks: ["e2e-tests", "e2e-tests-dev", "bench", "vitest-integration"]
  },
  "nextjs/15-ts": {
    name: "Next.js v15 (Webpack | TypeScript)",
    script: 'npx create-next-app@^15.5 {{beforeDir}} --eslint --tailwind --app --import-alias="@/*" --src-dir',
    expected: {
      framework: "@storybook/nextjs",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    },
    modifications: {
      useCsfFactory: true,
      mainConfig: {
        features: {
          experimentalRSC: true,
          developmentModeForBuild: true,
          experimentalTestSyntax: true
        }
      },
      extraDependencies: ["server-only", "prop-types"]
    },
    skipTasks: ["e2e-tests", "bench", "vitest-integration"]
  },
  "nextjs/default-ts": {
    name: "Next.js Latest (Webpack | TypeScript)",
    script: 'npx create-next-app {{beforeDir}} --eslint --tailwind --app --import-alias="@/*" --src-dir',
    expected: {
      framework: "@storybook/nextjs",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    },
    modifications: {
      useCsfFactory: true,
      mainConfig: {
        features: {
          experimentalRSC: true,
          developmentModeForBuild: true,
          experimentalTestSyntax: true
        }
      },
      extraDependencies: ["server-only", "prop-types"]
    },
    skipTasks: ["bench", "vitest-integration"]
  },
  "nextjs/prerelease": {
    name: "Next.js Prerelease (Webpack | TypeScript)",
    script: 'npx create-next-app@canary {{beforeDir}} --eslint --tailwind --app --import-alias="@/*" --src-dir',
    expected: {
      framework: "@storybook/nextjs",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    },
    modifications: {
      useCsfFactory: true,
      mainConfig: {
        features: {
          experimentalRSC: true,
          developmentModeForBuild: true,
          experimentalTestSyntax: true
        }
      },
      extraDependencies: ["server-only", "prop-types"]
    },
    skipTasks: ["e2e-tests", "bench", "vitest-integration"]
  },
  "nextjs-vite/14-ts": {
    name: "Next.js v14 (Vite | TypeScript)",
    script: 'npx create-next-app@^14 {{beforeDir}} --eslint --tailwind --app --import-alias="@/*" --src-dir',
    expected: {
      framework: "@storybook/nextjs-vite",
      renderer: "@storybook/react",
      builder: "@storybook/builder-vite"
    },
    modifications: {
      useCsfFactory: true,
      mainConfig: {
        framework: "@storybook/nextjs-vite",
        features: {
          experimentalRSC: true,
          developmentModeForBuild: true,
          experimentalTestSyntax: true
        }
      },
      extraDependencies: ["server-only", "@storybook/nextjs-vite", "vite", "prop-types"]
    },
    skipTasks: ["e2e-tests", "bench"]
  },
  "nextjs-vite/15-ts": {
    name: "Next.js v15 (Vite | TypeScript)",
    script: 'npx create-next-app@^15 {{beforeDir}} --eslint --tailwind --app --import-alias="@/*" --src-dir',
    expected: {
      framework: "@storybook/nextjs-vite",
      renderer: "@storybook/react",
      builder: "@storybook/builder-vite"
    },
    modifications: {
      useCsfFactory: true,
      mainConfig: {
        framework: "@storybook/nextjs-vite",
        features: {
          experimentalRSC: true,
          developmentModeForBuild: true,
          experimentalTestSyntax: true
        }
      },
      extraDependencies: ["server-only", "@storybook/nextjs-vite", "vite", "prop-types"]
    },
    skipTasks: ["e2e-tests", "bench"]
  },
  "nextjs-vite/default-ts": {
    name: "Next.js Latest (Vite | TypeScript)",
    script: 'npx create-next-app {{beforeDir}} --eslint --no-tailwind --app --import-alias="@/*" --src-dir',
    expected: {
      framework: "@storybook/nextjs-vite",
      renderer: "@storybook/react",
      builder: "@storybook/builder-vite"
    },
    modifications: {
      useCsfFactory: true,
      mainConfig: {
        framework: "@storybook/nextjs-vite",
        features: {
          experimentalRSC: true,
          developmentModeForBuild: true,
          experimentalTestSyntax: true
        }
      },
      extraDependencies: ["server-only", "@storybook/nextjs-vite", "vite", "prop-types"]
    },
    skipTasks: ["bench"]
  },
  "react-vite/default-js": {
    name: "React Latest (Vite | JavaScript)",
    script: "npm create vite --yes {{beforeDir}} -- --template react",
    expected: {
      framework: "@storybook/react-vite",
      renderer: "@storybook/react",
      builder: "@storybook/builder-vite"
    },
    modifications: {
      useCsfFactory: true,
      extraDependencies: ["prop-types"],
      mainConfig: {
        features: {
          developmentModeForBuild: true,
          experimentalTestSyntax: true
        }
      }
    },
    skipTasks: ["e2e-tests", "bench"]
  },
  "react-vite/default-ts": {
    name: "React Latest (Vite | TypeScript)",
    script: "npm create vite --yes {{beforeDir}} -- --template react-ts",
    expected: {
      framework: "@storybook/react-vite",
      renderer: "@storybook/react",
      builder: "@storybook/builder-vite"
    },
    modifications: {
      useCsfFactory: true,
      extraDependencies: ["prop-types"],
      mainConfig: {
        features: {
          developmentModeForBuild: true,
          experimentalTestSyntax: true
        }
      }
    },
    skipTasks: ["bench"]
  },
  "react-vite/prerelease-ts": {
    name: "React Prerelease (Vite | TypeScript)",
    /**
     * 1. Create a Vite project with the React template
     * 2. Add React beta versions
     * 3. Add resolutions for react, react-dom,@types/react and @types/react-dom, see
     *    https://react.dev/blog/2024/04/25/react-19-upgrade-guide#installing
     * 4. Add @types/react and @types/react-dom pointing to the beta packages
     */
    script: `
      npm create vite --yes {{beforeDir}} -- --template react-ts &&       cd {{beforeDir}} &&       jq '.resolutions += {"@types/react": "npm:types-react@beta", "@types/react-dom": "npm:types-react-dom@beta", "react": "npm:react@beta", "react-dom": "npm:react-dom@beta"}' package.json > tmp.json && mv tmp.json package.json &&       yarn add react@beta react-dom@beta &&       yarn add --dev @types/react@npm:types-react@beta @types/react-dom@npm:types-react-dom@beta
      `,
    expected: {
      framework: "@storybook/react-vite",
      renderer: "@storybook/react",
      builder: "@storybook/builder-vite"
    },
    modifications: {
      useCsfFactory: true,
      extraDependencies: ["prop-types"],
      mainConfig: {
        features: {
          developmentModeForBuild: true,
          experimentalTestSyntax: true
        }
      }
    },
    skipTasks: ["e2e-tests", "bench"]
  },
  "react-webpack/18-ts": {
    name: "React Latest (Webpack | TypeScript)",
    script: "yarn create webpack5-react {{beforeDir}}",
    expected: {
      framework: "@storybook/react-webpack5",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    },
    modifications: {
      useCsfFactory: true,
      extraDependencies: ["prop-types"],
      mainConfig: {
        features: {
          experimentalTestSyntax: true
        }
      }
    },
    skipTasks: ["e2e-tests", "bench", "vitest-integration"]
  },
  "react-webpack/17-ts": {
    name: "React v17 (Webpack | TypeScript)",
    script: 'yarn create webpack5-react {{beforeDir}} --version-react="17" --version-react-dom="17"',
    expected: {
      framework: "@storybook/react-webpack5",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    },
    modifications: {
      useCsfFactory: true,
      extraDependencies: ["prop-types"],
      mainConfig: {
        features: {
          experimentalTestSyntax: true
        }
      }
    },
    skipTasks: ["e2e-tests", "bench", "vitest-integration"]
  },
  "react-webpack/prerelease-ts": {
    name: "React Prerelease (Webpack | TypeScript)",
    /**
     * 1. Create a Webpack project with React beta versions
     * 2. Add resolutions for @types/react and @types/react-dom, see
     *    https://react.dev/blog/2024/04/25/react-19-upgrade-guide#installing
     * 3. Add @types/react and @types/react-dom pointing to the beta packages
     */
    script: `
      yarn create webpack5-react {{beforeDir}} --version-react="beta" --version-react-dom="beta" &&       cd {{beforeDir}} &&       jq '.resolutions += {"@types/react": "npm:types-react@beta", "@types/react-dom": "npm:types-react-dom@beta"}' package.json > tmp.json && mv tmp.json package.json &&       yarn add --dev @types/react@npm:types-react@beta @types/react-dom@npm:types-react-dom@beta
      `,
    expected: {
      framework: "@storybook/react-webpack5",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    },
    modifications: {
      useCsfFactory: true,
      extraDependencies: ["prop-types"],
      mainConfig: {
        features: {
          experimentalTestSyntax: true
        }
      }
    },
    skipTasks: ["e2e-tests", "bench", "vitest-integration"]
  },
  "solid-vite/default-js": {
    name: "SolidJS Latest (Vite | JavaScript)",
    script: "npx degit solidjs/templates/js {{beforeDir}}",
    expected: {
      framework: "storybook-solidjs-vite",
      renderer: "storybook-solidjs-vite",
      builder: "@storybook/builder-vite"
    },
    skipTasks: ["e2e-tests", "bench", "vitest-integration"]
  },
  "solid-vite/default-ts": {
    name: "SolidJS Latest (Vite | TypeScript)",
    script: "npx degit solidjs/templates/ts {{beforeDir}}",
    expected: {
      framework: "storybook-solidjs-vite",
      renderer: "storybook-solidjs-vite",
      builder: "@storybook/builder-vite"
    },
    skipTasks: ["e2e-tests", "bench"]
  },
  "vue3-vite/default-js": {
    name: "Vue v3 (Vite | JavaScript)",
    script: "npm create vite --yes {{beforeDir}} -- --template vue",
    expected: {
      framework: "@storybook/vue3-vite",
      renderer: "@storybook/vue3",
      builder: "@storybook/builder-vite"
    },
    skipTasks: ["e2e-tests", "bench"]
  },
  "vue3-vite/default-ts": {
    name: "Vue v3 (Vite | TypeScript)",
    script: "npm create vite --yes {{beforeDir}} -- --template vue-ts",
    expected: {
      framework: "@storybook/vue3-vite",
      renderer: "@storybook/vue3",
      builder: "@storybook/builder-vite"
    },
    skipTasks: ["bench"]
  },
  // 'nuxt-vite/default-ts': {
  //   name: 'Nuxt v3 (Vite | TypeScript)',
  //   script: 'npx nuxi init --packageManager yarn --gitInit false -M @nuxt/ui {{beforeDir}}',
  //   expected: {
  //     framework: '@storybook-vue/nuxt',
  //     renderer: '@storybook/vue3',
  //     builder: '@storybook/builder-vite',
  //   },
  //   skipTasks: ['e2e-tests', 'bench', 'vitest-integration'],
  // },
  "html-vite/default-js": {
    name: "HTML Latest (Vite | JavaScript)",
    script: 'npm create vite --yes {{beforeDir}} -- --template vanilla && cd {{beforeDir}} && echo "export default {}" > vite.config.js',
    expected: {
      framework: "@storybook/html-vite",
      renderer: "@storybook/html",
      builder: "@storybook/builder-vite"
    },
    skipTasks: ["e2e-tests", "bench", "vitest-integration"]
  },
  "html-vite/default-ts": {
    name: "HTML Latest (Vite | TypeScript)",
    script: 'npm create vite --yes {{beforeDir}} -- --template vanilla-ts && cd {{beforeDir}} && echo "export default {}" > vite.config.js',
    expected: {
      framework: "@storybook/html-vite",
      renderer: "@storybook/html",
      builder: "@storybook/builder-vite"
    },
    skipTasks: ["e2e-tests", "bench", "vitest-integration"]
  },
  "svelte-vite/default-js": {
    name: "Svelte Latest (Vite | JavaScript)",
    script: "npm create vite --yes {{beforeDir}} -- --template svelte",
    expected: {
      framework: "@storybook/svelte-vite",
      renderer: "@storybook/svelte",
      builder: "@storybook/builder-vite"
    },
    skipTasks: ["e2e-tests", "bench"]
  },
  "svelte-vite/default-ts": {
    name: "Svelte Latest (Vite | TypeScript)",
    script: "npm create vite --yes {{beforeDir}} -- --template svelte-ts",
    expected: {
      framework: "@storybook/svelte-vite",
      renderer: "@storybook/svelte",
      builder: "@storybook/builder-vite"
    },
    // Remove smoke-test from the list once https://github.com/storybookjs/storybook/issues/19351 is fixed.
    skipTasks: ["smoke-test", "bench"]
  },
  "angular-cli/prerelease": {
    name: "Angular CLI Prerelease (Webpack | TypeScript)",
    script: "npx -p @angular/cli@next ng new angular-v16 --directory {{beforeDir}} --routing=true --minimal=true --style=scss --strict --skip-git --skip-install --package-manager=yarn --ssr",
    expected: {
      framework: "@storybook/angular",
      renderer: "@storybook/angular",
      builder: "@storybook/builder-webpack5"
    },
    skipTasks: ["e2e-tests", "bench", "vitest-integration"]
  },
  "angular-cli/default-ts": {
    name: "Angular CLI Latest (Webpack | TypeScript)",
    script: "npx -p @angular/cli ng new angular-latest --directory {{beforeDir}} --routing=true --minimal=true --style=scss --strict --skip-git --skip-install --package-manager=yarn --ssr",
    expected: {
      framework: "@storybook/angular",
      renderer: "@storybook/angular",
      builder: "@storybook/builder-webpack5"
    },
    skipTasks: ["bench", "vitest-integration"]
  },
  "svelte-kit/skeleton-ts": {
    name: "SvelteKit Latest (Vite | TypeScript)",
    script: "npx sv@latest create --template minimal --types ts --no-add-ons --no-install {{beforeDir}}",
    expected: {
      framework: "@storybook/sveltekit",
      renderer: "@storybook/svelte",
      builder: "@storybook/builder-vite"
    },
    skipTasks: ["e2e-tests", "bench"]
  },
  "lit-vite/default-js": {
    name: "Lit Latest (Vite | JavaScript)",
    script: 'npm create vite --yes {{beforeDir}} -- --template lit && cd {{beforeDir}} && echo "export default {}" > vite.config.js',
    expected: {
      framework: "@storybook/web-components-vite",
      renderer: "@storybook/web-components",
      builder: "@storybook/builder-vite"
    },
    // Remove smoke-test from the list once https://github.com/storybookjs/storybook/issues/19351 is fixed.
    skipTasks: ["smoke-test", "e2e-tests", "bench", "vitest-integration"]
  },
  "lit-vite/default-ts": {
    name: "Lit Latest (Vite | TypeScript)",
    script: 'npm create vite --yes {{beforeDir}} -- --template lit-ts && cd {{beforeDir}} && echo "export default {}" > vite.config.js',
    expected: {
      framework: "@storybook/web-components-vite",
      renderer: "@storybook/web-components",
      builder: "@storybook/builder-vite"
    },
    // Remove smoke-test from the list once https://github.com/storybookjs/storybook/issues/19351 is fixed.
    skipTasks: ["smoke-test", "e2e-tests", "bench", "vitest-integration"]
  },
  "preact-vite/default-js": {
    name: "Preact Latest (Vite | JavaScript)",
    script: "npm create vite --yes {{beforeDir}} -- --template preact",
    expected: {
      framework: "@storybook/preact-vite",
      renderer: "@storybook/preact",
      builder: "@storybook/builder-vite"
    },
    modifications: {
      extraDependencies: ["preact-render-to-string"]
    },
    skipTasks: ["e2e-tests", "bench"]
  },
  "preact-vite/default-ts": {
    name: "Preact Latest (Vite | TypeScript)",
    script: "npm create vite --yes {{beforeDir}} -- --template preact-ts",
    expected: {
      framework: "@storybook/preact-vite",
      renderer: "@storybook/preact",
      builder: "@storybook/builder-vite"
    },
    modifications: {
      extraDependencies: ["preact-render-to-string"]
    },
    skipTasks: ["e2e-tests", "bench"]
  },
  "qwik-vite/default-ts": {
    name: "Qwik CLI Latest (Vite | TypeScript)",
    script: "npm create qwik playground {{beforeDir}}",
    // TODO: The community template does not provide standard stories, which is required for e2e tests. Reenable once it does.
    inDevelopment: true,
    expected: {
      framework: "storybook-framework-qwik",
      renderer: "storybook-framework-qwik",
      builder: "storybook-framework-qwik"
    },
    // TODO: The community template does not provide standard stories, which is required for e2e tests.
    skipTasks: ["e2e-tests-dev", "e2e-tests", "bench", "vitest-integration"]
  },
  "ember/3-js": {
    name: "Ember v3 (Webpack | JavaScript)",
    script: "npx --package ember-cli@3.28.1 ember new {{beforeDir}}",
    inDevelopment: true,
    expected: {
      framework: "@storybook/ember",
      renderer: "@storybook/ember",
      builder: "@storybook/builder-webpack5"
    }
  },
  "ember/default-js": {
    name: "Ember v4 (Webpack | JavaScript)",
    script: "npx --package ember-cli@4.12.1 ember new {{beforeDir}} --yarn && cd {{beforeDir}} && yarn add --dev @storybook/ember-cli-storybook && yarn build",
    inDevelopment: true,
    expected: {
      framework: "@storybook/ember",
      renderer: "@storybook/ember",
      builder: "@storybook/builder-webpack5"
    }
  },
  "react-native-web-vite/expo-ts": {
    // NOTE: create-expo-app installs React 18.2.0. But yarn portal
    // expects 18.3.1 (dunno why). Therefore to run this in dev you
    // must either:
    //  - edit the sandbox package.json to depend on react 18.3.1, OR
    //  - build/run the sandbox in --no-link mode, which is fine
    //
    // Users & CI won't see this limitation because they are not using
    // yarn portals.
    name: "React Native Expo Latest (Vite | TypeScript)",
    script: "npx create-expo-app -y {{beforeDir}}",
    expected: {
      framework: "@storybook/react-native-web-vite",
      renderer: "@storybook/react",
      builder: "@storybook/builder-vite"
    },
    modifications: {
      useCsfFactory: true,
      mainConfig: {
        features: {
          experimentalTestSyntax: true
        }
      }
    },
    skipTasks: ["bench", "vitest-integration"]
  },
  "react-native-web-vite/rn-cli-ts": {
    // NOTE: create-expo-app installs React 18.2.0. But yarn portal
    // expects 18.3.1 (dunno why). Therefore to run this in dev you
    // must either:
    //  - edit the sandbox package.json to depend on react 18.3.1, OR
    //  - build/run the sandbox in --no-link mode, which is fine
    //
    // Users & CI won't see this limitation because they are not using
    // yarn portals.
    name: "React Native CLI Latest (Vite | TypeScript)",
    script: "npx @react-native-community/cli@latest init --install-pods=false --directory={{beforeDir}} rnapp",
    expected: {
      framework: "@storybook/react-native-web-vite",
      renderer: "@storybook/react",
      builder: "@storybook/builder-vite"
    },
    skipTasks: ["e2e-tests", "bench", "vitest-integration"]
  }
};
var internalTemplates = {
  "internal/react18-webpack-babel": {
    name: "React with Babel Latest (Webpack | TypeScript)",
    script: "yarn create webpack5-react {{beforeDir}}",
    expected: {
      framework: "@storybook/react-webpack5",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    },
    modifications: {
      useCsfFactory: true,
      extraDependencies: ["@storybook/addon-webpack5-compiler-babel", "prop-types"],
      editAddons: /* @__PURE__ */ __name((addons) => [...addons, "@storybook/addon-webpack5-compiler-babel"].filter(
        (a) => a !== "@storybook/addon-webpack5-compiler-swc"
      ), "editAddons"),
      mainConfig: {
        features: {
          experimentalTestSyntax: true
        }
      }
    },
    isInternal: true,
    skipTasks: ["e2e-tests", "bench", "vitest-integration"]
  },
  "internal/react16-webpack": {
    name: "React 16 (Webpack | TypeScript)",
    script: "yarn create webpack5-react {{beforeDir}} --version-react=16 --version-react-dom=16 --version-@types/react=16 --version-@types/react-dom=16",
    expected: {
      framework: "@storybook/react-webpack5",
      renderer: "@storybook/react",
      builder: "@storybook/builder-webpack5"
    },
    modifications: {
      useCsfFactory: true,
      extraDependencies: ["prop-types"],
      mainConfig: {
        features: {
          experimentalTestSyntax: true
        }
      }
    },
    skipTasks: ["e2e-tests", "bench", "vitest-integration"],
    isInternal: true
  },
  "internal/server-webpack5": {
    name: "Server Webpack5",
    script: 'yarn init -y && echo "module.exports = {}" > webpack.config.js',
    expected: {
      framework: "@storybook/server-webpack5",
      renderer: "@storybook/server",
      builder: "@storybook/builder-webpack5"
    },
    isInternal: true,
    skipTasks: ["bench", "vitest-integration"]
  }
};
var benchTemplates = {
  "bench/react-vite-default-ts": {
    ...baseTemplates["react-vite/default-ts"],
    name: "Bench (react-vite/default-ts)",
    isInternal: true,
    modifications: {
      skipTemplateStories: true
    },
    skipTasks: [
      "e2e-tests",
      "test-runner",
      "test-runner-dev",
      "e2e-tests-dev",
      "chromatic",
      "vitest-integration"
    ]
  },
  "bench/react-webpack-18-ts": {
    ...baseTemplates["react-webpack/18-ts"],
    name: "Bench (react-webpack/18-ts)",
    isInternal: true,
    modifications: {
      skipTemplateStories: true
    },
    skipTasks: [
      "e2e-tests",
      "test-runner",
      "test-runner-dev",
      "e2e-tests-dev",
      "chromatic",
      "vitest-integration"
    ]
  },
  "bench/react-vite-default-ts-nodocs": {
    ...baseTemplates["react-vite/default-ts"],
    name: "Bench (react-vite/default-ts, no docs)",
    isInternal: true,
    modifications: {
      skipTemplateStories: true,
      disableDocs: true
    },
    skipTasks: [
      "e2e-tests",
      "test-runner",
      "test-runner-dev",
      "e2e-tests-dev",
      "chromatic",
      "vitest-integration"
    ]
  },
  "bench/react-vite-default-ts-test-build": {
    ...baseTemplates["react-vite/default-ts"],
    name: "Bench (react-vite/default-ts, test-build)",
    isInternal: true,
    modifications: {
      skipTemplateStories: true,
      testBuild: true
    },
    skipTasks: [
      "e2e-tests",
      "test-runner",
      "test-runner-dev",
      "e2e-tests-dev",
      "vitest-integration"
    ]
  },
  "bench/react-webpack-18-ts-test-build": {
    ...baseTemplates["react-webpack/18-ts"],
    name: "Bench (react-webpack/18-ts, test-build)",
    isInternal: true,
    modifications: {
      skipTemplateStories: true,
      testBuild: true
    },
    skipTasks: [
      "e2e-tests",
      "test-runner",
      "test-runner-dev",
      "e2e-tests-dev",
      "vitest-integration"
    ]
  }
};
var allTemplates = {
  ...baseTemplates,
  ...internalTemplates,
  ...benchTemplates
};
var normal = [
  // TODO: Add this back once we resolve the React 19 issues
  // 'cra/default-ts',
  "react-vite/default-ts",
  "angular-cli/default-ts",
  "vue3-vite/default-ts",
  // 'nuxt-vite/default-ts', // temporarily disabled because it's broken
  "lit-vite/default-ts",
  "svelte-vite/default-ts",
  "svelte-kit/skeleton-ts",
  "nextjs/default-ts",
  "nextjs-vite/default-ts",
  "bench/react-vite-default-ts",
  "bench/react-webpack-18-ts",
  "bench/react-vite-default-ts-nodocs",
  "bench/react-vite-default-ts-test-build",
  "bench/react-webpack-18-ts-test-build",
  "ember/default-js"
];
var merged = [
  ...normal,
  "react-webpack/18-ts",
  "react-webpack/17-ts",
  "nextjs/15-ts",
  "nextjs-vite/15-ts",
  "preact-vite/default-ts",
  "html-vite/default-ts"
];
var daily = [
  ...merged,
  "angular-cli/prerelease",
  // TODO: Add this back once we resolve the React 19 issues
  // 'cra/default-js',
  "react-vite/default-js",
  "react-vite/prerelease-ts",
  "react-webpack/prerelease-ts",
  "nextjs-vite/14-ts",
  "nextjs/14-ts",
  "vue3-vite/default-js",
  "lit-vite/default-js",
  "svelte-vite/default-js",
  "nextjs/prerelease",
  "qwik-vite/default-ts",
  "preact-vite/default-js",
  "html-vite/default-js",
  "internal/react16-webpack",
  "internal/react18-webpack-babel",
  "react-native-web-vite/expo-ts"
  // 'react-native-web-vite/rn-cli-ts',
];

// src/sandbox.ts
var toChoices = /* @__PURE__ */ __name((c) => ({ label: allTemplates[c].name, value: c }), "toChoices");
var sandbox = /* @__PURE__ */ __name(async ({
  output: outputDirectory,
  filterValue,
  init,
  ...options
}) => {
  let selectedConfig = allTemplates[filterValue];
  let templateId = selectedConfig ? filterValue : null;
  const { packageManager: pkgMgr } = options;
  const packageManager = JsPackageManagerFactory.getPackageManager({
    force: pkgMgr
  });
  const latestVersion = await packageManager.latestVersion("storybook");
  const nextVersion = await packageManager.latestVersion("storybook@next") ?? "0.0.0";
  const currentVersion = versions3.storybook;
  const isPrerelease = (0, import_semver6.prerelease)(currentVersion);
  const isOutdated = (0, import_semver6.lt)(currentVersion, isPrerelease ? nextVersion : latestVersion);
  const borderColor = isOutdated ? "#FC521F" : "#F1618C";
  const downloadType = !isOutdated && init ? "after-storybook" : "before-storybook";
  const branch = isPrerelease ? "next" : "main";
  const messages2 = {
    welcome: `Creating a Storybook ${import_picocolors15.default.bold(currentVersion)} sandbox..`,
    notLatest: import_picocolors15.default.red(dedent14`
      This version is behind the latest release, which is: ${import_picocolors15.default.bold(latestVersion)}!
      You likely ran the init command through npx, which can use a locally cached version, to get the latest please run:
      ${import_picocolors15.default.bold("npx storybook@latest sandbox")}
      
      You may want to CTRL+C to stop, and run with the latest version instead.
    `),
    longInitTime: import_picocolors15.default.yellow(
      "The creation of the sandbox will take longer, because we will need to run init."
    ),
    prerelease: import_picocolors15.default.yellow("This is a pre-release version.")
  };
  logger18.logBox(
    [messages2.welcome].concat(isOutdated && !isPrerelease ? [messages2.notLatest] : []).concat(init && (isOutdated || isPrerelease) ? [messages2.longInitTime] : []).concat(isPrerelease ? [messages2.prerelease] : []).join("\n"),
    { borderStyle: "round", padding: 1, borderColor }
  );
  if (!selectedConfig) {
    const filterRegex = new RegExp(`^${filterValue || ""}`, "i");
    const keys = Object.keys(allTemplates);
    const choices = keys.reduce((acc, group) => {
      const current = allTemplates[group];
      if (!filterValue) {
        acc.push(group);
        return acc;
      }
      if (current.name.match(filterRegex) || group.match(filterRegex) || current.expected.builder.match(filterRegex) || current.expected.framework.match(filterRegex) || current.expected.renderer.match(filterRegex)) {
        acc.push(group);
        return acc;
      }
      return acc;
    }, []);
    if (choices.length === 0) {
      logger18.logBox(
        dedent14`
             You filtered out all templates. 

            After filtering all the templates with "${import_picocolors15.default.yellow(
          filterValue
        )}", we found no results. Please try again with a different filter.

            Available templates:
            ${keys.map((key) => import_picocolors15.default.blue(`- ${key}`)).join("\n")}
            `.trim(),
        { borderStyle: "round", padding: 1, borderColor: "#F1618C" }
      );
      process.exit(1);
    }
    if (choices.length === 1) {
      [templateId] = choices;
    } else {
      logger18.logBox(
        dedent14`
             Welcome to ${import_picocolors15.default.yellow("sb sandbox")}! 

            Create a ${import_picocolors15.default.green("new project")} to minimally reproduce Storybook issues.

            1. select an environment that most closely matches your project setup.
            2. select a location for the reproduction, outside of your project.

            After the reproduction is ready, we'll guide you through the next steps.
            `.trim(),
        { borderStyle: "round", padding: 1, borderColor: "#F1618C" }
      );
      templateId = await promptSelectedTemplate(choices);
    }
    const hasSelectedTemplate = !!(templateId ?? null);
    if (!hasSelectedTemplate) {
      logger18.error("Somehow we got no templates. Please rerun this command!");
      return;
    }
    selectedConfig = templateId ? allTemplates[templateId] : void 0;
    if (!selectedConfig) {
      throw new Error("\u{1F6A8} Sandbox: please specify a valid template type");
    }
  }
  let selectedDirectory = outputDirectory;
  const outputDirectoryName = outputDirectory || templateId;
  if (selectedDirectory && existsSync3(`${selectedDirectory}`)) {
    logger18.log(`\u26A0\uFE0F  ${selectedDirectory} already exists! Overwriting...`);
    await rm(selectedDirectory, { recursive: true, force: true });
  }
  if (!selectedDirectory) {
    const directory = await prompt4.text(
      {
        message: "Enter the output directory",
        initialValue: outputDirectoryName ?? void 0,
        validate: /* @__PURE__ */ __name((directoryName) => directoryName && existsSync3(directoryName) ? `${directoryName} already exists. Please choose another name.` : void 0, "validate")
      },
      {
        onCancel: /* @__PURE__ */ __name(() => {
          logger18.log("Command cancelled by the user. Exiting...");
          process.exit(1);
        }, "onCancel")
      }
    );
    selectedDirectory = directory;
  }
  invariant(selectedDirectory);
  try {
    const templateDestination = isAbsolute2(selectedDirectory) ? selectedDirectory : join(process.cwd(), selectedDirectory);
    logger18.log(`\u{1F3C3} Adding ${selectedConfig.name} into ${templateDestination}`);
    logger18.log(`\u{1F4E6} Downloading sandbox template (${import_picocolors15.default.bold(downloadType)})...`);
    try {
      const gitPath = `github:storybookjs/sandboxes/${templateId}/${downloadType}#${branch}`;
      await mkdir2(templateDestination, { recursive: true });
      await downloadTemplate(gitPath, {
        force: true,
        dir: templateDestination
      });
      if ((await readdir(templateDestination)).length === 0) {
        const selected = import_picocolors15.default.yellow(templateId);
        throw new Error(dedent14`
          Template downloaded from ${import_picocolors15.default.blue(gitPath)} is empty.
          Are you use it exists? Or did you want to set ${selected} to inDevelopment first?
        `);
      }
      if (downloadType === "before-storybook" && init) {
        const before = process.cwd();
        process.chdir(templateDestination);
        const { initiate } = await import("create-storybook");
        await initiate({
          dev: isCI() && !optionalEnvToBoolean2(process.env.IN_STORYBOOK_SANDBOX),
          ...options,
          features: ["docs", "test"]
        });
        process.chdir(before);
      }
    } catch (err) {
      logger18.error(`\u{1F6A8} Failed to download sandbox template: ${String(err)}`);
      throw err;
    }
    const initMessage = init ? import_picocolors15.default.yellow(dedent14`
          yarn install
          yarn storybook
        `) : `Recreate your setup, then ${import_picocolors15.default.yellow(`npx storybook@latest init`)}`;
    logger18.logBox(
      dedent14`
         Your Storybook reproduction project is ready to use! 

        ${import_picocolors15.default.yellow(`cd ${selectedDirectory}`)}
        ${initMessage}

        Once you've recreated the problem you're experiencing, please:

        1. Document any additional steps in ${import_picocolors15.default.cyan("README.md")}
        2. Publish the repository to github
        3. Link to the repro repository in your issue

        Having a clean repro helps us solve your issue faster! 
      `.trim(),
      { borderStyle: "round", padding: 1, borderColor: "#F1618C" }
    );
  } catch (error) {
    logger18.error("\u{1F6A8} Failed to create sandbox");
    throw error;
  }
}, "sandbox");
async function promptSelectedTemplate(choices) {
  const selected = await prompt4.select({
    message: "Select a template",
    options: choices.map(toChoices)
  });
  return selected;
}
__name(promptSelectedTemplate, "promptSelectedTemplate");

// src/upgrade.ts
var import_cross_spawn2 = __toESM(require_cross_spawn(), 1);
var import_picocolors16 = __toESM(require_picocolors(), 1);
var import_semver7 = __toESM(require_semver(), 1);
import { versions as versions4 } from "storybook/internal/common";
import { HandledError, JsPackageManagerFactory as JsPackageManagerFactory2, isCorePackage as isCorePackage2 } from "storybook/internal/common";
import { withTelemetry } from "storybook/internal/core-server";
import {
  CLI_COLORS as CLI_COLORS3,
  createHyperlink,
  logTracker as logTracker3,
  logger as logger20,
  prompt as prompt6
} from "storybook/internal/node-logger";
import {
  UpgradeStorybookToLowerVersionError,
  UpgradeStorybookUnknownCurrentVersionError
} from "storybook/internal/server-errors";
import { telemetry } from "storybook/internal/telemetry";
import { dedent as dedent15 } from "ts-dedent";

// src/automigrate/multi-project.ts
import { CLI_COLORS as CLI_COLORS2, logger as logger19, prompt as prompt5 } from "storybook/internal/node-logger";
import { sanitizeError } from "storybook/internal/telemetry";
async function collectAutomigrationsAcrossProjects(options) {
  const { fixes, projects, taskLog } = options;
  const automigrationMap = /* @__PURE__ */ new Map();
  logger19.debug(
    `Starting automigration collection across ${projects.length} projects and ${fixes.length} fixes...`
  );
  function collectResult(fix, project, status, result) {
    const existing = automigrationMap.get(fix.id);
    if (existing) {
      existing.reports.push({
        project,
        result,
        status
      });
    } else {
      automigrationMap.set(fix.id, {
        fix,
        reports: [
          {
            result,
            status,
            project
          }
        ]
      });
    }
  }
  __name(collectResult, "collectResult");
  for (const project of projects) {
    const projectName = shortenPath(project.configDir);
    taskLog.message(`Checking automigrations for ${projectName}...`);
    logger19.debug(`Processing project: ${projectName}`);
    for (const fix of fixes) {
      try {
        logger19.debug(`Checking fix ${fix.id} for project ${projectName}...`);
        const checkOptions = {
          packageManager: project.packageManager,
          configDir: project.configDir,
          mainConfig: project.mainConfig,
          storybookVersion: project.storybookVersion,
          previewConfigPath: project.previewConfigPath,
          mainConfigPath: project.mainConfigPath,
          storiesPaths: project.storiesPaths
        };
        const result = await fix.check(checkOptions);
        if (result !== null) {
          collectResult(fix, project, "check_succeeded", result);
        } else {
          collectResult(fix, project, "not_applicable");
        }
      } catch (error) {
        collectResult(fix, project, "check_failed");
        logger19.debug(
          `Failed to check fix ${fix.id} for project ${shortenPath(project.configDir)}.`
        );
        logger19.debug(`${error instanceof Error ? error.stack : String(error)}`);
      }
    }
  }
  const allAutomigrations = Array.from(automigrationMap.values());
  const applicableAutomigrations = allAutomigrations.filter(
    (am) => am.reports.every((rep) => rep.status !== "not_applicable")
  );
  const { successAutomigrations, failedAutomigrations } = applicableAutomigrations.reduce(
    (acc, { fix, reports }) => {
      const successReports = reports.filter((report) => report.status === "check_succeeded");
      const failedReports = reports.filter((report) => report.status === "check_failed");
      if (successReports.length > 0) {
        acc.successAutomigrations.push(fix.id);
      }
      if (failedReports.length > 0) {
        acc.failedAutomigrations.push(fix.id);
      }
      return acc;
    },
    { successAutomigrations: [], failedAutomigrations: [] }
  );
  taskLog.message("\nAutomigrations detected:");
  successAutomigrations.forEach((fixId) => {
    taskLog.message(`${CLI_COLORS2.success(`${logger19.SYMBOLS.success} ${fixId}`)}`);
  });
  failedAutomigrations.forEach((fixId) => {
    taskLog.message(`${CLI_COLORS2.error(`${logger19.SYMBOLS.error} ${fixId}`)}`);
  });
  if (failedAutomigrations.length > 0) {
    taskLog.error(
      `${failedAutomigrations.length} automigration ${failedAutomigrations.length > 1 ? "checks" : "check"} failed`
    );
  } else {
    taskLog.success(
      `${applicableAutomigrations.length === 0 ? "No automigrations detected" : `${applicableAutomigrations.length} automigration(s) detected`}`
    );
  }
  return allAutomigrations;
}
__name(collectAutomigrationsAcrossProjects, "collectAutomigrationsAcrossProjects");
var formatProjectDirs = /* @__PURE__ */ __name((list) => {
  const amountOfProjectsShown = 1;
  const relativeDirs = list.filter((p) => p.status === "check_succeeded").map((p) => shortenPath(p.project.configDir) || ".");
  if (relativeDirs.length <= amountOfProjectsShown) {
    return relativeDirs.join(", ");
  }
  const remaining = relativeDirs.length - amountOfProjectsShown;
  return `${relativeDirs.slice(0, amountOfProjectsShown).join(", ")}${remaining > 0 ? ` and ${remaining} more...` : ""}`;
}, "formatProjectDirs");
async function promptForAutomigrations(automigrations, options) {
  if (automigrations.length === 0) {
    return [];
  }
  if (options.dryRun) {
    logger19.log("Detected automigrations (dry run - no changes will be made):");
    automigrations.forEach(({ fix, reports: list }) => {
      logger19.log(`  - ${fix.id} (${formatProjectDirs(list)})`);
    });
    return [];
  }
  if (options.yes) {
    logger19.log("Running all detected automigrations:");
    automigrations.forEach(({ fix, reports: list }) => {
      logger19.log(`  - ${fix.id} (${formatProjectDirs(list)})`);
    });
    return automigrations;
  }
  const choices = automigrations.map((am) => {
    const hint = [];
    hint.push(`${am.fix.prompt()}`);
    if (am.fix.link) {
      hint.push(`More info: ${am.fix.link}`);
    }
    const label = am.reports.length > 1 ? `${am.fix.id} (${formatProjectDirs(am.reports)})` : am.fix.id;
    return {
      value: am.fix.id,
      label,
      hint: hint.join("\n"),
      defaultSelected: am.fix.defaultSelected ?? true
    };
  });
  const selectedIds = await prompt5.multiselect({
    message: "Select automigrations to run",
    options: choices,
    initialValues: choices.filter((c) => c.defaultSelected).map((c) => c.value),
    required: false
  });
  return automigrations.filter((am) => selectedIds.includes(am.fix.id));
}
__name(promptForAutomigrations, "promptForAutomigrations");
async function runAutomigrationsForProjects(selectedAutomigrations, options) {
  const { dryRun, skipInstall, automigrations } = options;
  const projectResults = {};
  const applicableAutomigrations = selectedAutomigrations.filter(
    (am) => am.reports.every((rep) => rep.status !== "not_applicable")
  );
  const projectAutomigrationResults = /* @__PURE__ */ new Map();
  for (const automigration of automigrations) {
    for (const report of automigration.reports) {
      const { project, result, status } = report;
      const existing = projectAutomigrationResults.get(project.configDir) || [];
      if (existing.length > 0) {
        existing.push({
          fix: automigration.fix,
          project,
          result,
          status
        });
      } else {
        projectAutomigrationResults.set(project.configDir, [
          {
            fix: automigration.fix,
            project,
            result,
            status
          }
        ]);
      }
    }
  }
  let projectIndex = 0;
  for (const [configDir, projectAutomigration] of projectAutomigrationResults) {
    const countPrefix = projectAutomigrationResults.size > 1 ? `(${++projectIndex}/${projectAutomigrationResults.size}) ` : "";
    const { project } = projectAutomigration[0];
    const projectName = shortenPath(project.configDir);
    const taskLog = applicableAutomigrations.length > 0 ? prompt5.taskLog({
      id: `automigrate-${projectName}`,
      title: `${countPrefix}Running automigrations for ${projectName}`
    }) : {
      message: /* @__PURE__ */ __name((message) => {
        logger19.debug(`${message}`);
      }, "message"),
      error: /* @__PURE__ */ __name((message) => {
        logger19.debug(`${message}`);
      }, "error"),
      success: /* @__PURE__ */ __name((message) => {
        logger19.debug(`${message}`);
      }, "success")
    };
    const fixResults = {};
    const fixFailures = {};
    for (const automigration of projectAutomigration) {
      const { fix, result, project: project2, status } = automigration;
      if (status === "not_applicable") {
        fixResults[fix.id] = "unnecessary" /* UNNECESSARY */;
        continue;
      }
      if (status === "check_failed") {
        fixResults[fix.id] = "check_failed" /* CHECK_FAILED */;
        continue;
      }
      const hasBeenSelected = selectedAutomigrations.some(
        (am) => am.fix.id === fix.id && am.reports.some((report) => report.project.configDir === project2.configDir)
      );
      if (!hasBeenSelected) {
        fixResults[fix.id] = "skipped" /* SKIPPED */;
        continue;
      }
      try {
        if (typeof fix.run === "function") {
          const runOptions = {
            packageManager: project2.packageManager,
            result,
            dryRun,
            mainConfigPath: project2.mainConfigPath,
            previewConfigPath: project2.previewConfigPath,
            mainConfig: project2.mainConfig,
            configDir: project2.configDir,
            skipInstall,
            storybookVersion: project2.storybookVersion,
            storiesPaths: project2.storiesPaths
          };
          await fix.run(runOptions);
          fixResults[fix.id] = "succeeded" /* SUCCEEDED */;
          taskLog.message(CLI_COLORS2.success(`${logger19.SYMBOLS.success} ${fix.id}`));
        }
      } catch (error) {
        const errorMessage = (error instanceof Error ? error.stack : String(error)) ?? "Unknown error";
        fixResults[fix.id] = "failed" /* FAILED */;
        fixFailures[fix.id] = sanitizeError(error);
        taskLog.message(CLI_COLORS2.error(`${logger19.SYMBOLS.error} ${automigration.fix.id}`));
        logger19.debug(errorMessage);
      }
    }
    const automigrationsWithErrors = Object.values(fixResults).filter(
      (status) => status === "failed" /* FAILED */
    );
    if (automigrationsWithErrors.length > 0) {
      const count = automigrationsWithErrors.length;
      taskLog.error(`${countPrefix}${count} automigrations failed for ${projectName}`);
    } else {
      taskLog.success(`${countPrefix}Completed automigrations for ${projectName}`);
    }
    projectResults[configDir] = {
      automigrationStatuses: fixResults,
      automigrationErrors: fixFailures
    };
  }
  return projectResults;
}
__name(runAutomigrationsForProjects, "runAutomigrationsForProjects");
async function runAutomigrations(projects, options) {
  const projectAutomigrationData = projects.map((project) => ({
    configDir: project.configDir,
    packageManager: project.packageManager,
    mainConfig: project.mainConfig,
    mainConfigPath: project.mainConfigPath,
    previewConfigPath: project.previewConfigPath,
    storybookVersion: project.currentCLIVersion,
    beforeVersion: project.beforeVersion,
    storiesPaths: project.storiesPaths
  }));
  const detectingAutomigrationTask = prompt5.taskLog({
    id: "detect-automigrations",
    title: projectAutomigrationData.length > 1 ? `Detecting automigrations for ${projectAutomigrationData.length} projects...` : `Detecting automigrations...`
  });
  const detectedAutomigrations = await collectAutomigrationsAcrossProjects({
    fixes: allFixes,
    projects: projectAutomigrationData,
    dryRun: options.dryRun,
    yes: options.yes,
    skipInstall: options.skipInstall,
    taskLog: detectingAutomigrationTask
  });
  const successfulAutomigrations = detectedAutomigrations.filter(
    (am) => am.reports.some((report) => report.status === "check_succeeded")
  );
  const selectedAutomigrations = await promptForAutomigrations(successfulAutomigrations, {
    dryRun: options.dryRun,
    yes: options.yes
  });
  const automigrationResults = await runAutomigrationsForProjects(selectedAutomigrations, {
    automigrations: detectedAutomigrations,
    dryRun: options.dryRun,
    yes: options.yes,
    skipInstall: options.skipInstall
  });
  Object.entries(automigrationResults).forEach(([configDir, resultData]) => {
    if (resultData.automigrationStatuses[rnstorybookConfig.id] === "succeeded" /* SUCCEEDED */) {
      const project = projects.find((p) => p.configDir === configDir);
      if (project) {
        const oldConfigDir = project.configDir;
        project.configDir = project.configDir.replace(".storybook", ".rnstorybook");
        automigrationResults[project.configDir] = resultData;
        delete automigrationResults[oldConfigDir];
      }
    }
  });
  return {
    detectedAutomigrations,
    automigrationResults
  };
}
__name(runAutomigrations, "runAutomigrations");

// src/upgrade.ts
function getUpgradeResults(projectResults, doctorResults) {
  const successfulProjects = [];
  const failedProjects = [];
  const projectsWithNoFixes = [];
  const allProjects = Object.entries(projectResults).map(([configDir, resultData]) => {
    const automigrationResults = Object.entries(resultData.automigrationStatuses).map(
      ([fixId, status]) => {
        const succeeded = status === "succeeded" /* SUCCEEDED */ || status === "manual_succeeded" /* MANUAL_SUCCEEDED */;
        return {
          fixId,
          status,
          succeeded
        };
      }
    );
    const hasFailures2 = automigrationResults.some(
      (fix) => fix.status === "failed" /* FAILED */ || fix.status === "check_failed" /* CHECK_FAILED */
    );
    const hasSuccessfulFixes = automigrationResults.some(
      (fix) => fix.status === "succeeded" /* SUCCEEDED */ || fix.status === "manual_succeeded" /* MANUAL_SUCCEEDED */
    );
    const noFixesNeeded = Object.keys(resultData.automigrationStatuses).length === 0;
    const migratedSuccessfully = hasSuccessfulFixes && !hasFailures2;
    const hasDoctorReport = !!doctorResults[configDir];
    if (hasFailures2) {
      failedProjects.push(configDir);
    } else if (migratedSuccessfully) {
      successfulProjects.push(configDir);
    } else if (noFixesNeeded) {
      projectsWithNoFixes.push(configDir);
    }
    return {
      configDir,
      migratedSuccessfully,
      hasDoctorReport,
      automigrations: {
        fixes: automigrationResults,
        noFixesNeeded,
        hasFailures: hasFailures2,
        hasSuccessfulFixes
      },
      doctor: doctorResults[configDir] ? {
        status: doctorResults[configDir].status,
        isHealthy: doctorResults[configDir].status === "healthy"
      } : null
    };
  });
  return {
    allProjects,
    successfulProjects,
    failedProjects,
    projectsWithNoFixes
  };
}
__name(getUpgradeResults, "getUpgradeResults");
function logUpgradeResults(projectResults, detectedAutomigrations, doctorResults) {
  const { successfulProjects, failedProjects, projectsWithNoFixes } = getUpgradeResults(
    projectResults,
    doctorResults
  );
  if (failedProjects.length > 0) {
    logTracker3.enableLogWriting();
    logger20.step(
      "The upgrade is complete, but some projects failed to upgrade or migrate completely. Please see the debug logs for more details."
    );
    if (successfulProjects.length > 0) {
      const successfulProjectsList = successfulProjects.map((dir) => `  \u2022 ${shortenPath(dir)}`).join("\n");
      logger20.log(`${CLI_COLORS3.success("Successfully upgraded:")}
${successfulProjectsList}`);
    }
    const failedProjectsList = failedProjects.map((dir) => `  \u2022 ${shortenPath(dir)}`).join("\n");
    logger20.log(
      `${CLI_COLORS3.error("Failed to upgrade:")}
Some automigrations failed, please check the logs in the log file for more details.
${failedProjectsList}`
    );
    if (projectsWithNoFixes.length > 0) {
      const projectList = projectsWithNoFixes.map((dir) => `  \u2022 ${shortenPath(dir)}`).join("\n");
      logger20.log(`${CLI_COLORS3.info("No applicable migrations:")}
${projectList}`);
    }
  } else {
    logger20.step("The upgrade is complete!");
    if (Object.values(doctorResults).every((result) => result.status === "healthy")) {
      logger20.log(`${CLI_COLORS3.success("Your project(s) have been upgraded successfully! \u{1F389}")}`);
    } else {
      logger20.log(
        `${import_picocolors16.default.yellow("Your project(s) have been upgraded successfully, but some issues were found which need your attention, please check Storybook doctor logs above.")}`
      );
    }
  }
  const automigrationLinks = detectedAutomigrations.filter(
    (am) => Object.entries(projectResults).some(
      ([_, resultData]) => resultData.automigrationStatuses[am.fix.id] === "failed" /* FAILED */ || resultData.automigrationStatuses[am.fix.id] === "succeeded" /* SUCCEEDED */ || resultData.automigrationStatuses[am.fix.id] === "check_failed" /* CHECK_FAILED */
    )
  ).map((am) => `\u2022 ${createHyperlink(am.fix.id, am.fix.link)}`);
  if (automigrationLinks.length > 0) {
    const automigrationLinksMessage = [
      "If you want to learn more about the automigrations that executed in your project(s), please check the following links:\n",
      ...automigrationLinks
    ].join("\n");
    logger20.log(automigrationLinksMessage);
  }
  logger20.log(
    `For a full list of changes, please check our migration guide: ${CLI_COLORS3.cta("https://storybook.js.org/docs/releases/migration-guide?ref=upgrade")}`
  );
}
__name(logUpgradeResults, "logUpgradeResults");
async function sendMultiUpgradeTelemetry(options) {
  const {
    allProjects,
    selectedProjects,
    projectResults,
    doctorResults,
    hasUserInterrupted = false
  } = options;
  const { successfulProjects, failedProjects, projectsWithNoFixes } = getUpgradeResults(
    projectResults,
    doctorResults
  );
  const processedProjects = /* @__PURE__ */ new Set([
    ...Object.keys(projectResults),
    ...Object.keys(doctorResults)
  ]);
  const incompleteProjects = selectedProjects.map((p) => p.configDir).filter((configDir) => !processedProjects.has(configDir));
  const projectsWithDoctorReports = Object.values(doctorResults).filter(
    (result) => result.status !== "healthy"
  ).length;
  try {
    await telemetry("multi-upgrade", {
      totalDetectedProjects: allProjects.length,
      totalSelectedProjects: selectedProjects.length,
      projectsWithSuccessfulAutomigrations: successfulProjects.length,
      projectsWithFailedAutomigrations: failedProjects.length,
      projectsWithNoAutomigrations: projectsWithNoFixes.length,
      projectsWithDoctorReports,
      incompleteProjects: incompleteProjects.length,
      hasUserInterrupted
    });
  } catch (error) {
    logger20.debug(`Failed to send multi-upgrade telemetry: ${String(error)}`);
  }
}
__name(sendMultiUpgradeTelemetry, "sendMultiUpgradeTelemetry");
async function upgrade(options) {
  await withTelemetry(
    "upgrade",
    { cliOptions: { ...options, configDir: options.configDir?.[0] } },
    async () => {
      logger20.intro(`Storybook Upgrade - ${import_picocolors16.default.bold(`v${versions4.storybook}`)}`);
      const projectsResult = await getProjects(options);
      if (projectsResult === void 0 || projectsResult.selectedProjects.length === 0) {
        return;
      }
      const { allProjects, selectedProjects: storybookProjects } = projectsResult;
      if (storybookProjects.length > 1) {
        logger20.info(`Upgrading the following projects:
          ${storybookProjects.map((p) => `${import_picocolors16.default.cyan(shortenPath(p.configDir))}: ${import_picocolors16.default.bold(p.beforeVersion)} -> ${import_picocolors16.default.bold(p.currentCLIVersion)}`).join("\n")}`);
      } else {
        logger20.info(
          `Upgrading from ${import_picocolors16.default.bold(storybookProjects[0].beforeVersion)} to ${import_picocolors16.default.bold(storybookProjects[0].currentCLIVersion)}`
        );
      }
      const automigrationResults = {};
      let doctorResults = {};
      const handleInterruption = /* @__PURE__ */ __name(async () => {
        logger20.log("\n\nUpgrade interrupted by user.");
        if (allProjects.length > 1) {
          await sendMultiUpgradeTelemetry({
            allProjects,
            selectedProjects: storybookProjects,
            projectResults: automigrationResults,
            doctorResults,
            hasUserInterrupted: true
          });
        }
        throw new HandledError("Upgrade cancelled by user");
      }, "handleInterruption");
      process.on("SIGINT", handleInterruption);
      process.on("SIGTERM", handleInterruption);
      try {
        const hasBlockers = processAutoblockerResults(storybookProjects, (message) => {
          logger20.error(dedent15`Blockers detected\n\n${message}`);
        });
        if (hasBlockers) {
          throw new HandledError("Blockers detected");
        }
        storybookProjects.some((project) => {
          if (!project.isCanary && (0, import_semver7.lt)(project.currentCLIVersion, project.beforeVersion)) {
            throw new UpgradeStorybookToLowerVersionError({
              beforeVersion: project.beforeVersion,
              currentVersion: project.currentCLIVersion
            });
          }
          if (!project.beforeVersion) {
            throw new UpgradeStorybookUnknownCurrentVersionError();
          }
        });
        if (!options.dryRun) {
          const task = prompt6.taskLog({
            id: "upgrade-dependencies",
            title: `Fetching versions to update package.json files..`
          });
          try {
            const loggedPaths = [];
            for (const project of storybookProjects) {
              logger20.debug(`Updating dependencies in ${shortenPath(project.configDir)}...`);
              const packageJsonPaths = project.packageManager.packageJsonPaths.map(shortenPath);
              const newPaths = packageJsonPaths.filter((path4) => !loggedPaths.includes(path4));
              if (newPaths.length > 0) {
                task.message(newPaths.join("\n"));
                loggedPaths.push(...newPaths);
              }
              await upgradeStorybookDependencies({
                packageManager: project.packageManager,
                isCanary: project.isCanary,
                isCLIOutdated: project.isCLIOutdated,
                isCLIPrerelease: project.isCLIPrerelease,
                isCLIExactLatest: project.isCLIExactLatest,
                isCLIExactPrerelease: project.isCLIExactPrerelease
              });
            }
            task.success(`Updated package versions in package.json files`);
          } catch (err) {
            task.error(`Failed to upgrade dependencies: ${String(err)}`);
          }
        }
        const { automigrationResults: automigrationResults2, detectedAutomigrations } = await runAutomigrations(
          storybookProjects,
          options
        );
        const rootPackageManager = storybookProjects.length > 1 ? JsPackageManagerFactory2.getPackageManager({ force: options.packageManager }) : storybookProjects[0].packageManager;
        if (rootPackageManager.type === "npm") {
          await rootPackageManager.installDependencies({ force: true });
        } else {
          await rootPackageManager.installDependencies();
        }
        if (rootPackageManager.type !== "yarn1" && rootPackageManager.isStorybookInMonorepo()) {
          logger20.warn(
            `Since you are in a monorepo, we advise you to deduplicate your dependencies. We can do this for you but it might take some time.`
          );
          const dedupe = options.yes || await prompt6.confirm({
            message: `Execute ${rootPackageManager.getRunCommand("dedupe")}?`,
            initialValue: true
          });
          if (dedupe) {
            if (rootPackageManager.type === "npm") {
              await rootPackageManager.dedupeDependencies({ force: true });
            } else {
              await rootPackageManager.dedupeDependencies();
            }
          } else {
            logger20.log(
              `If you find any issues running Storybook, you can run ${rootPackageManager.getRunCommand("dedupe")} manually to deduplicate your dependencies and try again.`
            );
          }
        }
        const doctorProjects = storybookProjects.map((project) => ({
          configDir: project.configDir,
          packageManager: project.packageManager,
          storybookVersion: project.currentCLIVersion,
          mainConfig: project.mainConfig
        }));
        logger20.step("Checking the health of your project(s)..");
        doctorResults = await runMultiProjectDoctor(doctorProjects);
        const hasIssues = displayDoctorResults(doctorResults);
        if (hasIssues) {
          logTracker3.enableLogWriting();
        }
        logUpgradeResults(automigrationResults2, detectedAutomigrations, doctorResults);
        if (!options.disableTelemetry) {
          for (const project of storybookProjects) {
            const resultData = automigrationResults2[project.configDir] || {
              automigrationStatuses: {},
              automigrationErrors: {}
            };
            let doctorFailureCount = 0;
            let doctorErrorCount = 0;
            Object.values(doctorResults[project.configDir]?.diagnostics || {}).forEach((status) => {
              if (status === "has_issues") {
                doctorFailureCount++;
              }
              if (status === "check_error") {
                doctorErrorCount++;
              }
            });
            const automigrationFailureCount = Object.keys(resultData.automigrationErrors).length;
            const automigrationPreCheckFailure = project.autoblockerCheckResults && project.autoblockerCheckResults.length > 0 ? project.autoblockerCheckResults?.map((result) => {
              if (result.result !== null) {
                return result.blocker.id;
              }
              return null;
            }).filter(Boolean) : null;
            await telemetry("upgrade", {
              beforeVersion: project.beforeVersion,
              afterVersion: project.currentCLIVersion,
              automigrationResults: resultData.automigrationStatuses,
              automigrationErrors: resultData.automigrationErrors,
              automigrationFailureCount,
              automigrationPreCheckFailure,
              doctorResults: doctorResults[project.configDir]?.diagnostics || {},
              doctorFailureCount,
              doctorErrorCount
            });
          }
          await sendMultiUpgradeTelemetry({
            allProjects,
            selectedProjects: storybookProjects,
            projectResults: automigrationResults2,
            doctorResults
          });
        }
      } finally {
        process.removeListener("SIGINT", handleInterruption);
        process.removeListener("SIGTERM", handleInterruption);
      }
    }
  );
}
__name(upgrade, "upgrade");

// src/bin/run.ts
addToGlobalContext("cliVersion", versions5.storybook);
var handleCommandFailure = /* @__PURE__ */ __name(async (error) => {
  if (!(error instanceof HandledError2)) {
    logger21.error(String(error));
  }
  const logFile = await logTracker4.writeToFile();
  logger21.log(`Storybook debug logs can be found at: ${logFile}`);
  logger21.outro("");
  process.exit(1);
}, "handleCommandFailure");
var command = /* @__PURE__ */ __name((name) => program.command(name).option(
  "--disable-telemetry",
  "Disable sending telemetry data",
  optionalEnvToBoolean3(process.env.STORYBOOK_DISABLE_TELEMETRY)
).option("--debug", "Get more logs in debug mode", false).option("--enable-crash-reports", "Enable sending crash reports to telemetry data").option("--write-logs", "Write all debug logs to a file at the end of the run").option("--loglevel <trace | debug | info | warn | error | silent>", "Define log level", "info").hook("preAction", async (self2) => {
  try {
    const options = self2.opts();
    if (options.loglevel) {
      logger21.setLogLevel(options.loglevel);
    }
    if (options.writeLogs) {
      logTracker4.enableLogWriting();
    }
    await globalSettings();
  } catch (e) {
    logger21.error("Error loading global settings:\n" + String(e));
  }
}).hook("postAction", async () => {
  if (logTracker4.shouldWriteLogsToFile) {
    const logFile = await logTracker4.writeToFile();
    logger21.log(`Storybook debug logs can be found at: ${logFile}`);
    logger21.outro(CLI_COLORS4.success("Done!"));
  }
}), "command");
command("init").description("Initialize Storybook into your project").option("-f --force", "Force add Storybook").option("-s --skip-install", "Skip installing deps").option("--package-manager <npm|pnpm|yarn1|yarn2>", "Force package manager for installing deps").option("--use-pnp", "Enable PnP mode for Yarn 2+").option("-p --parser <babel | babylon | flow | ts | tsx>", "jscodeshift parser").option("-t --type <type>", "Add Storybook for a specific project type").option("-y --yes", "Answer yes to all prompts").option("-b --builder <webpack5 | vite>", "Builder library").option("-l --linkable", "Prepare installation for link (contributor helper)").option(
  "--dev",
  "Launch the development server after completing initialization. Enabled by default (default: true)",
  !isCI2() && !optionalEnvToBoolean3(process.env.IN_STORYBOOK_SANDBOX)
).option(
  "--no-dev",
  "Complete the initialization of Storybook without launching the Storybook development server"
);
command("add <addon>").description("Add an addon to your Storybook").option(
  "--package-manager <npm|pnpm|yarn1|yarn2|bun>",
  "Force package manager for installing dependencies"
).option("-c, --config-dir <dir-name>", "Directory where to load Storybook configurations from").option("--skip-install", "Skip installing deps").option("-s --skip-postinstall", "Skip package specific postinstall config modifications").option("-y --yes", "Skip prompting the user").option("--skip-doctor", "Skip doctor check").action((addonName, options) => add(addonName, options));
command("remove <addon>").description("Remove an addon from your Storybook").option(
  "--package-manager <npm|pnpm|yarn1|yarn2|bun>",
  "Force package manager for installing dependencies"
).option("-c, --config-dir <dir-name>", "Directory where to load Storybook configurations from").option("-s --skip-install", "Skip installing deps").action(
  (addonName, options) => withTelemetry2("remove", { cliOptions: options }, async () => {
    const packageManager = JsPackageManagerFactory3.getPackageManager({
      configDir: options.configDir,
      force: options.packageManager
    });
    await remove(addonName, {
      configDir: options.configDir,
      packageManager,
      skipInstall: options.skipInstall
    });
    if (!options.disableTelemetry) {
      await telemetry2("remove", { addon: addonName, source: "cli" });
    }
  })
);
command("upgrade").description(`Upgrade your Storybook packages to v${versions5.storybook}`).option(
  "--package-manager <npm|pnpm|yarn1|yarn2|bun>",
  "Force package manager for installing dependencies"
).option("-y --yes", "Skip prompting the user").option("-f --force", "force the upgrade, skipping autoblockers").option("-n --dry-run", "Only check for upgrades, do not install").option("-s --skip-check", "Skip postinstall version and automigration checks").option(
  "-c, --config-dir <dir-name...>",
  "Directory(ies) where to load Storybook configurations from"
).action(async (options) => {
  prompt7.setPromptLibrary("clack");
  await upgrade(options).catch(handleCommandFailure);
});
command("info").description("Prints debugging information about the local environment").action(async () => {
  logger21.log(import_picocolors17.default.bold("\nStorybook Environment Info:"));
  const pkgManager = JsPackageManagerFactory3.getPackageManager();
  const activePackageManager = pkgManager.type.replace(/\d/, "");
  const output = await import_envinfo.default.run({
    System: ["OS", "CPU", "Shell"],
    Binaries: ["Node", "Yarn", "npm", "pnpm"],
    Browsers: ["Chrome", "Edge", "Firefox", "Safari"],
    npmPackages: "{@storybook/*,*storybook*,sb,chromatic}",
    npmGlobalPackages: "{@storybook/*,*storybook*,sb,chromatic}"
  });
  const activePackageManagerLine = output.match(new RegExp(`${activePackageManager}:.*`, "i"));
  logger21.log(
    output.replace(
      activePackageManagerLine,
      import_picocolors17.default.bold(`${activePackageManagerLine} <----- active`)
    )
  );
});
command("migrate [migration]").description("Run a Storybook codemod migration on your source files").option("-l --list", "List available migrations").option("-g --glob <glob>", "Glob for files upon which to apply the migration", "**/*.js").option("-p --parser <babel | babylon | flow | ts | tsx>", "jscodeshift parser").option("-c, --config-dir <dir-name>", "Directory where to load Storybook configurations from").option(
  "-n --dry-run",
  "Dry run: verify the migration exists and show the files to which it will be applied"
).option(
  "-r --rename <from-to>",
  'Rename suffix of matching files after codemod has been applied, e.g. ".js:.ts"'
).action((migration, { configDir, glob, dryRun, list, rename: rename2, parser }) => {
  migrate(migration, {
    configDir,
    glob,
    dryRun,
    list,
    rename: rename2,
    parser
  }).catch(handleCommandFailure);
});
command("sandbox [filterValue]").alias("repro").description("Create a sandbox from a set of possible templates").option("-o --output <outDir>", "Define an output directory").option("--no-init", "Whether to download a template without an initialized Storybook", false).action(
  (filterValue, options) => sandbox({ filterValue, ...options }).catch(handleCommandFailure)
);
command("link <repo-url-or-directory>").description("Pull down a repro from a URL (or a local directory), link it, and run storybook").option("--local", "Link a local directory already in your file system").option("--no-start", "Start the storybook", true).action((target, { local, start }) => link({ target, local, start }).catch(handleCommandFailure));
command("automigrate [fixId]").description("Check storybook for incompatibilities or migrations and apply fixes").option("-y --yes", "Skip prompting the user").option("-n --dry-run", "Only check for fixes, do not actually run them").option("--package-manager <npm|pnpm|yarn1|yarn2|bun>", "Force package manager").option("-l --list", "List available migrations").option("-c, --config-dir <dir-name>", "Directory of Storybook configurations to migrate").option("-s --skip-install", "Skip installing deps").option(
  "--renderer <renderer-pkg-name>",
  "The renderer package for the framework Storybook is using."
).option("--skip-doctor", "Skip doctor check").action(async (fixId, options) => {
  prompt7.setPromptLibrary("clack");
  await doAutomigrate({ fixId, ...options }).catch(handleCommandFailure);
});
command("doctor").description("Check Storybook for known problems and provide suggestions or fixes").option("--package-manager <npm|pnpm|yarn1|yarn2|bun>", "Force package manager").option("-c, --config-dir <dir-name>", "Directory of Storybook configuration").action(async (options) => {
  await doctor(options).catch(handleCommandFailure);
});
program.on("command:*", ([invalidCmd]) => {
  let errorMessage = ` Invalid command: ${import_picocolors17.default.bold(invalidCmd)}.
 See --help for a list of available commands.`;
  const availableCommands = program.commands.map((cmd) => cmd.name());
  const suggestion = availableCommands.find((cmd) => leven(cmd, invalidCmd) < 3);
  if (suggestion) {
    errorMessage += `
 Did you mean ${import_picocolors17.default.yellow(suggestion)}?`;
  }
  logger21.error(errorMessage);
  process.exit(1);
});
program.usage("<command> [options]").version(String(version)).parse(process.argv);
